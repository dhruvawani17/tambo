"use client";
import React, { createContext, useCallback, useContext, useEffect, useMemo, useState, } from "react";
import { deduplicateMcpServers, normalizeServerInfo, } from "../util/mcp-server-utils";
import { validateAndPrepareComponent, validateTool, validateToolAssociation, } from "../util/registry-validators";
import { validateResource, validateResourceSource, } from "../util/resource-validators";
export const TamboRegistryContext = createContext({
    componentList: {},
    toolRegistry: {},
    componentToolAssociations: {},
    mcpServerInfos: [],
    resources: [],
    resourceSource: null,
    /**
     *
     */
    registerComponent: () => { },
    /**
     *
     */
    registerTool: () => { },
    /**
     *
     */
    registerTools: () => { },
    /**
     *
     */
    addToolAssociation: () => { },
    /**
     *
     */
    registerMcpServer: () => { },
    /**
     *
     */
    registerMcpServers: () => { },
    /**
     *
     */
    registerResource: () => { },
    /**
     *
     */
    registerResources: () => { },
    /**
     *
     */
    registerResourceSource: () => { },
});
/**
 * The TamboRegistryProvider is a React provider that provides a component
 * registry to the descendants of the provider.
 * @param props - The props for the TamboRegistryProvider
 * @param props.children - The children to wrap
 * @param props.components - The components to register
 * @param props.tools - The tools to register
 * @param props.mcpServers - The MCP servers to register
 * @param props.resources - The static resources to register
 * @param props.listResources - The dynamic resource search function (must be paired with getResource)
 * @param props.getResource - The dynamic resource fetch function (must be paired with listResources)
 * @param props.onCallUnregisteredTool - The function to call when an unknown tool is called (optional)
 * @returns The TamboRegistryProvider component
 */
export const TamboRegistryProvider = ({ children, components: userComponents, tools: userTools, mcpServers: userMcpServers, resources: userResources, listResources: userListResources, getResource: userGetResource, onCallUnregisteredTool, }) => {
    const [componentList, setComponentList] = useState({});
    const [toolRegistry, setToolRegistry] = useState({});
    const [componentToolAssociations, setComponentToolAssociations] = useState({});
    const [staticMcpServerInfos, setStaticMcpServerInfos] = useState([]);
    const [dynamicMcpServerInfos, setDynamicMcpServerInfos] = useState([]);
    const [staticResources, setStaticResources] = useState([]);
    const [resourceSource, setResourceSource] = useState(null);
    const registryWithTool = useCallback((warnOnOverwrite) => {
        return (registry, tool) => {
            validateTool(tool);
            if (registry[tool.name] && warnOnOverwrite) {
                console.warn(`Overwriting tool ${tool.name}`);
            }
            return {
                ...registry,
                [tool.name]: tool,
            };
        };
    }, []);
    const registerTool = useCallback((tool, warnOnOverwrite = true) => {
        setToolRegistry((registry) => registryWithTool(warnOnOverwrite)(registry, tool));
    }, [registryWithTool]);
    const registerTools = useCallback((tools, warnOnOverwrite = true) => {
        setToolRegistry((existingRegistry) => tools.reduce(registryWithTool(warnOnOverwrite), existingRegistry));
    }, [registryWithTool]);
    const registerMcpServer = useCallback((info) => {
        const normalized = normalizeServerInfo(info);
        setDynamicMcpServerInfos((prev) => [...prev, normalized]);
    }, []);
    const registerMcpServers = useCallback((infos) => {
        const normalized = infos.map(normalizeServerInfo);
        setDynamicMcpServerInfos((prev) => [...prev, ...normalized]);
    }, []);
    const addToolAssociation = useCallback((componentName, tool) => {
        validateToolAssociation(componentName, tool.name, !!componentList[componentName], !!toolRegistry[tool.name]);
        setComponentToolAssociations((prev) => ({
            ...prev,
            [componentName]: [...(prev[componentName] || []), tool.name],
        }));
    }, [componentList, toolRegistry]);
    const registerComponent = useCallback((options, warnOnOverwrite = true) => {
        const { name, description, component, loadingComponent, associatedTools, } = options;
        const { props } = validateAndPrepareComponent(options);
        setComponentList((prev) => {
            if (prev[name] && warnOnOverwrite) {
                console.warn(`overwriting component ${name}`);
            }
            return {
                ...prev,
                [name]: {
                    component,
                    loadingComponent,
                    name,
                    description,
                    props,
                    contextTools: [],
                },
            };
        });
        if (associatedTools) {
            registerTools(associatedTools);
            setComponentToolAssociations((prev) => ({
                ...prev,
                [name]: associatedTools.map((tool) => tool.name),
            }));
        }
    }, [registerTools]);
    useEffect(() => {
        if (userComponents) {
            userComponents.forEach((component) => {
                registerComponent(component, false);
            });
        }
    }, [registerComponent, userComponents]);
    useEffect(() => {
        if (userTools) {
            registerTools(userTools, false);
        }
    }, [registerTools, userTools]);
    useEffect(() => {
        if (!userMcpServers || userMcpServers.length === 0) {
            setStaticMcpServerInfos([]);
            return;
        }
        // Normalize servers from props and ensure all have serverKey and transport
        const normalized = userMcpServers.map(normalizeServerInfo);
        setStaticMcpServerInfos(normalized);
    }, [userMcpServers]);
    useEffect(() => {
        // Validate that listResources and getResource are both provided or both omitted
        validateResourceSource(userListResources, userGetResource);
        // Set static resources from props
        if (userResources) {
            userResources.forEach((resource) => validateResource(resource));
            setStaticResources(userResources);
        }
        else {
            setStaticResources([]);
        }
        // Set resource source from props
        if (userListResources && userGetResource) {
            setResourceSource({
                listResources: userListResources,
                getResource: userGetResource,
            });
        }
        else {
            setResourceSource(null);
        }
    }, [userResources, userListResources, userGetResource]);
    const registerResource = useCallback((resource) => {
        validateResource(resource);
        setStaticResources((prev) => [...prev, resource]);
    }, []);
    const registerResources = useCallback((resources) => {
        resources.forEach((resource) => validateResource(resource));
        setStaticResources((prev) => [...prev, ...resources]);
    }, []);
    const registerResourceSource = useCallback((source) => {
        validateResourceSource(source.listResources, source.getResource);
        setResourceSource(source);
    }, []);
    const mcpServerInfos = useMemo(() => {
        const allServers = [...staticMcpServerInfos, ...dynamicMcpServerInfos];
        return deduplicateMcpServers(allServers);
    }, [staticMcpServerInfos, dynamicMcpServerInfos]);
    const value = {
        componentList,
        toolRegistry,
        componentToolAssociations,
        mcpServerInfos,
        resources: staticResources,
        resourceSource,
        registerComponent,
        registerTool,
        registerTools,
        addToolAssociation,
        registerMcpServer,
        registerMcpServers,
        registerResource,
        registerResources,
        registerResourceSource,
        onCallUnregisteredTool,
    };
    return (React.createElement(TamboRegistryContext.Provider, { value: value }, children));
};
/**
 * The useTamboRegistry hook provides access to the component registry
 * to the descendants of the TamboRegistryProvider.
 * @returns The component registry
 */
export const useTamboRegistry = () => {
    return useContext(TamboRegistryContext);
};
/**
 * Hook to access the MCP server metadata from TamboRegistryProvider.
 * This provides access to the registered MCP server configurations (metadata only, not connections).
 *
 * This hook can be used anywhere within the TamboProvider hierarchy to access
 * the list of configured MCP servers without needing to be inside TamboMcpProvider.
 * @returns Array of MCP server metadata
 * @example
 * ```tsx
 * function MyComponent() {
 *   const mcpServers = useTamboMcpServerInfos();
 *
 *   return (
 *     <div>
 *       <h3>Configured MCP Servers:</h3>
 *       {mcpServers.map((server) => (
 *         <div key={server.url}>
 *           {server.name || server.url}
 *         </div>
 *       ))}
 *     </div>
 *   );
 * }
 * ```
 *
 * The returned objects are `NormalizedMcpServerInfo` instances, meaning both
 * `serverKey` and `transport` are always populated (with `transport`
 * defaulting to HTTP when not explicitly specified).
 */
export const useTamboMcpServerInfos = () => {
    return useContext(TamboRegistryContext).mcpServerInfos;
};
//# sourceMappingURL=tambo-registry-provider.js.map