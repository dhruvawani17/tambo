import { render, waitFor } from "@testing-library/react";
import React from "react";
import { z } from "zod/v4";
import { withTamboInteractable } from "../hoc/with-tambo-interactable";
import { TamboContextHelpersProvider, useTamboContextHelpers, } from "./tambo-context-helpers-provider";
import { TamboInteractableProvider, useCurrentInteractablesSnapshot, } from "./tambo-interactable-provider";
import { TamboStubProvider } from "./tambo-stubs";
function wrapperWithProviders(children) {
    const thread = {
        id: "t-1",
        projectId: "p-1",
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        messages: [],
        metadata: {},
    };
    return (React.createElement(TamboStubProvider, { thread: thread, registerTool: () => { }, registerTools: () => { }, registerComponent: () => { }, addToolAssociation: () => { } },
        React.createElement(TamboContextHelpersProvider, null, children)));
}
describe("Interactables AdditionalContext (provider-based)", () => {
    test("registers default helper and returns payload with description and components", async () => {
        const Note = ({ title }) => React.createElement("div", null, title);
        const InteractableNote = withTamboInteractable(Note, {
            componentName: "Note",
            description: "A note",
            propsSchema: z.object({ title: z.string() }),
        });
        let capturedContexts = [];
        const TestComponent = () => {
            const { getAdditionalContext } = useTamboContextHelpers();
            React.useEffect(() => {
                let mounted = true;
                void getAdditionalContext().then((contexts) => {
                    if (mounted) {
                        capturedContexts = contexts;
                    }
                });
                return () => {
                    mounted = false;
                };
            }, [getAdditionalContext]);
            return React.createElement("div", { "data-testid": "ready" }, "ready");
        };
        const { getByTestId } = render(wrapperWithProviders(React.createElement(TamboInteractableProvider, null,
            React.createElement(InteractableNote, { title: "hello" }),
            React.createElement(TestComponent, null))));
        await waitFor(() => {
            expect(getByTestId("ready")).toBeInTheDocument();
            const entry = capturedContexts.find((c) => c.name === "interactables");
            expect(entry).toBeDefined();
            expect(Array.isArray(entry?.context?.components)).toBe(true);
            const comp = entry.context.components[0];
            expect(comp.componentName).toBe("Note");
            expect(comp.props).toEqual({ title: "hello" });
        });
    });
    test("returns null when no interactable components are present", async () => {
        let capturedContexts = [];
        const TestComponent = () => {
            const { getAdditionalContext } = useTamboContextHelpers();
            React.useEffect(() => {
                let mounted = true;
                void getAdditionalContext().then((contexts) => {
                    if (mounted) {
                        capturedContexts = contexts;
                    }
                });
                return () => {
                    mounted = false;
                };
            }, [getAdditionalContext]);
            return React.createElement("div", { "data-testid": "ready" }, "ready");
        };
        const { getByTestId } = render(wrapperWithProviders(React.createElement(TamboInteractableProvider, null,
            React.createElement("div", null, "No interactables here"),
            React.createElement(TestComponent, null))));
        await waitFor(() => {
            expect(getByTestId("ready")).toBeInTheDocument();
            const entry = capturedContexts.find((c) => c.name === "interactables");
            expect(entry).toBeUndefined(); // Should be filtered out when helper returns null
        });
    });
    test("context includes proper AI prompt with clear instructions", async () => {
        const Note = ({ title }) => React.createElement("div", null, title);
        const InteractableNote = withTamboInteractable(Note, {
            componentName: "Note",
            description: "A simple note",
            propsSchema: z.object({ title: z.string() }),
        });
        let capturedContexts = [];
        const TestComponent = () => {
            const { getAdditionalContext } = useTamboContextHelpers();
            React.useEffect(() => {
                let mounted = true;
                void getAdditionalContext().then((contexts) => {
                    if (mounted) {
                        capturedContexts = contexts;
                    }
                });
                return () => {
                    mounted = false;
                };
            }, [getAdditionalContext]);
            return React.createElement("div", { "data-testid": "ready" }, "ready");
        };
        const { getByTestId } = render(wrapperWithProviders(React.createElement(TamboInteractableProvider, null,
            React.createElement(InteractableNote, { title: "test" }),
            React.createElement(TestComponent, null))));
        await waitFor(() => {
            expect(getByTestId("ready")).toBeInTheDocument();
            const entry = capturedContexts.find((c) => c.name === "interactables");
            expect(entry).toBeDefined();
            expect(Array.isArray(entry?.context?.components)).toBe(true);
        });
    });
    test("includes component metadata in expected format", async () => {
        const Note = ({ title, color = "white", }) => React.createElement("div", { className: `note-${color}` }, title);
        const InteractableNote = withTamboInteractable(Note, {
            componentName: "Note",
            description: "A colorful note component",
            propsSchema: z.object({
                title: z.string(),
                color: z.string().optional(),
            }),
        });
        let capturedContexts = [];
        const TestComponent = () => {
            const { getAdditionalContext } = useTamboContextHelpers();
            React.useEffect(() => {
                let mounted = true;
                void getAdditionalContext().then((contexts) => {
                    if (mounted) {
                        capturedContexts = contexts;
                    }
                });
                return () => {
                    mounted = false;
                };
            }, [getAdditionalContext]);
            return React.createElement("div", { "data-testid": "ready" }, "ready");
        };
        const { getByTestId } = render(wrapperWithProviders(React.createElement(TamboInteractableProvider, null,
            React.createElement(InteractableNote, { title: "test note", color: "blue" }),
            React.createElement(TestComponent, null))));
        await waitFor(() => {
            expect(getByTestId("ready")).toBeInTheDocument();
            const entry = capturedContexts.find((c) => c.name === "interactables");
            const component = entry.context.components[0];
            expect(component).toMatchObject({
                id: expect.any(String),
                componentName: "Note",
                description: "A colorful note component",
                props: { title: "test note", color: "blue" },
                propsSchema: "Available - use component-specific update tools",
            });
        });
    });
    test("snapshot hook returns immutable copies", async () => {
        const Note = ({ title }) => React.createElement("div", null, title);
        const InteractableNote = withTamboInteractable(Note, {
            componentName: "Note",
            description: "A note",
            propsSchema: z.object({ title: z.string() }),
        });
        const TestComponent = () => {
            const snapshot = useCurrentInteractablesSnapshot();
            const [testResult, setTestResult] = React.useState("pending");
            React.useEffect(() => {
                if (snapshot.length > 0) {
                    const originalLength = snapshot.length;
                    // Try to mutate the returned array and props
                    snapshot.push({
                        id: "fake",
                        name: "Fake",
                        description: "",
                        component: () => null,
                        props: {},
                    });
                    snapshot[0].props.title = "MUTATED";
                    // The mutations should succeed on the returned copy, proving it's a separate object
                    if (snapshot.length === originalLength + 1 &&
                        snapshot[0].props.title === "MUTATED") {
                        setTestResult("mutation-successful-but-isolated");
                    }
                    else {
                        setTestResult("mutation-failed");
                    }
                }
            }, [snapshot]);
            return React.createElement("div", { "data-testid": "test-result" }, testResult);
        };
        const { getByTestId } = render(wrapperWithProviders(React.createElement(TamboInteractableProvider, null,
            React.createElement(InteractableNote, { title: "immutable test" }),
            React.createElement(TestComponent, null))));
        await waitFor(() => {
            const result = getByTestId("test-result").textContent;
            expect(result).toBe("mutation-successful-but-isolated");
        });
    });
    test("multiple interactables from same provider appear in context", async () => {
        const Note = ({ title }) => React.createElement("div", null, title);
        const Counter = ({ count }) => (React.createElement("div", null, count));
        const InteractableNote = withTamboInteractable(Note, {
            componentName: "Note",
            description: "A note",
            propsSchema: z.object({ title: z.string() }),
        });
        const InteractableCounter = withTamboInteractable(Counter, {
            componentName: "Counter",
            description: "A counter",
            propsSchema: z.object({ count: z.number() }),
        });
        let capturedContexts = [];
        const TestComponent = () => {
            const { getAdditionalContext } = useTamboContextHelpers();
            React.useEffect(() => {
                let mounted = true;
                void getAdditionalContext().then((contexts) => {
                    if (mounted) {
                        capturedContexts = contexts;
                    }
                });
                return () => {
                    mounted = false;
                };
            }, [getAdditionalContext]);
            return React.createElement("div", { "data-testid": "ready" }, "ready");
        };
        const { getByTestId } = render(wrapperWithProviders(React.createElement(TamboInteractableProvider, null,
            React.createElement(InteractableNote, { title: "first" }),
            React.createElement(InteractableCounter, { count: 42 }),
            React.createElement(TestComponent, null))));
        await waitFor(() => {
            expect(getByTestId("ready")).toBeInTheDocument();
            const entry = capturedContexts.find((c) => c.name === "interactables");
            expect(entry?.context?.components).toHaveLength(2);
            const components = entry.context.components;
            expect(components[0].componentName).toBe("Note");
            expect(components[0].props).toEqual({ title: "first" });
            expect(components[1].componentName).toBe("Counter");
            expect(components[1].props).toEqual({ count: 42 });
        });
    });
    test("can be disabled by returning null", async () => {
        const Note = ({ title }) => React.createElement("div", null, title);
        const InteractableNote = withTamboInteractable(Note, {
            componentName: "Note",
            description: "A note",
            propsSchema: z.object({ title: z.string() }),
        });
        // Create a context helpers provider with a disabled interactables helper
        const DisabledContextHelpers = ({ children, }) => (React.createElement(TamboContextHelpersProvider, { contextHelpers: {
                ["interactables"]: () => null,
            } }, children));
        let capturedContexts = [];
        const TestComponent = () => {
            const { getAdditionalContext } = useTamboContextHelpers();
            React.useEffect(() => {
                let mounted = true;
                void getAdditionalContext().then((contexts) => {
                    if (mounted) {
                        capturedContexts = contexts;
                    }
                });
                return () => {
                    mounted = false;
                };
            }, [getAdditionalContext]);
            return React.createElement("div", { "data-testid": "ready" }, "ready");
        };
        const thread = {
            id: "t-1",
            projectId: "p-1",
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            messages: [],
            metadata: {},
        };
        const { getByTestId } = render(React.createElement(TamboStubProvider, { thread: thread, registerTool: () => { }, registerTools: () => { }, registerComponent: () => { }, addToolAssociation: () => { } },
            React.createElement(DisabledContextHelpers, null,
                React.createElement(TamboInteractableProvider, null,
                    React.createElement(InteractableNote, { title: "should not appear" }),
                    React.createElement(TestComponent, null)))));
        await waitFor(() => {
            expect(getByTestId("ready")).toBeInTheDocument();
            const entry = capturedContexts.find((c) => c.name === "interactables");
            expect(entry).toBeUndefined(); // Should be filtered out when helper returns null
        });
    });
});
//# sourceMappingURL=tambo-interactables-additional-context.test.js.map