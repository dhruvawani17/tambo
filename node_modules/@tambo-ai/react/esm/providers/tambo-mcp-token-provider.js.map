{"version":3,"file":"tambo-mcp-token-provider.js","sourceRoot":"","sources":["../../src/providers/tambo-mcp-token-provider.tsx"],"names":[],"mappings":"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","sourcesContent":["\"use client\";\nimport React, {\n  createContext,\n  PropsWithChildren,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport { TamboThread } from \"../model/tambo-thread\";\nimport { TamboClientContext } from \"./tambo-client-provider\";\nimport {\n  PLACEHOLDER_THREAD,\n  TamboThreadContext,\n} from \"./tambo-thread-provider\";\n\nexport interface TamboMcpTokenContextProps {\n  /**\n   * The current MCP access token for the internal Tambo MCP server.\n   * Prefers thread-specific token over threadless token.\n   */\n  mcpAccessToken: string | null;\n  /**\n   * The base URL for the Tambo API (used to construct the MCP server URL)\n   * Returns undefined if the client is not yet initialized\n   */\n  tamboBaseUrl: string | undefined;\n}\n\nconst TamboMcpTokenContext = createContext<\n  TamboMcpTokenContextProps | undefined\n>(undefined);\n\n/**\n * Provider for managing the MCP access token that is returned by the Tambo API.\n * This token is used to authenticate with the internal Tambo MCP server.\n *\n * Token selection logic:\n * - Returns the current thread's mcpAccessToken if available\n * - Returns null if no thread or thread has no token\n *\n * Token fetching:\n * - Thread-specific token: always fetched when switching to thread without token\n * - Tokens are fetched regardless of client-side MCP server configuration\n *   to support server-side MCP servers that are not visible to the provider\n * - Threadless tokens must be fetched by individual hooks/callbacks using contextKey\n * @internal\n * @param props - The provider props\n * @param props.children - The children to wrap\n * @returns The TamboMcpTokenProvider component\n */\nexport const TamboMcpTokenProvider: React.FC<PropsWithChildren> = ({\n  children,\n}) => {\n  const clientContext = useContext(TamboClientContext);\n  if (!clientContext) {\n    throw new Error(\n      \"TamboMcpTokenProvider must be used within a TamboClientProvider\",\n    );\n  }\n  const { client } = clientContext;\n  const tamboBaseUrl = client.baseURL;\n\n  // Optional thread context - may not be available in all contexts\n  const threadContext = useContext(TamboThreadContext);\n  const currentThread = threadContext?.currentThread ?? null;\n  const currentThreadId = threadContext?.currentThreadId ?? null;\n  const setThreadMap = useMemo(\n    () => threadContext?.setThreadMap ?? (() => {}),\n    [threadContext?.setThreadMap],\n  );\n\n  // Track previous thread ID to detect thread switches\n  const previousThreadId = useRef<string | null>(null);\n\n  // Return the current thread's token or null\n  const selectedToken = useMemo(() => {\n    return currentThread?.mcpAccessToken ?? null;\n  }, [currentThread]);\n\n  // Fetch thread-specific token when switching to a thread without one\n  // Always fetch to support server-side MCP servers (not just client-side)\n  // Skip PLACEHOLDER_THREAD - never send it to the server\n  useEffect(() => {\n    const hasThreadChanged = previousThreadId.current !== currentThreadId;\n    previousThreadId.current = currentThreadId;\n\n    const isPlaceholderThread = currentThreadId === PLACEHOLDER_THREAD.id;\n    const shouldFetchThreadToken =\n      hasThreadChanged &&\n      currentThreadId &&\n      !isPlaceholderThread &&\n      currentThread &&\n      !currentThread.mcpAccessToken;\n\n    if (shouldFetchThreadToken) {\n      const fetchThreadToken = async () => {\n        try {\n          const response = await client.beta.auth.getMcpToken({\n            threadId: currentThreadId,\n          });\n          if (response.mcpAccessToken) {\n            // Update thread in threadMap with new token\n            setThreadMap((prev: Record<string, TamboThread>) => {\n              const thread = prev[currentThreadId];\n              if (thread) {\n                return {\n                  ...prev,\n                  [currentThreadId]: {\n                    ...thread,\n                    mcpAccessToken: response.mcpAccessToken,\n                  },\n                };\n              }\n              return prev;\n            });\n          }\n        } catch (error) {\n          console.error(\n            `Failed to fetch MCP token for thread ${currentThreadId}:`,\n            error,\n          );\n        }\n      };\n      void fetchThreadToken();\n    }\n  }, [currentThreadId, currentThread, client, setThreadMap]);\n\n  const value = useMemo(\n    () => ({ mcpAccessToken: selectedToken, tamboBaseUrl }),\n    [selectedToken, tamboBaseUrl],\n  );\n\n  return (\n    <TamboMcpTokenContext.Provider value={value}>\n      {children}\n    </TamboMcpTokenContext.Provider>\n  );\n};\n\n/**\n * Hook to access the current MCP access token with optional threadless token fetching.\n *\n * Token selection logic:\n * 1. If current thread has mcpAccessToken → use thread-specific token\n * 2. Else if contextKey provided and no thread (or placeholder thread) → fetch and use threadless token\n * 3. Else → null\n * @param contextKey - Optional context key for fetching threadless tokens when not in a thread\n * @returns The current MCP access token and base URL\n */\nexport const useTamboMcpToken = (\n  contextKey?: string,\n): TamboMcpTokenContextProps => {\n  const context = useContext(TamboMcpTokenContext);\n  if (context === undefined) {\n    throw new Error(\n      \"useTamboMcpToken must be used within a TamboMcpTokenProvider\",\n    );\n  }\n\n  const clientContext = useContext(TamboClientContext);\n  if (!clientContext) {\n    throw new Error(\n      \"useTamboMcpToken must be used within a TamboClientProvider\",\n    );\n  }\n  const { client } = clientContext;\n\n  const threadContext = useContext(TamboThreadContext);\n  const currentThreadId = threadContext?.currentThreadId ?? null;\n\n  // State for threadless token\n  const [threadlessToken, setThreadlessToken] = useState<string | null>(null);\n  const hasAttemptedFetch = useRef(false);\n\n  // Determine if we should fetch a threadless token\n  const isPlaceholderThread = currentThreadId === PLACEHOLDER_THREAD.id;\n  const shouldFetchThreadless =\n    contextKey &&\n    (!currentThreadId || isPlaceholderThread) &&\n    !context.mcpAccessToken &&\n    !threadlessToken &&\n    !hasAttemptedFetch.current;\n\n  // Fetch threadless token when needed\n  useEffect(() => {\n    if (shouldFetchThreadless) {\n      hasAttemptedFetch.current = true;\n      const fetchThreadlessToken = async () => {\n        try {\n          const response = await client.beta.auth.getMcpToken({ contextKey });\n          if (response.mcpAccessToken) {\n            setThreadlessToken(response.mcpAccessToken);\n          }\n        } catch (error) {\n          console.error(\"Failed to fetch threadless MCP token:\", error);\n        }\n      };\n      void fetchThreadlessToken();\n    }\n  }, [shouldFetchThreadless, client, contextKey]);\n\n  // Reset threadless token when switching to a real thread\n  useEffect(() => {\n    if (currentThreadId && currentThreadId !== PLACEHOLDER_THREAD.id) {\n      setThreadlessToken(null);\n      hasAttemptedFetch.current = false;\n    }\n  }, [currentThreadId]);\n\n  // Return thread token if available, otherwise threadless token\n  const selectedToken = context.mcpAccessToken ?? threadlessToken;\n\n  return {\n    mcpAccessToken: selectedToken,\n    tamboBaseUrl: context.tamboBaseUrl,\n  };\n};\n"]}