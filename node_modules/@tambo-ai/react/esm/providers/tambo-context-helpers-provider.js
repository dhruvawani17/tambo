"use client";
import React, { createContext, useCallback, useContext, useEffect, useMemo, useState, } from "react";
import { resolveAdditionalContext } from "../context-helpers/registry";
const TamboContextHelpersContext = createContext(null);
/**
 * Provider for managing additional context helpers.
 * Accepts a map of { key: () => any | null | undefined | Promise<any | null | undefined> }.
 * Returning null/undefined skips inclusion; returned values are wrapped as { name: key, context: value }.
 * @param props - The props for the TamboContextHelpersProvider.
 * @param props.contextHelpers - A dictionary of context helper functions keyed by context name.
 * @param props.children - The children to render.
 * @returns The provider that exposes context helper APIs via useTamboContextHelpers.
 */
export const TamboContextHelpersProvider = ({ children, contextHelpers }) => {
    const [helpers, setHelpers] = useState({});
    const addContextHelper = useCallback((name, fn) => {
        setHelpers((prev) => ({ ...prev, [name]: fn }));
    }, []);
    const removeContextHelper = useCallback((name, fn) => {
        setHelpers((prev) => {
            const { [name]: registeredFn, ...rest } = prev;
            if (fn === undefined || registeredFn === fn) {
                return rest;
            }
            return prev;
        });
    }, []);
    // Hydrate the global registry with initial helpers (runs on prop changes)
    useEffect(() => {
        const addedEntries = [];
        if (contextHelpers) {
            for (const [name, fn] of Object.entries(contextHelpers)) {
                addContextHelper(name, fn);
                addedEntries.push([name, fn]);
            }
        }
        return () => {
            for (const [name, fn] of addedEntries) {
                // Only remove if the registry still points to the same function
                removeContextHelper(name, fn);
            }
        };
    }, [addContextHelper, contextHelpers, removeContextHelper]);
    const getAdditionalContext = useCallback(async () => {
        const contexts = await resolveAdditionalContext(helpers);
        return contexts;
    }, [helpers]);
    const getContextHelpers = useCallback(() => {
        return helpers;
    }, [helpers]);
    const value = useMemo(() => ({
        getAdditionalContext,
        getContextHelpers,
        addContextHelper,
        removeContextHelper,
    }), [
        getAdditionalContext,
        getContextHelpers,
        addContextHelper,
        removeContextHelper,
    ]);
    return (React.createElement(TamboContextHelpersContext.Provider, { value: value }, children));
};
/**
 * Hook to access context helpers functionality.
 *
 * Behavior without a provider: this hook does NOT throw immediately. If it is
 * called outside of a `TamboContextHelpersProvider`, it returns a fallback
 * object whose methods will throw when invoked. This "lazy-throw" pattern is
 * intentional so the error surfaces at the actual point of use.
 * @returns The context helpers API when a provider is present; otherwise, a
 * fallback object whose methods throw if called.
 */
export const useTamboContextHelpers = () => {
    const context = useContext(TamboContextHelpersContext);
    if (context)
        return context;
    // No provider present: return methods that throw with a helpful error when used
    return {
        getAdditionalContext: async () => {
            throw new Error("useTamboContextHelpers must be used within a TamboContextHelpersProvider");
        },
        getContextHelpers: () => {
            throw new Error("useTamboContextHelpers must be used within a TamboContextHelpersProvider");
        },
        addContextHelper: (_name, _helper) => {
            throw new Error("useTamboContextHelpers must be used within a TamboContextHelpersProvider");
        },
        removeContextHelper: (_name) => {
            throw new Error("useTamboContextHelpers must be used within a TamboContextHelpersProvider");
        },
    };
};
//# sourceMappingURL=tambo-context-helpers-provider.js.map