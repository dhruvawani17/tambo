{"version":3,"file":"elicitation.js","sourceRoot":"","sources":["../../src/mcp/elicitation.ts"],"names":[],"mappings":"AAWA,OAAO,EAAE,WAAW,EAAE,QAAQ,EAAE,MAAM,OAAO,CAAC;AAiD9C;;;;;;;;;;;GAWG;AACH,SAAS,4BAA4B,CACnC,KAAgE;IAEhE,OAAO,KAAmC,CAAC;AAC7C,CAAC;AAED;;;GAGG;AACH,SAAS,kBAAkB,CACzB,MAA+B;IAE/B,OAAO,iBAAiB,IAAI,MAAM,CAAC;AACrC,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,cAAc;IAC5B,MAAM,CAAC,WAAW,EAAE,cAAc,CAAC,GACjC,QAAQ,CAAiC,IAAI,CAAC,CAAC;IACjD,MAAM,CAAC,kBAAkB,EAAE,qBAAqB,CAAC,GAAG,QAAQ,CAE1D,IAAI,CAAC,CAAC;IAER,MAAM,yBAAyB,GAA0B,WAAW,CAClE,KAAK,EACH,OAAsB,EACtB,KAA6D,EACtC,EAAE;QACzB,OAAO,MAAM,IAAI,OAAO,CAAe,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACzD,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC;gBACxC,MAAM,IAAI,GACR,MAAM,IAAI,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;gBAErE,MAAM,CACJ,IAAI,KAAK,CACP,sFAAsF,IAAI,EAAE,CAC7F,CACF,CAAC;gBACF,OAAO;YACT,CAAC;YAED,6CAA6C;YAC7C,yEAAyE;YACzE,yEAAyE;YACzE,kCAAkC;YAClC,cAAc,CAAC;gBACb,OAAO,EAAE,OAAO,CAAC,MAAM,CAAC,OAAO;gBAC/B,eAAe,EAAE,4BAA4B,CAC3C,OAAO,CAAC,MAAM,CAAC,eAAe,CAC/B;gBACD,MAAM,EAAE,KAAK,CAAC,MAAM;aACrB,CAAC,CAAC;YAEH,uDAAuD;YACvD,IAAI,KAAK,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC;gBACzB,cAAc,CAAC,IAAI,CAAC,CAAC;gBACrB,MAAM,CAAC,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC,CAAC;gBACrC,OAAO;YACT,CAAC;YAED,sCAAsC;YACtC,MAAM,WAAW,GAAG,GAAG,EAAE;gBACvB,cAAc,CAAC,IAAI,CAAC,CAAC;gBACrB,qBAAqB,CAAC,IAAI,CAAC,CAAC;gBAC5B,MAAM,CAAC,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC,CAAC;YACvC,CAAC,CAAC;YAEF,KAAK,CAAC,MAAM,CAAC,gBAAgB,CAAC,OAAO,EAAE,WAAW,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC;YAEpE,sEAAsE;YACtE,qBAAqB,CAAC,GAAG,EAAE,CAAC,CAAC,QAAsB,EAAE,EAAE;gBACrD,uDAAuD;gBACvD,KAAK,CAAC,MAAM,CAAC,mBAAmB,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;gBACvD,0CAA0C;gBAC1C,cAAc,CAAC,IAAI,CAAC,CAAC;gBACrB,qBAAqB,CAAC,IAAI,CAAC,CAAC;gBAC5B,OAAO,CAAC,QAAQ,CAAC,CAAC;YACpB,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC,EACD,EAAE,CACH,CAAC;IAEF,OAAO;QACL,WAAW;QACX,cAAc;QACd,kBAAkB;QAClB,qBAAqB;QACrB,yBAAyB;KAC1B,CAAC;AACJ,CAAC","sourcesContent":["import type { RequestHandlerExtra } from \"@modelcontextprotocol/sdk/shared/protocol.js\";\nimport type {\n  ElicitRequestFormParams,\n  PrimitiveSchemaDefinition,\n} from \"@modelcontextprotocol/sdk/spec.types.js\";\nimport type {\n  ClientNotification,\n  ClientRequest,\n  ElicitRequest,\n  ElicitResult,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport { useCallback, useState } from \"react\";\nimport { MCPElicitationHandler } from \"./mcp-client\";\n\n/**\n * Schema type for elicitation request fields\n */\nexport type ElicitationRequestedSchema =\n  ElicitRequestFormParams[\"requestedSchema\"];\n\n/**\n * Elicitation request from MCP server\n */\nexport interface TamboElicitationRequest {\n  message: string;\n  requestedSchema: ElicitationRequestedSchema;\n  /** AbortSignal that fires when the server cancels the request (e.g., timeout) */\n  signal?: AbortSignal;\n}\n\n/**\n * Re-export PrimitiveSchemaDefinition for consumers that need to work with schema fields\n */\nexport type { PrimitiveSchemaDefinition };\n\ntype ElicitRequestParamsWithRequestedSchema = Extract<\n  ElicitRequest[\"params\"],\n  { requestedSchema: unknown }\n>;\n\n/**\n * Elicitation response to be sent back\n */\nexport interface TamboElicitationResponse {\n  action: \"accept\" | \"decline\" | \"cancel\";\n  content?: Record<string, unknown>;\n  [x: string]: unknown;\n}\n\n/**\n * Elicitation context state - read-only interface for consumers.\n * State management is handled internally by useElicitation hook.\n */\nexport interface ElicitationContextState {\n  /** Current elicitation request, or null if none active */\n  elicitation: TamboElicitationRequest | null;\n  /** Function to call when user responds to elicitation (clears state automatically) */\n  resolveElicitation: ((response: TamboElicitationResponse) => void) | null;\n}\n\n/**\n * Narrow the runtime ElicitRequest requestedSchema into the public\n * ElicitationRequestedSchema type.\n *\n * The MCP SDK guarantees that the runtime\n * `ElicitRequest[\"params\"][\"requestedSchema\"]` shape stays aligned with the\n * spec-defined `ElicitRequestFormParams[\"requestedSchema\"]`. This helper\n * centralizes the cast based on that contract so that if a future SDK version\n * ever diverges, we have a single place to tighten the implementation (for\n * example with structural validation or normalization).\n * @returns requestedSchema as ElicitationRequestedSchema\n */\nfunction toElicitationRequestedSchema(\n  value: ElicitRequestParamsWithRequestedSchema[\"requestedSchema\"],\n): ElicitationRequestedSchema {\n  return value as ElicitationRequestedSchema;\n}\n\n/**\n * Type guard for the elicitation form params shape.\n * @returns true when params include requestedSchema\n */\nfunction hasRequestedSchema(\n  params: ElicitRequest[\"params\"],\n): params is ElicitRequestParamsWithRequestedSchema {\n  return \"requestedSchema\" in params;\n}\n\n/**\n * Internal hook that manages elicitation state and creates a default handler.\n * This bundles all the state management and handler creation for elicitation.\n *\n * Do not export this hook from this package. It is only intended to be used internally by the TamboMcpProvider.\n * @returns Elicitation state and default handler\n */\nexport function useElicitation() {\n  const [elicitation, setElicitation] =\n    useState<TamboElicitationRequest | null>(null);\n  const [resolveElicitation, setResolveElicitation] = useState<\n    ((response: TamboElicitationResponse) => void) | null\n  >(null);\n\n  const defaultElicitationHandler: MCPElicitationHandler = useCallback(\n    async (\n      request: ElicitRequest,\n      extra: RequestHandlerExtra<ClientRequest, ClientNotification>,\n    ): Promise<ElicitResult> => {\n      return await new Promise<ElicitResult>((resolve, reject) => {\n        if (!hasRequestedSchema(request.params)) {\n          const mode =\n            \"mode\" in request.params ? String(request.params.mode) : \"unknown\";\n\n          reject(\n            new Error(\n              `Unsupported MCP elicitation params: expected requestedSchema (form mode), got mode=${mode}`,\n            ),\n          );\n          return;\n        }\n\n        // Set the elicitation request to show the UI\n        // Cast is needed because ElicitRequest uses Zod-inferred types (from the\n        // user's installed zod version), while we use pure TypeScript spec types\n        // for cross-version compatibility\n        setElicitation({\n          message: request.params.message,\n          requestedSchema: toElicitationRequestedSchema(\n            request.params.requestedSchema,\n          ),\n          signal: extra.signal,\n        });\n\n        // If the signal is already aborted, reject immediately\n        if (extra.signal.aborted) {\n          setElicitation(null);\n          reject(new Error(\"Request aborted\"));\n          return;\n        }\n\n        // Listen for abort signal to clean up\n        const handleAbort = () => {\n          setElicitation(null);\n          setResolveElicitation(null);\n          reject(new Error(\"Request aborted\"));\n        };\n\n        extra.signal.addEventListener(\"abort\", handleAbort, { once: true });\n\n        // Store the resolve function so we can call it when the user responds\n        setResolveElicitation(() => (response: ElicitResult) => {\n          // Remove abort listener since we're resolving normally\n          extra.signal.removeEventListener(\"abort\", handleAbort);\n          // Clear state now that user has responded\n          setElicitation(null);\n          setResolveElicitation(null);\n          resolve(response);\n        });\n      });\n    },\n    [],\n  );\n\n  return {\n    elicitation,\n    setElicitation,\n    resolveElicitation,\n    setResolveElicitation,\n    defaultElicitationHandler,\n  };\n}\n"]}