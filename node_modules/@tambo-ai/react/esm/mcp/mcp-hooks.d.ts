import { type ListPromptsResult, type ListResourcesResult } from "@modelcontextprotocol/sdk/types.js";
import { UseQueryResult } from "@tanstack/react-query";
import { type ConnectedMcpServer, type McpServer } from "./tambo-mcp-provider";
export type ListPromptItem = ListPromptsResult["prompts"][number];
export interface ListPromptEntry {
    server: ConnectedMcpServer;
    prompt: ListPromptItem;
}
export type ListResourceItem = ListResourcesResult["resources"][number];
/**
 * Registry resource entry - resources from the local registry (not MCP servers).
 *
 * These entries always have `server === null`.
 */
export interface RegistryResourceEntry {
    server: null;
    resource: ListResourceItem;
}
/**
 * MCP server resource entry - resources from connected MCP servers.
 */
export interface McpResourceEntry {
    server: ConnectedMcpServer;
    resource: ListResourceItem;
}
/**
 * Union type for all resource entries returned by `useTamboMcpResourceList`.
 */
export type ListResourceEntry = RegistryResourceEntry | McpResourceEntry;
/**
 * Type guard for narrowing a `ListResourceEntry` to an MCP-backed resource.
 * @param entry - The resource entry to check
 * @returns True if the entry is from an MCP server, false if it's from the registry
 */
export declare function isMcpResourceEntry(entry: ListResourceEntry): entry is McpResourceEntry;
/**
 * Hook to get the prompts for all the registered MCP servers.
 * @param search - Optional search string to filter prompts by name (case-insensitive).
 * @returns The prompts for the MCP servers, including the server that the prompt was found on.
 */
export declare function useTamboMcpPromptList(search?: string): {
    data: {
        prompt: {
            name: string;
            description?: string | undefined;
            arguments?: {
                name: string;
                description?: string | undefined;
                required?: boolean | undefined;
            }[] | undefined;
            _meta?: {
                [x: string]: unknown;
            } | undefined;
            icons?: {
                src: string;
                mimeType?: string | undefined;
                sizes?: string[] | undefined;
                theme?: "light" | "dark" | undefined;
            }[] | undefined;
            title?: string | undefined;
        };
        server: ConnectedMcpServer;
    }[];
    error: Error | null;
    errors: Error[];
    isPending: boolean;
    isSuccess: boolean;
    isError: boolean;
    isPaused: boolean;
    isRefetching: boolean;
    isFetching: boolean;
    isLoading: boolean;
    refetch: () => Promise<void>;
};
/**
 * Type guard for narrowing McpServer to ConnectedMcpServer.
 * A connected server has a non-null client.
 * @param server - The MCP server to check
 * @returns True if the server is connected, false otherwise
 */
export declare function isConnectedMcpServer(server: McpServer): server is ConnectedMcpServer;
/**
 * Hook to get the prompt for the specified name.
 * @param promptName - The name of the prompt to get. Can be prefixed with serverKey (e.g., "linear:issue") or unprefixed.
 * @param args - The arguments to pass to the prompt.
 * @returns The prompt for the specified name.
 */
export declare function useTamboMcpPrompt(promptName: string | undefined, args?: Record<string, string>): UseQueryResult<{
    [x: string]: unknown;
    messages: {
        role: "user" | "assistant";
        content: {
            type: "text";
            text: string;
            annotations?: {
                audience?: ("user" | "assistant")[] | undefined;
                priority?: number | undefined;
                lastModified?: string | undefined;
            } | undefined;
            _meta?: {
                [x: string]: unknown;
            } | undefined;
        } | {
            type: "image";
            data: string;
            mimeType: string;
            annotations?: {
                audience?: ("user" | "assistant")[] | undefined;
                priority?: number | undefined;
                lastModified?: string | undefined;
            } | undefined;
            _meta?: {
                [x: string]: unknown;
            } | undefined;
        } | {
            type: "audio";
            data: string;
            mimeType: string;
            annotations?: {
                audience?: ("user" | "assistant")[] | undefined;
                priority?: number | undefined;
                lastModified?: string | undefined;
            } | undefined;
            _meta?: {
                [x: string]: unknown;
            } | undefined;
        } | {
            uri: string;
            name: string;
            type: "resource_link";
            description?: string | undefined;
            mimeType?: string | undefined;
            annotations?: {
                audience?: ("user" | "assistant")[] | undefined;
                priority?: number | undefined;
                lastModified?: string | undefined;
            } | undefined;
            _meta?: {
                [x: string]: unknown;
            } | undefined;
            icons?: {
                src: string;
                mimeType?: string | undefined;
                sizes?: string[] | undefined;
                theme?: "light" | "dark" | undefined;
            }[] | undefined;
            title?: string | undefined;
        } | {
            type: "resource";
            resource: {
                uri: string;
                text: string;
                mimeType?: string | undefined;
                _meta?: {
                    [x: string]: unknown;
                } | undefined;
            } | {
                uri: string;
                blob: string;
                mimeType?: string | undefined;
                _meta?: {
                    [x: string]: unknown;
                } | undefined;
            };
            annotations?: {
                audience?: ("user" | "assistant")[] | undefined;
                priority?: number | undefined;
                lastModified?: string | undefined;
            } | undefined;
            _meta?: {
                [x: string]: unknown;
            } | undefined;
        };
    }[];
    _meta?: {
        [x: string]: unknown;
        progressToken?: string | number | undefined;
        "io.modelcontextprotocol/related-task"?: {
            taskId: string;
        } | undefined;
    } | undefined;
    description?: string | undefined;
} | null, Error>;
/**
 * Hook to get the resources for all the registered MCP servers and registry.
 * @param search - Optional search string. For MCP servers, results are filtered locally after fetching.
 *                 For registry dynamic sources, the search is passed to listResources(search) for dynamic generation.
 * @returns The resources from MCP servers and the local registry, including the server that the resource was found on (null for registry resources).
 */
export declare function useTamboMcpResourceList(search?: string): {
    data: ListResourceEntry[];
    error: Error | null;
    errors: Error[];
    isPending: boolean;
    isSuccess: boolean;
    isError: boolean;
    isPaused: boolean;
    isRefetching: boolean;
    isFetching: boolean;
    isLoading: boolean;
    refetch: () => Promise<void>;
};
/**
 * Hook to get the resource for the specified URI.
 * @param resourceUri - The URI of the resource to get. Must be prefixed:
 *   - MCP resources: prefixed with serverKey (e.g., "linear:file://foo")
 *   - Registry resources: prefixed with "registry:" (e.g., "registry:file://bar")
 * @returns The resource for the specified URI.
 */
export declare function useTamboMcpResource(resourceUri: string | undefined): UseQueryResult<{
    [x: string]: unknown;
    contents: ({
        uri: string;
        text: string;
        mimeType?: string | undefined;
        _meta?: {
            [x: string]: unknown;
        } | undefined;
    } | {
        uri: string;
        blob: string;
        mimeType?: string | undefined;
        _meta?: {
            [x: string]: unknown;
        } | undefined;
    })[];
    _meta?: {
        [x: string]: unknown;
        progressToken?: string | number | undefined;
        "io.modelcontextprotocol/related-task"?: {
            taskId: string;
        } | undefined;
    } | undefined;
} | null, Error>;
//# sourceMappingURL=mcp-hooks.d.ts.map