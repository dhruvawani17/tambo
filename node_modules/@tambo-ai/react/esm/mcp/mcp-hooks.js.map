{"version":3,"file":"mcp-hooks.js","sourceRoot":"","sources":["../../src/mcp/mcp-hooks.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  GetPromptResult,\n  type ListPromptsResult,\n  type ListResourcesResult,\n  type ReadResourceResult,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport { UseQueryResult } from \"@tanstack/react-query\";\nimport * as React from \"react\";\nimport { useTamboQueries, useTamboQuery } from \"../hooks\";\nimport { useTamboRegistry } from \"../providers/tambo-registry-provider\";\nimport { REGISTRY_SERVER_KEY } from \"./mcp-constants\";\nimport {\n  type ConnectedMcpServer,\n  type McpServer,\n  useTamboMcpServers,\n} from \"./tambo-mcp-provider\";\n\nexport type ListPromptItem = ListPromptsResult[\"prompts\"][number];\nexport interface ListPromptEntry {\n  // Only connected servers produce prompt entries, so expose the connected type\n  server: ConnectedMcpServer;\n  prompt: ListPromptItem;\n}\n\nexport type ListResourceItem = ListResourcesResult[\"resources\"][number];\n\n/**\n * Registry resource entry - resources from the local registry (not MCP servers).\n *\n * These entries always have `server === null`.\n */\nexport interface RegistryResourceEntry {\n  server: null;\n  resource: ListResourceItem;\n}\n\n/**\n * MCP server resource entry - resources from connected MCP servers.\n */\nexport interface McpResourceEntry {\n  server: ConnectedMcpServer;\n  resource: ListResourceItem;\n}\n\n/**\n * Union type for all resource entries returned by `useTamboMcpResourceList`.\n */\nexport type ListResourceEntry = RegistryResourceEntry | McpResourceEntry;\n\ntype InternalRegistryResourceEntry = RegistryResourceEntry & {\n  isDynamic: boolean;\n};\n\ntype InternalListResourceEntry =\n  | McpResourceEntry\n  | InternalRegistryResourceEntry;\n\nfunction toPublicResourceEntry(\n  entry: InternalListResourceEntry,\n): ListResourceEntry {\n  if (entry.server === null) {\n    const { isDynamic: _isDynamic, ...publicEntry } = entry;\n    return publicEntry;\n  }\n  return entry;\n}\n\n/**\n * Type guard for narrowing a `ListResourceEntry` to an MCP-backed resource.\n * @param entry - The resource entry to check\n * @returns True if the entry is from an MCP server, false if it's from the registry\n */\nexport function isMcpResourceEntry(\n  entry: ListResourceEntry,\n): entry is McpResourceEntry {\n  return entry.server !== null && isConnectedMcpServer(entry.server);\n}\n\n/**\n * Hook to get the prompts for all the registered MCP servers.\n * @param search - Optional search string to filter prompts by name (case-insensitive).\n * @returns The prompts for the MCP servers, including the server that the prompt was found on.\n */\nexport function useTamboMcpPromptList(search?: string) {\n  const mcpServers = useTamboMcpServers();\n\n  const queries = useTamboQueries({\n    queries: mcpServers.map((mcpServer) => ({\n      // search is NOT in queryKey - we filter locally after fetching\n      queryKey: [\"mcp-prompts\", mcpServer.key],\n      // Only run for connected servers that have a client\n      enabled: isConnectedMcpServer(mcpServer),\n      queryFn: async (): Promise<ListPromptEntry[]> => {\n        // Fast path: if this server doesn't have a client, skip work\n        if (!isConnectedMcpServer(mcpServer)) return [];\n\n        const result = await mcpServer.client.client.listPrompts();\n        const prompts: ListPromptItem[] = result?.prompts ?? [];\n        // Return prompts without prefixes - we'll apply prefixing in combine\n        const promptsEntries = prompts.map((prompt) => ({\n          server: mcpServer,\n          prompt,\n        }));\n        return promptsEntries;\n      },\n    })),\n    combine: (results) => {\n      const combined = combineArrayResults(results);\n\n      // Always apply serverKey prefix to MCP prompts (breaking change for consistency with resources)\n      // This ensures clear separation between local and remote prompts\n      return {\n        ...combined,\n        data: combined.data.map((entry) => ({\n          ...entry,\n          prompt: {\n            ...entry.prompt,\n            name: `${entry.server.serverKey}:${entry.prompt.name}`,\n          },\n        })),\n      };\n    },\n  });\n\n  // Filter results by search string - runs on every search change (not just query completion)\n  const filteredData = React.useMemo(() => {\n    if (!search) return queries.data;\n\n    const normalizedSearch = search.toLowerCase();\n    return queries.data.filter((entry) => {\n      const name = entry.prompt.name?.toLowerCase() ?? \"\";\n      return name.includes(normalizedSearch);\n    });\n  }, [queries.data, search]);\n\n  return {\n    ...queries,\n    data: filteredData,\n  };\n}\n// TODO: find a more general place for this\nfunction combineArrayResults<T>(results: UseQueryResult<T[]>[]): {\n  data: T[];\n  error: Error | null;\n  errors: Error[];\n  isPending: boolean;\n  isSuccess: boolean;\n  isError: boolean;\n  isPaused: boolean;\n  isRefetching: boolean;\n  isFetching: boolean;\n  isLoading: boolean;\n  refetch: () => Promise<void>;\n} {\n  const errors = results\n    .filter((result) => result.isError)\n    .map((result) => result.error);\n\n  // Treat queries that are idle (disabled) as non-blocking for aggregate status\n  const enabledish = results.filter(\n    (r) => r.fetchStatus !== \"idle\" || r.isSuccess || r.isError,\n  );\n\n  return {\n    // Prefer flatMap to avoid extra intermediate arrays\n    data: results.flatMap((result) =>\n      result.isSuccess && Array.isArray(result.data) ? result.data : [],\n    ),\n    // Preserve a single error for compatibility and expose the full list for diagnostics\n    error: errors[0] ?? null,\n    errors,\n    isPending: enabledish.some((result) => result.isPending),\n    isSuccess:\n      enabledish.length > 0 && enabledish.every((result) => result.isSuccess),\n    isError: errors.length > 0,\n    isPaused: enabledish.some((result) => result.isPaused),\n    isRefetching: enabledish.some((result) => result.isRefetching),\n    isFetching: enabledish.some((result) => result.isFetching),\n    isLoading: enabledish.some((result) => result.isLoading),\n    // Aggregate refetch to trigger all underlying queries\n    refetch: async () => {\n      await Promise.all(\n        results.map(async (r) => {\n          await r.refetch();\n        }),\n      );\n    },\n  };\n}\n\n/**\n * Type guard for narrowing McpServer to ConnectedMcpServer.\n * A connected server has a non-null client.\n * @param server - The MCP server to check\n * @returns True if the server is connected, false otherwise\n */\nexport function isConnectedMcpServer(\n  server: McpServer,\n): server is ConnectedMcpServer {\n  return \"client\" in server && server.client != null;\n}\n\n/**\n * Hook to get the prompt for the specified name.\n * @param promptName - The name of the prompt to get. Can be prefixed with serverKey (e.g., \"linear:issue\") or unprefixed.\n * @param args - The arguments to pass to the prompt.\n * @returns The prompt for the specified name.\n */\nexport function useTamboMcpPrompt(\n  promptName: string | undefined,\n  args: Record<string, string> = {},\n) {\n  // figure out which server has the prompt\n  const { data: promptEntries } = useTamboMcpPromptList();\n  const promptEntry = promptEntries?.find(\n    (prompt) => prompt.prompt.name === promptName,\n  );\n  // Use the stable server key (and the server instance itself) instead of brittle\n  // name/url/transport matching.\n  const mcpServer = promptEntry?.server;\n\n  // Strip the prefix to get the original prompt name for the MCP server call\n  const originalPromptName = promptName?.includes(\":\")\n    ? promptName.split(\":\").slice(1).join(\":\")\n    : promptName;\n\n  // Canonicalize args to avoid unstable cache keys from object identity/order\n  const sortedArgsEntries = Object.keys(args)\n    .sort()\n    .map((k) => [k, args[k]] as const);\n  return useTamboQuery({\n    // Include server identity and sorted args to prevent stale cache hits\n    queryKey: [\"mcp-prompt\", promptName, mcpServer?.key, sortedArgsEntries],\n    // Only run when we have a prompt name and a connected server\n    enabled: Boolean(\n      promptName && mcpServer && isConnectedMcpServer(mcpServer),\n    ),\n    queryFn: async (): Promise<GetPromptResult | null> => {\n      if (\n        !originalPromptName ||\n        !mcpServer ||\n        !isConnectedMcpServer(mcpServer)\n      ) {\n        return null;\n      }\n      const result = await mcpServer.client.client.getPrompt({\n        name: originalPromptName,\n        arguments: args,\n      });\n      return result ?? null; // return null because react-query doesn't like undefined results\n    },\n  });\n}\n\n/**\n * Hook to get the resources for all the registered MCP servers and registry.\n * @param search - Optional search string. For MCP servers, results are filtered locally after fetching.\n *                 For registry dynamic sources, the search is passed to listResources(search) for dynamic generation.\n * @returns The resources from MCP servers and the local registry, including the server that the resource was found on (null for registry resources).\n */\nexport function useTamboMcpResourceList(search?: string) {\n  const mcpServers = useTamboMcpServers();\n  const { resources: staticResources, resourceSource } = useTamboRegistry();\n\n  // Build list of queries: MCP servers + optional dynamic resource source\n  const queriesToRun = [\n    // MCP server queries - search is NOT in queryKey so queries don't re-run on search change\n    ...mcpServers.map((mcpServer) => ({\n      queryKey: [\"mcp-resources\", mcpServer.key],\n      // Only run for connected servers that have a client\n      enabled: isConnectedMcpServer(mcpServer),\n      queryFn: async (): Promise<McpResourceEntry[]> => {\n        // Fast path: if this server doesn't have a client, skip work\n        if (!isConnectedMcpServer(mcpServer)) return [];\n\n        const result = await mcpServer.client.client.listResources();\n        const resources: ListResourceItem[] = result?.resources ?? [];\n        // Return resources without prefixes - we'll apply prefixing in combine\n        const resourceEntries: McpResourceEntry[] = resources.map(\n          (resource) => ({\n            server: mcpServer,\n            resource,\n          }),\n        );\n        return resourceEntries;\n      },\n    })),\n    // Dynamic resource source query (if exists) - search IS in queryKey to allow dynamic generation\n    ...(resourceSource\n      ? [\n          {\n            queryKey: [\"registry-resources\", \"dynamic\", search],\n            enabled: true,\n            queryFn: async (): Promise<InternalRegistryResourceEntry[]> => {\n              if (!resourceSource) return [];\n              const resources = await resourceSource.listResources(search);\n              return resources.map((resource) => ({\n                server: null,\n                resource,\n                isDynamic: true,\n              }));\n            },\n          },\n        ]\n      : []),\n  ];\n\n  const queries = useTamboQueries({\n    queries: queriesToRun,\n    combine: (results) => {\n      // Type assertion needed because queries can return different entry types\n      const combined = combineArrayResults(\n        results as UseQueryResult<InternalListResourceEntry[]>[],\n      );\n\n      // Add static registry resources (no query needed)\n      const staticEntries: InternalRegistryResourceEntry[] =\n        staticResources.map((resource) => ({\n          server: null,\n          resource,\n          isDynamic: false,\n        }));\n\n      // Merge static resources with query results (registry resources first)\n      const allData = [...staticEntries, ...combined.data];\n\n      // Apply serverKey prefix to ALL resources for unified @serverKey:uri format\n      // Registry resources get REGISTRY_SERVER_KEY prefix, MCP resources get their serverKey\n      const prefixedData = allData.map((entry) => {\n        if (entry.server === null) {\n          // Registry resource - prefix with REGISTRY_SERVER_KEY\n          return {\n            ...entry,\n            resource: {\n              ...entry.resource,\n              uri: `${REGISTRY_SERVER_KEY}:${entry.resource.uri}`,\n            },\n          };\n        }\n        // MCP resource - always prefix with serverKey\n        return {\n          ...entry,\n          resource: {\n            ...entry.resource,\n            uri: `${entry.server.serverKey}:${entry.resource.uri}`,\n          },\n        };\n      });\n\n      return {\n        ...combined,\n        data: prefixedData,\n      };\n    },\n  });\n\n  // Filter results by search string - runs on every search change (not just query completion)\n  // - MCP resources are filtered locally\n  // - Static registry resources are filtered locally\n  // - Dynamic registry resources are already filtered by listResources(search)\n  const filteredData = React.useMemo((): InternalListResourceEntry[] => {\n    if (!search) return queries.data;\n\n    const normalizedSearch = search.toLowerCase();\n    return queries.data.filter((entry) => {\n      if (entry.server === null && entry.isDynamic) {\n        return true;\n      }\n\n      const name = entry.resource.name?.toLowerCase() ?? \"\";\n      const uri = entry.resource.uri.toLowerCase();\n      return name.includes(normalizedSearch) || uri.includes(normalizedSearch);\n    });\n  }, [queries.data, search]);\n\n  const publicData = React.useMemo(\n    () => filteredData.map(toPublicResourceEntry),\n    [filteredData],\n  );\n\n  return {\n    ...queries,\n    data: publicData,\n  };\n}\n\n/**\n * Hook to get the resource for the specified URI.\n * @param resourceUri - The URI of the resource to get. Must be prefixed:\n *   - MCP resources: prefixed with serverKey (e.g., \"linear:file://foo\")\n *   - Registry resources: prefixed with \"registry:\" (e.g., \"registry:file://bar\")\n * @returns The resource for the specified URI.\n */\nexport function useTamboMcpResource(resourceUri: string | undefined) {\n  const { resourceSource } = useTamboRegistry();\n  const { data: resourceEntries } = useTamboMcpResourceList();\n\n  // Find which server/source has the resource\n  const resourceEntry = resourceEntries?.find(\n    (entry) => entry.resource.uri === resourceUri,\n  );\n\n  // Determine if this is a registry resource or MCP resource\n  const isRegistryResource = resourceEntry?.server === null;\n  const mcpServer = resourceEntry?.server ?? null;\n\n  // Check if the URI has the registry prefix\n  const hasRegistryPrefix = Boolean(\n    resourceUri?.startsWith(`${REGISTRY_SERVER_KEY}:`),\n  );\n\n  // Strip the prefix to get the original resource URI for fetching\n  let originalResourceUri: string | undefined;\n  if (isRegistryResource || hasRegistryPrefix) {\n    const prefixLen = REGISTRY_SERVER_KEY.length + 1; // +1 for the colon\n    originalResourceUri = resourceUri?.slice(prefixLen);\n  } else if (mcpServer) {\n    const prefixLen = mcpServer.serverKey.length + 1; // +1 for the colon\n    originalResourceUri = resourceUri?.slice(prefixLen);\n  }\n\n  // Check if we can fetch this resource\n  const hasRegistrySource = resourceSource != null;\n  const hasConnectedMcpServer =\n    mcpServer != null && isConnectedMcpServer(mcpServer);\n  const canFetchFromRegistry =\n    hasRegistrySource && (isRegistryResource || hasRegistryPrefix);\n  const canFetchResource = Boolean(\n    resourceUri && (canFetchFromRegistry || hasConnectedMcpServer),\n  );\n\n  const locationKey =\n    isRegistryResource || hasRegistryPrefix\n      ? REGISTRY_SERVER_KEY\n      : mcpServer?.key;\n\n  return useTamboQuery({\n    queryKey: [\"resource\", resourceUri, locationKey],\n    enabled: canFetchResource,\n    queryFn: async (): Promise<ReadResourceResult | null> => {\n      if (!originalResourceUri) {\n        return null;\n      }\n\n      // Registry resource: use resourceSource.getResource\n      if (resourceSource && (isRegistryResource || hasRegistryPrefix)) {\n        const result = await resourceSource.getResource(originalResourceUri);\n        return result ?? null;\n      }\n\n      // MCP resource: use MCP client\n      if (mcpServer && isConnectedMcpServer(mcpServer)) {\n        const result = await mcpServer.client.client.readResource({\n          uri: originalResourceUri,\n        });\n        return result ?? null;\n      }\n\n      return null;\n    },\n  });\n}\n"]}