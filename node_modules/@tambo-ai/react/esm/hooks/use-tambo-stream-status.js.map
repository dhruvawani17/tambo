{"version":3,"file":"use-tambo-stream-status.js","sourceRoot":"","sources":["../../src/hooks/use-tambo-stream-status.tsx"],"names":[],"mappings":"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","sourcesContent":["\"use client\";\nimport { useEffect, useMemo, useState } from \"react\";\nimport { GenerationStage } from \"../model/generate-component-response\";\nimport { useTamboGenerationStage } from \"../providers/tambo-thread-provider\";\nimport { useTamboCurrentMessage } from \"./use-current-message\";\n\n/**\n * Global stream status flags for a specific component in a message.\n * Represents the aggregate state across all props for this component only.\n * Once a component completes, its status remains stable regardless of other generations.\n */\nexport interface StreamStatus {\n  /**\n   * Indicates no tokens have been received for any prop and generation is not active.\n   * Useful for showing initial loading states before any data arrives.\n   */\n  isPending: boolean;\n\n  /**\n   * Indicates active streaming - either generation is streaming OR at least one prop is still streaming.\n   * Use this to show loading animations or skeleton states during data transmission.\n   */\n  isStreaming: boolean;\n\n  /**\n   * Indicates successful completion - generation is complete AND every prop finished without error.\n   * Safe to render the final component when this is true.\n   */\n  isSuccess: boolean;\n\n  /**\n   * Indicates a fatal error occurred in any prop or the stream itself.\n   * Check streamError for details about what went wrong.\n   */\n  isError: boolean;\n\n  /**\n   * The first fatal error encountered during streaming (if any).\n   * Will be undefined if no errors occurred.\n   */\n  streamError?: Error;\n}\n\n/**\n * Streaming status flags for individual component props.\n * Tracks the state of each prop as it streams from the LLM.\n */\nexport interface PropStatus {\n  /**\n   * Indicates no tokens have been received for this specific prop yet.\n   * The prop value is still undefined, null, or empty string.\n   */\n  isPending: boolean;\n\n  /**\n   * Indicates at least one token has been received but streaming is not complete.\n   * The prop has partial content that may still be updating.\n   */\n  isStreaming: boolean;\n\n  /**\n   * Indicates this prop has finished streaming successfully.\n   * The prop value is complete and stable.\n   */\n  isSuccess: boolean;\n\n  /**\n   * The error that occurred during streaming (if any).\n   * Will be undefined if no error occurred for this prop.\n   */\n  error?: Error;\n}\n\n/**\n * SSR Guard - throws during server-side rendering.\n * Ensures the hook is only used in browser contexts.\n * @throws {Error} When called during server-side rendering\n */\nfunction assertClientSide() {\n  if (typeof window === \"undefined\") {\n    throw new Error(\n      \"useTamboStreamStatus can only be used in browser contexts. \" +\n        \"This hook is not compatible with SSR/SSG. \" +\n        \"Consider wrapping it in useEffect or using dynamic imports.\",\n    );\n  }\n}\n\n/**\n * Track streaming status for individual props by monitoring their values.\n * Monitors when props receive their first token and when they complete streaming.\n * Maintains stable state per message - once props complete for a message, they stay complete.\n * @template Props - The type of the component props being tracked\n * @param props - The current component props object\n * @param generationStage - The current generation stage from the LLM\n * @param messageId - The ID of the current message to track component-specific state\n * @returns A record mapping each prop key to its PropStatus\n */\nfunction usePropsStreamingStatus<Props extends Record<string, any>>(\n  props: Props | undefined,\n  generationStage: GenerationStage,\n  messageId: string,\n): Record<keyof Props, PropStatus> {\n  const [propTracking, setPropTracking] = useState<\n    Record<\n      string,\n      {\n        hasStarted: boolean;\n        isComplete: boolean;\n        error?: Error;\n        messageId: string;\n      }\n    >\n  >({});\n\n  /** Reset tracking only when the message changes */\n  useEffect(() => {\n    setPropTracking((prev) => {\n      // If we have tracking data for a different message, reset\n      const hasOldMessageData = Object.values(prev).some(\n        (track) => track.messageId && track.messageId !== messageId,\n      );\n      return hasOldMessageData ? {} : prev;\n    });\n  }, [messageId]);\n\n  /** Track when props start streaming (receive first token) and when they complete */\n  useEffect(() => {\n    if (!props) return;\n\n    setPropTracking((prev) => {\n      const updated = { ...prev };\n      let hasChanges = false;\n\n      // First pass: identify which props are starting now\n      const propsStartingNow: string[] = [];\n      Object.entries(props).forEach(([key, value]) => {\n        const current = prev[key] || {\n          hasStarted: false,\n          isComplete: false,\n        };\n\n        /** A prop starts streaming when it has a non-empty value for the first time */\n        const hasContent =\n          value !== undefined && value !== null && value !== \"\";\n        const justStarted = hasContent && !current.hasStarted;\n\n        if (justStarted) {\n          propsStartingNow.push(key);\n        }\n      });\n\n      // Second pass: update tracking and mark previous props as complete\n      Object.entries(props).forEach(([key, value]) => {\n        const current = prev[key] || {\n          hasStarted: false,\n          isComplete: false,\n        };\n\n        /** A prop starts streaming when it has a non-empty value for the first time */\n        const hasContent =\n          value !== undefined && value !== null && value !== \"\";\n        const justStarted = hasContent && !current.hasStarted;\n\n        /**\n         * A prop is complete when it has started and either:\n         * 1. A following prop has started, OR\n         * 2. Generation is complete (for the final prop)\n         */\n        const hasFollowingPropStarted = propsStartingNow.some(\n          (startingKey) => startingKey !== key,\n        );\n        const isGenerationComplete =\n          generationStage === GenerationStage.COMPLETE;\n        const isComplete =\n          current.hasStarted &&\n          (hasFollowingPropStarted || isGenerationComplete) &&\n          !current.isComplete;\n\n        // Once a prop is complete for this message, it stays complete\n        if (current.isComplete && current.messageId === messageId) {\n          // Skip - already complete for this message\n          return;\n        }\n\n        if (justStarted || isComplete) {\n          updated[key] = {\n            ...current,\n            hasStarted: justStarted ? true : current.hasStarted,\n            isComplete: isComplete ? true : current.isComplete,\n            messageId,\n          };\n          hasChanges = true;\n        }\n      });\n\n      return hasChanges ? updated : prev;\n    });\n  }, [props, generationStage, messageId]);\n\n  /** Convert tracking state to PropStatus objects */\n  return useMemo(() => {\n    if (!props) return {} as Record<keyof Props, PropStatus>;\n\n    const result = {} as Record<keyof Props, PropStatus>;\n\n    Object.keys(props).forEach((key) => {\n      const tracking = propTracking[key] || {\n        hasStarted: false,\n        isComplete: false,\n        messageId: \"\",\n      };\n\n      // If this prop is complete for this message, it stays complete\n      const isCompleteForThisMessage =\n        tracking.isComplete && tracking.messageId === messageId;\n\n      // Only consider generation stage if this prop isn't already complete for this message\n      const isGenerationStreaming =\n        !isCompleteForThisMessage &&\n        generationStage === GenerationStage.STREAMING_RESPONSE;\n\n      result[key as keyof Props] = {\n        isPending: !tracking.hasStarted && !isCompleteForThisMessage,\n        isStreaming:\n          tracking.hasStarted &&\n          !isCompleteForThisMessage &&\n          isGenerationStreaming,\n        isSuccess: isCompleteForThisMessage,\n        error: tracking.error,\n      };\n    });\n\n    return result;\n  }, [props, propTracking, generationStage, messageId]);\n}\n\n/**\n * Derives global StreamStatus from generation stage and individual prop statuses.\n * Aggregates individual prop states into a unified stream status.\n * @template Props - The type of the component props\n * @param generationStage - The current generation stage from the LLM\n * @param propStatus - Status record for each individual prop\n * @param hasComponent - Whether a component exists in the current message\n * @param generationError - Any error from the generation process itself\n * @returns The aggregated StreamStatus for the entire component\n */\nfunction deriveGlobalStreamStatus<Props extends Record<string, any>>(\n  generationStage: GenerationStage,\n  propStatus: Record<keyof Props, PropStatus>,\n  hasComponent: boolean,\n  generationError?: Error,\n): StreamStatus {\n  const propStatuses = Object.values(propStatus);\n\n  // If all props are already successful, the component is complete regardless of generation stage\n  const allPropsSuccessful =\n    propStatuses.length > 0 && propStatuses.every((p) => p.isSuccess);\n\n  // Only consider generation stage if not all props are complete\n  const isGenerationStreaming =\n    !allPropsSuccessful &&\n    generationStage === GenerationStage.STREAMING_RESPONSE;\n  const isGenerationError = generationStage === GenerationStage.ERROR;\n\n  /** Find first error from generation or any prop */\n  const firstError =\n    generationError ?? propStatuses.find((p) => p.error)?.error;\n\n  return {\n    /** isPending: no component yet OR (has component but no props have started) */\n    isPending:\n      !hasComponent ||\n      (!isGenerationStreaming &&\n        !allPropsSuccessful &&\n        propStatuses.every((p) => p.isPending)),\n\n    /** isStreaming: any prop is streaming (generation stage doesn't matter if props are complete) */\n    isStreaming: propStatuses.some((p) => p.isStreaming),\n\n    /** isSuccess: all props successful (component is stable once all props complete) */\n    isSuccess: allPropsSuccessful,\n\n    /** isError: generation error OR any prop error */\n    isError:\n      isGenerationError ||\n      propStatuses.some((p) => p.error) ||\n      !!generationError,\n\n    streamError: firstError,\n  };\n}\n\n/**\n * Track streaming status for Tambo component props.\n *\n * **Important**: Props update repeatedly during streaming and may be partial.\n * Use `propStatus.<field>?.isSuccess` before treating a prop as complete.\n *\n * Pair with `useTamboComponentState` to disable inputs while streaming.\n * @see {@link https://docs.tambo.co/concepts/streaming/streaming-best-practices}\n * @template Props - Component props type\n * @returns `streamStatus` (overall) and `propStatus` (per-prop) flags\n * @throws {Error} When used during SSR/SSG\n * @example\n * ```tsx\n * // Wait for entire stream\n * const { streamStatus } = useTamboStreamStatus();\n * if (!streamStatus.isSuccess) return <Spinner />;\n * return <Card {...props} />;\n * ```\n * @example\n * ```tsx\n * // Highlight in-flight props\n * const { propStatus } = useTamboStreamStatus<Props>();\n * <h2 className={propStatus.title.isStreaming ? \"animate-pulse\" : \"\"}>\n *   {title}\n * </h2>\n * ```\n */\nexport function useTamboStreamStatus<\n  Props extends Record<string, any> = Record<string, any>,\n>(): {\n  streamStatus: StreamStatus;\n  propStatus: Record<keyof Props, PropStatus>;\n} {\n  /** SSR Guard - ensure client-side only execution */\n  assertClientSide();\n\n  const { generationStage } = useTamboGenerationStage();\n  const message = useTamboCurrentMessage();\n\n  /** Get the current component props from the message */\n  const componentProps = (message?.component?.props as Props) || ({} as Props);\n\n  /** Track per-prop streaming status */\n  const propStatus = usePropsStreamingStatus(\n    componentProps,\n    generationStage,\n    message?.id ?? \"\",\n  );\n\n  /** Derive global stream status from prop statuses and generation stage */\n  const streamStatus = useMemo(() => {\n    const generationError = message?.error\n      ? new Error(message.error)\n      : undefined;\n    const hasComponent = !!message?.component;\n    return deriveGlobalStreamStatus(\n      generationStage,\n      propStatus,\n      hasComponent,\n      generationError,\n    );\n  }, [generationStage, propStatus, message]);\n\n  return {\n    streamStatus,\n    propStatus,\n  };\n}\n"]}