"use client";
import { deepEqual } from "fast-equals";
import { useCallback, useContext, useEffect, useState } from "react";
import { useDebouncedCallback } from "use-debounce";
import { useTamboClient, useTamboThread } from "..";
import { useTamboInteractable } from "../providers/tambo-interactable-provider";
import { TamboMessageContext } from "./use-current-message";
export function useTamboComponentState(keyName, initialValue, setFromProp, debounceTime = 500) {
    const message = useContext(TamboMessageContext);
    const { updateThreadMessage } = useTamboThread();
    const client = useTamboClient();
    const componentId = message?.interactableMetadata?.id ?? null;
    const { setInteractableState, getInteractableComponentState } = useTamboInteractable();
    const messageState = message?.componentState?.[keyName];
    const interactableState = componentId
        ? getInteractableComponentState(componentId)?.[keyName]
        : undefined;
    const initialState = interactableState ?? messageState ?? initialValue;
    const [localState, setLocalState] = useState(initialState);
    const [initializedFromThreadMessage, setInitializedFromThreadMessage] = useState(messageState ? true : false);
    // Optimistically update the local thread message's componentState
    const updateLocalThreadMessage = useCallback(async (newState, existingMessage) => {
        if (!existingMessage) {
            return;
        }
        const updatedMessage = {
            threadId: existingMessage.threadId,
            componentState: {
                ...existingMessage.componentState,
                [keyName]: newState,
            },
        };
        await updateThreadMessage(existingMessage.id, updatedMessage, false);
    }, [updateThreadMessage, keyName]);
    // Debounced callback to update the remote thread message's componentState
    const updateRemoteThreadMessage = useDebouncedCallback(async (newState, existingMessage) => {
        if (!existingMessage) {
            return;
        }
        await client.beta.threads.messages.updateComponentState(existingMessage.id, {
            id: existingMessage.threadId,
            state: { [keyName]: newState },
        });
    }, debounceTime);
    const setValue = useCallback((newState) => {
        setLocalState(newState);
        if (componentId) {
            // For interactable components, update the interactable provider's state
            setInteractableState(componentId, keyName, newState);
        }
        else if (message) {
            // For generated components, update both local and remote thread message state
            void updateLocalThreadMessage(newState, message);
            void updateRemoteThreadMessage(newState, message);
        }
    }, [
        message,
        updateLocalThreadMessage,
        updateRemoteThreadMessage,
        setInteractableState,
        componentId,
        keyName,
    ]);
    const existingInteractableState = componentId
        ? getInteractableComponentState(componentId)?.[keyName]
        : undefined;
    const shouldUpdateInteractableInitial = !!componentId &&
        existingInteractableState === undefined &&
        initialValue !== undefined;
    // Set initial value in interactable state if we're in an interactable context and there's no existing state
    useEffect(() => {
        if (!shouldUpdateInteractableInitial) {
            return;
        }
        setInteractableState(componentId, keyName, initialValue);
    }, [
        shouldUpdateInteractableInitial,
        componentId,
        keyName,
        initialValue,
        setInteractableState,
    ]);
    const shouldSyncFromMessage = !!message && messageState !== undefined && messageState !== null;
    // Mirror the thread message's componentState value to the local state and interactable state
    useEffect(() => {
        if (!shouldSyncFromMessage) {
            return;
        }
        setInitializedFromThreadMessage(true);
        const stateValue = messageState;
        setLocalState(stateValue);
        if (componentId) {
            setInteractableState(componentId, keyName, stateValue);
        }
    }, [
        shouldSyncFromMessage,
        messageState,
        keyName,
        setInteractableState,
        componentId,
    ]);
    // Sync from interactable provider to local state when state changes externally (e.g., from Tambo tool call)
    useEffect(() => {
        if (!componentId)
            return;
        // only update if different
        setLocalState((prev) => deepEqual(prev, interactableState) ? prev : interactableState);
    }, [componentId, interactableState]);
    // For editable fields that are set from a prop to allow streaming updates, don't overwrite a fetched state value set from the thread message with prop value on initial load.
    useEffect(() => {
        if (setFromProp !== undefined && !initializedFromThreadMessage) {
            setLocalState(setFromProp);
        }
    }, [setFromProp, initializedFromThreadMessage]);
    // Ensure pending changes are flushed on unmount (only for generated components)
    useEffect(() => {
        // Only flush remote updates for generated components, not interactable components
        if (componentId) {
            return;
        }
        return () => {
            async function flushUpdates() {
                try {
                    await updateRemoteThreadMessage.flush();
                }
                catch (error) {
                    console.error("Failed to flush pending thread message updates:", error);
                }
            }
            // Fire-and-forget cleanup (errors handled inside)
            void flushUpdates();
        };
    }, [updateRemoteThreadMessage, componentId]);
    return [localState, setValue];
}
//# sourceMappingURL=use-component-state.js.map