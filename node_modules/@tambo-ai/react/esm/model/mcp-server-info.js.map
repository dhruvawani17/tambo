{"version":3,"file":"mcp-server-info.js","sourceRoot":"","sources":["../../src/model/mcp-server-info.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,MAAM,CAAN,IAAY,YAGX;AAHD,WAAY,YAAY;IACtB,2BAAW,CAAA;IACX,6BAAa,CAAA;AACf,CAAC,EAHW,YAAY,KAAZ,YAAY,QAGvB;AA+DD;;;;;;;GAOG;AACH,MAAM,UAAU,qBAAqB,CACnC,UAAsE;IAEtE,MAAM,SAAS,GAAG,UAAU,CAAC,aAAa;QACxC,CAAC,CAAC,IAAI,CAAC,SAAS,CACZ,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,aAAa,CAAC;aACrC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,EAAE,CAAC,CAAU,CAAC;aAC9C,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAC1C;QACH,CAAC,CAAC,EAAE,CAAC;IAEP,OAAO,GAAG,UAAU,CAAC,GAAG,IAAI,UAAU,CAAC,SAAS,IAAI,YAAY,CAAC,IAAI,IAAI,SAAS,EAAE,CAAC;AACvF,CAAC","sourcesContent":["/**\n * The transport protocol to use for MCP connections.\n */\nexport enum MCPTransport {\n  SSE = \"sse\",\n  HTTP = \"http\",\n}\n\n/**\n * User-provided configuration for an MCP server.\n *\n * This is the type accepted by `TamboProvider` / `TamboRegistryProvider` in\n * the `mcpServers` prop.\n *\n * The `handlers` field is intentionally typed as `unknown` here so the core\n * SDK does not depend on the MCP subpackage. In the `@tambo-ai/react/mcp`\n * subpackage this is treated as `Partial<MCPHandlers>` (with\n * `elicitation` / `sampling` callbacks). The `@modelcontextprotocol/sdk` is\n * included automatically with `@tambo-ai/react`. See the React SDK README for\n * any additional optional peer dependencies needed for MCP features.\n */\nexport interface McpServerInfo {\n  /** Optional name for the MCP server */\n  name?: string;\n  /** The URL of the MCP server to connect to */\n  url: string;\n  /** Optional description of the MCP server */\n  description?: string;\n  /** The transport type to use (SSE or HTTP). Defaults to HTTP for string URLs */\n  transport?: MCPTransport;\n  /** Optional custom headers to include in requests */\n  customHeaders?: Record<string, string>;\n  /**\n   * Optional short name for namespacing MCP resources, prompts, and tools.\n   * When multiple MCP servers are configured, this key is used to prefix:\n   * - prompts: `<serverKey>:<promptName>`\n   * - resources: `<serverKey>:<resourceUrl>`\n   * - tools: `<serverKey>__<toolName>`\n   *\n   * If not provided, a key will be derived from the URL hostname.\n   * For example, \"https://mcp.linear.app/mcp\" becomes \"linear\".\n   */\n  serverKey?: string;\n  /**\n   * Optional handlers for elicitation and sampling requests from the server.\n   *\n   * In the MCP subpackage this is interpreted as `Partial<MCPHandlers>`,\n   * i.e. `{ elicitation?: MCPElicitationHandler; sampling?: MCPSamplingHandler }`.\n   *\n   * Note: These callbacks should be stable (e.g., wrapped in useCallback or\n   * defined outside the component) to avoid constant re-registration of the\n   * MCP server on every render.\n   */\n  handlers?: unknown;\n}\n\n/**\n * Normalized MCP server metadata used internally by the registry and MCP\n * provider.\n *\n * This is equivalent to `McpServerInfo` except that:\n * - `serverKey` is guaranteed to be present\n * - `transport` is resolved to a concrete value (defaults to HTTP)\n */\nexport interface NormalizedMcpServerInfo extends McpServerInfo {\n  transport: MCPTransport;\n  serverKey: string;\n}\n\n/**\n * Creates a stable identifier for an MCP server based on its connection properties.\n * Two servers with the same URL, transport, and headers will have the same key.\n *\n * This is used by both the registry and MCP provider to deduplicate servers,\n * so it lives alongside the shared server metadata type.\n * @returns A stable string key identifying the server\n */\nexport function getMcpServerUniqueKey(\n  serverInfo: Pick<McpServerInfo, \"url\" | \"transport\" | \"customHeaders\">,\n): string {\n  const headerStr = serverInfo.customHeaders\n    ? JSON.stringify(\n        Object.entries(serverInfo.customHeaders)\n          .map(([k, v]) => [k.toLowerCase(), v] as const)\n          .sort(([a], [b]) => a.localeCompare(b)),\n      )\n    : \"\";\n\n  return `${serverInfo.url}|${serverInfo.transport ?? MCPTransport.HTTP}|${headerStr}`;\n}\n"]}