import { UseMutationResult, UseQueryResult } from "@tanstack/react-query";
export type CombinedMutationResult<TData = unknown, TError = unknown, TVariables = unknown, TContext = unknown> = Omit<UseMutationResult<TData, TError, TVariables, TContext>, "mutate" | "mutateAsync" | "reset" | "data" | "variables" | "context">;
/**
 * Combines two mutation results, showing the "loading state" of the two
 * mutations. For instance, if either mutation is pending, the combined
 * mutation result will be pending.
 * @param resultA - The first mutation result
 * @param resultB - The second mutation result
 * @returns The combined mutation result
 */
export declare function combineMutationResults<TData1, TData2, TError1, TError2>(resultA: UseMutationResult<TData1, TError1, any, any>, resultB: UseMutationResult<TData2, TError2, any, any>): CombinedMutationResult<TData1 | TData2, TError1 | TError2>;
export type CombinedQueryResult<TData1, TData2, TError1, TError2> = Omit<UseQueryResult<TData1 | TData2, TError1 | TError2>, "data" | "refetch" | "promise">;
/**
 * Combines two query results, showing the "loading state" of the two queries.
 * For instance, if either query is loading, the combined query result will be
 * loading.
 * @param resultA - The first query result
 * @param resultB - The second query result
 * @returns The combined query result
 */
export declare function combineQueryResults<TData1, TData2, TError1, TError2>(resultA: UseQueryResult<TData1, TError1>, resultB: UseQueryResult<TData2, TError2>): CombinedQueryResult<void, void, TError1, TError2>;
//# sourceMappingURL=query-utils.d.ts.map