{"version":3,"file":"mcp-server-utils.js","sourceRoot":"","sources":["../../src/util/mcp-server-utils.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  McpServerInfo,\n  NormalizedMcpServerInfo,\n} from \"../model/mcp-server-info\";\nimport { getMcpServerUniqueKey, MCPTransport } from \"../model/mcp-server-info\";\n\n/**\n * Derives a short, meaningful key from a server URL.\n * Strips TLDs and common prefixes to get a human-readable identifier.\n * For example, \"https://mcp.linear.app/mcp\" becomes \"linear\".\n * @returns A lowercased, human-readable key derived from the URL\n */\nexport function deriveServerKey(url: string): string {\n  try {\n    const parsed = new URL(url);\n    const hostname = parsed.hostname;\n\n    // Split hostname into parts\n    const parts = hostname.split(\".\");\n\n    // Remove common TLD patterns\n    // Handle cases like: .com, .org, .co.uk, .com.au, etc.\n    let relevantParts = [...parts];\n\n    // If we have 3+ parts and the last two are short (likely TLD like .co.uk)\n    if (\n      relevantParts.length >= 3 &&\n      relevantParts[relevantParts.length - 1].length <= 3 &&\n      relevantParts[relevantParts.length - 2].length <= 3\n    ) {\n      relevantParts = relevantParts.slice(0, -2);\n    }\n    // Otherwise just remove the last part (TLD like .com)\n    else if (relevantParts.length >= 2) {\n      relevantParts = relevantParts.slice(0, -1);\n    }\n\n    // From what's left, prefer the rightmost part that's not a common prefix\n    // Common prefixes: www, api, mcp, app, etc.\n    const commonPrefixes = new Set([\n      \"www\",\n      \"api\",\n      \"mcp\",\n      \"app\",\n      \"staging\",\n      \"dev\",\n      \"prod\",\n    ]);\n\n    // Work backwards through the parts to find a meaningful name\n    for (let i = relevantParts.length - 1; i >= 0; i--) {\n      const part = relevantParts[i];\n      if (part && !commonPrefixes.has(part.toLowerCase())) {\n        return part.toLowerCase();\n      }\n    }\n\n    // Fallback: use the last relevant part even if it's a common prefix\n    return relevantParts[relevantParts.length - 1]?.toLowerCase() || hostname;\n  } catch {\n    // If URL parsing fails, just return a sanitized version of the input\n    return url.replace(/[^a-zA-Z0-9]/g, \"_\").toLowerCase();\n  }\n}\n\n/**\n * Normalizes an MCP server info object, ensuring it has a serverKey.\n * If serverKey is not provided, derives it from the URL.\n * @returns The normalized MCP server info object\n */\nexport function normalizeServerInfo(\n  server: McpServerInfo | string,\n): NormalizedMcpServerInfo {\n  const base: McpServerInfo =\n    typeof server === \"string\"\n      ? {\n          url: server,\n          transport: MCPTransport.HTTP,\n        }\n      : server;\n\n  const serverKey = base.serverKey ?? deriveServerKey(base.url);\n  const transport = base.transport ?? MCPTransport.HTTP;\n\n  return { ...base, transport, serverKey };\n}\n\n/**\n * Deduplicates MCP servers by connection identity and ensures serverKey uniqueness.\n * First deduplicates by connection (url + transport), then ensures serverKey uniqueness\n * by appending -2, -3, etc. to duplicate serverKeys.\n * @param servers - Array of normalized MCP server info objects\n * @returns Array of deduplicated servers with unique serverKeys\n */\nexport function deduplicateMcpServers(\n  servers: NormalizedMcpServerInfo[],\n): NormalizedMcpServerInfo[] {\n  if (servers.length === 0) {\n    return servers;\n  }\n\n  // 1. Deduplicate by connection identity using a stable key\n  const byKey = new Map<string, NormalizedMcpServerInfo>();\n  for (const server of servers) {\n    const key = getMcpServerUniqueKey(server);\n    byKey.set(key, server);\n  }\n\n  const deduped = Array.from(byKey.values());\n\n  // 2. Ensure serverKey uniqueness for readable, unambiguous prefixes\n  const seen = new Map<string, number>();\n  return deduped.map((server) => {\n    const baseKey = server.serverKey;\n    const count = (seen.get(baseKey) ?? 0) + 1;\n    seen.set(baseKey, count);\n\n    if (count === 1) {\n      return server;\n    }\n\n    return {\n      ...server,\n      serverKey: `${baseKey}-${count}`,\n    };\n  });\n}\n"]}