{"version":3,"file":"message-builder.js","sourceRoot":"","sources":["../../src/util/message-builder.ts"],"names":[],"mappings":"AAIA;;;;;;;;;;;;GAYG;AACH,MAAM,0BAA0B,GAAG,yBAAyB,CAAC;AAE7D;;;;;;;;;;;;GAYG;AACH,SAAS,uBAAuB,CAC9B,IAAY,EACZ,aAAqC,EACrC,eAAiD;IAEjD,MAAM,KAAK,GAAqD,EAAE,CAAC;IAEnE,kDAAkD;IAClD,MAAM,OAAO,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,0BAA0B,CAAC,CAAC,CAAC;IACtE,IAAI,SAAS,GAAG,CAAC,CAAC;IAElB,wDAAwD;IACxD,KAAK,MAAM,KAAK,IAAI,OAAO,EAAE,CAAC;QAC5B,MAAM,CAAC,SAAS,EAAE,SAAS,EAAE,GAAG,CAAC,GAAG,KAAK,CAAC;QAC1C,MAAM,MAAM,GAAG,GAAG,SAAS,IAAI,GAAG,EAAE,CAAC;QAErC,gEAAgE;QAChE,IAAI,KAAK,CAAC,KAAK,KAAK,SAAS,IAAI,KAAK,CAAC,KAAK,GAAG,SAAS,EAAE,CAAC;YACzD,MAAM,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC;YACtD,IAAI,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAC1B,KAAK,CAAC,IAAI,CAAC;oBACT,IAAI,EAAE,MAAM;oBACZ,IAAI,EAAE,UAAU;iBACjB,CAAC,CAAC;YACL,CAAC;QACH,CAAC;QAED,MAAM,QAAQ,GAAqB,EAAE,GAAG,EAAE,CAAC;QAC3C,MAAM,IAAI,GAAG,aAAa,CAAC,MAAM,CAAC,CAAC;QACnC,IAAI,IAAI,EAAE,CAAC;YACT,QAAQ,CAAC,IAAI,GAAG,IAAI,CAAC;QACvB,CAAC;QAED,wEAAwE;QACxE,2EAA2E;QAC3E,MAAM,eAAe,GAAG,eAAe,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC;QACrD,IAAI,eAAe,EAAE,QAAQ,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;YACnC,MAAM,OAAO,GAAG,eAAe,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;YAC5C,IAAI,MAAM,IAAI,OAAO,IAAI,OAAO,CAAC,IAAI,EAAE,CAAC;gBACtC,QAAQ,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;YAC/B,CAAC;iBAAM,IAAI,MAAM,IAAI,OAAO,IAAI,OAAO,CAAC,IAAI,EAAE,CAAC;gBAC7C,QAAQ,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;YAC/B,CAAC;YACD,IAAI,UAAU,IAAI,OAAO,IAAI,OAAO,CAAC,QAAQ,EAAE,CAAC;gBAC9C,QAAQ,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC;YACvC,CAAC;QACH,CAAC;QAED,KAAK,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,UAAU,EAAE,QAAQ,EAAE,CAAC,CAAC;QAE3C,IAAI,KAAK,CAAC,KAAK,KAAK,SAAS,EAAE,CAAC;YAC9B,SAAS,GAAG,KAAK,CAAC,KAAK,GAAG,SAAS,CAAC,MAAM,CAAC;QAC7C,CAAC;IACH,CAAC;IAED,6EAA6E;IAC7E,IAAI,SAAS,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC;QAC5B,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;QACxC,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YACzB,KAAK,CAAC,IAAI,CAAC;gBACT,IAAI,EAAE,MAAM;gBACZ,IAAI,EAAE,SAAS;aAChB,CAAC,CAAC;QACL,CAAC;IACH,CAAC;IAED,oFAAoF;IACpF,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,IAAI,IAAI,CAAC,IAAI,EAAE,EAAE,CAAC;QACtC,KAAK,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC;IACrC,CAAC;IAED,OAAO,KAAK,CAAC;AACf,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,mBAAmB,CACjC,IAAY,EACZ,MAAqB,EACrB,gBAAwC,EAAE,EAC1C,eAAiD;IAEjD,MAAM,OAAO,GAAqD,EAAE,CAAC;IAErE,MAAM,oBAAoB,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC,MAAM,GAAG,CAAC,CAAC;IAEpD,IAAI,oBAAoB,EAAE,CAAC;QACzB,+DAA+D;QAC/D,iEAAiE;QACjE,iEAAiE;QACjE,MAAM,KAAK,GAAG,uBAAuB,CAAC,IAAI,EAAE,aAAa,EAAE,eAAe,CAAC,CAAC;QAC5E,OAAO,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,CAAC;IACzB,CAAC;IAED,wBAAwB;IACxB,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE,CAAC;QAC3B,OAAO,CAAC,IAAI,CAAC;YACX,IAAI,EAAE,WAAW;YACjB,SAAS,EAAE;gBACT,GAAG,EAAE,KAAK,CAAC,OAAO;aACnB;SACF,CAAC,CAAC;IACL,CAAC;IAED,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACzB,MAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC,CAAC;IACzD,CAAC;IAED,OAAO,OAAO,CAAC;AACjB,CAAC","sourcesContent":["import type { ReadResourceResult } from \"@modelcontextprotocol/sdk/types.js\";\nimport type TamboAI from \"@tambo-ai/typescript-sdk\";\nimport { StagedImage } from \"../hooks/use-message-images\";\n\n/**\n * Regular expression to match MCP resource references in the format: \\@serverKey:uri\n *\n * Examples:\n * - \\@tambo-1hfs429:tambo:test://static/resource/1\n * - \\@linear:file://path/to/file\n *\n * Pattern breakdown:\n * - \\@              - Literal \\@ symbol\n * - ([a-zA-Z0-9-]+) - Server key (alphanumeric + hyphens, client-side routing key)\n * - :               - Literal colon separator\n * - (\\S+)           - URI (non-whitespace characters, actual resource URI)\n */\nconst RESOURCE_REFERENCE_PATTERN = /@([a-zA-Z0-9-]+):(\\S+)/g;\n\n/**\n * Parses text with resource references and returns interleaved content parts.\n * Resource references have the format: \\@serverKey:uri\n *\n * The serverKey prefix is stripped before sending to the backend because:\n * - It's a client-side routing key (e.g., \"tambo-1hfs429\") used by React SDK to route to the correct MCP connection\n * - The backend only needs the actual resource URI (e.g., \"tambo:test://static/resource/1\")\n * - The backend routes resources based on the thread's MCP server configuration, not client-side keys\n * @param text - Text potentially containing resource references\n * @param resourceNames - Map of full resource IDs (serverKey:uri) to their display names\n * @param resourceContent - Optional map of prefixed URIs to resolved content (for client-side resources)\n * @returns Array of content parts in order (text and resource parts interleaved)\n */\nfunction parseResourceReferences(\n  text: string,\n  resourceNames: Record<string, string>,\n  resourceContent?: Map<string, ReadResourceResult>,\n): TamboAI.Beta.Threads.ChatCompletionContentPart[] {\n  const parts: TamboAI.Beta.Threads.ChatCompletionContentPart[] = [];\n\n  // Use matchAll to avoid global regex state issues\n  const matches = Array.from(text.matchAll(RESOURCE_REFERENCE_PATTERN));\n  let lastIndex = 0;\n\n  // Find all resource references and interleave with text\n  for (const match of matches) {\n    const [fullMatch, serverKey, uri] = match;\n    const fullId = `${serverKey}:${uri}`;\n\n    // Add text before this resource reference (preserve whitespace)\n    if (match.index !== undefined && match.index > lastIndex) {\n      const textBefore = text.slice(lastIndex, match.index);\n      if (textBefore.length > 0) {\n        parts.push({\n          type: \"text\",\n          text: textBefore,\n        });\n      }\n    }\n\n    const resource: TamboAI.Resource = { uri };\n    const name = resourceNames[fullId];\n    if (name) {\n      resource.name = name;\n    }\n\n    // Include resolved content for client-side resources (MCP and registry)\n    // Server-side resources won't be in the map - backend resolves them by URI\n    const resolvedContent = resourceContent?.get(fullId);\n    if (resolvedContent?.contents?.[0]) {\n      const content = resolvedContent.contents[0];\n      if (\"text\" in content && content.text) {\n        resource.text = content.text;\n      } else if (\"blob\" in content && content.blob) {\n        resource.blob = content.blob;\n      }\n      if (\"mimeType\" in content && content.mimeType) {\n        resource.mimeType = content.mimeType;\n      }\n    }\n\n    parts.push({ type: \"resource\", resource });\n\n    if (match.index !== undefined) {\n      lastIndex = match.index + fullMatch.length;\n    }\n  }\n\n  // Add remaining text after the last resource reference (preserve whitespace)\n  if (lastIndex < text.length) {\n    const textAfter = text.slice(lastIndex);\n    if (textAfter.length > 0) {\n      parts.push({\n        type: \"text\",\n        text: textAfter,\n      });\n    }\n  }\n\n  // If no resource references were found, return the whole text as a single text part\n  if (parts.length === 0 && text.trim()) {\n    parts.push({ type: \"text\", text });\n  }\n\n  return parts;\n}\n\n/**\n * Builds message content with text, MCP resource references, and images\n * @param text - The text content, may include \\@serverKey:uri resource references\n * @param images - Array of staged images\n * @param resourceNames - Map of resource IDs (serverKey:uri) to their display names\n * @param resourceContent - Optional map of prefixed URIs to resolved content (for client-side resources)\n * @returns Array of message content parts\n */\nexport function buildMessageContent(\n  text: string,\n  images: StagedImage[],\n  resourceNames: Record<string, string> = {},\n  resourceContent?: Map<string, ReadResourceResult>,\n): TamboAI.Beta.Threads.ChatCompletionContentPart[] {\n  const content: TamboAI.Beta.Threads.ChatCompletionContentPart[] = [];\n\n  const hasNonWhitespaceText = text.trim().length > 0;\n\n  if (hasNonWhitespaceText) {\n    // Parse resource references from the original text so that all\n    // user-visible whitespace (including leading/trailing spaces and\n    // internal spacing) is preserved in the resulting content parts.\n    const parts = parseResourceReferences(text, resourceNames, resourceContent);\n    content.push(...parts);\n  }\n\n  // Add images at the end\n  for (const image of images) {\n    content.push({\n      type: \"image_url\",\n      image_url: {\n        url: image.dataUrl,\n      },\n    });\n  }\n\n  if (content.length === 0) {\n    throw new Error(\"Message must contain text or images\");\n  }\n\n  return content;\n}\n"]}