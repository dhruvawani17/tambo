"use client";
import { useCallback, useEffect, useState } from "react";
import { useTamboClient } from "../../providers/tambo-client-provider";
import { useTamboRegistry } from "../../providers/tambo-registry-provider";
import { getAvailableComponents } from "../../util/registry";
import { useTamboMutation, useTamboQuery, } from "../../hooks/react-query-hooks";
import { combineMutationResults, } from "../../util/query-utils";
import { useTamboV1 } from "./use-tambo-v1";
import { useTamboV1ThreadInput } from "./use-tambo-v1-thread-input";
function normalizeSuggestionGenerateResponse(response) {
    if (response === undefined) {
        return [];
    }
    if (Array.isArray(response)) {
        return response;
    }
    throw new Error("Unexpected suggestions.generate response shape; expected an array");
}
/**
 * Hook for managing Tambo AI suggestions in a v1 thread.
 *
 * Automatically generates suggestions when the latest message is from the assistant
 * and the thread is idle (not streaming).
 *
 * Uses the shared thread input context, so accepting a suggestion without submitting
 * will automatically update the input field value for any component using
 * useTamboV1ThreadInput.
 * @param options - Configuration options for suggestion generation
 * @returns Object containing suggestions state and control functions
 * @example
 * ```tsx
 * function SuggestionsPanel() {
 *   const { suggestions, accept, isPending } = useTamboV1Suggestions();
 *
 *   return (
 *     <div>
 *       {suggestions.map(suggestion => (
 *         <button
 *           key={suggestion.id}
 *           onClick={() => accept({ suggestion })}
 *           disabled={isPending}
 *         >
 *           {suggestion.suggestion}
 *         </button>
 *       ))}
 *     </div>
 *   );
 * }
 *
 * function ChatInput() {
 *   // This input will automatically show the accepted suggestion
 *   const { value, setValue, submit } = useTamboV1ThreadInput();
 *   return <input value={value} onChange={e => setValue(e.target.value)} />;
 * }
 * ```
 */
export function useTamboV1Suggestions(options = {}) {
    const { maxSuggestions = 3 } = options;
    // Use shared thread input context
    const { setValue, submit, threadId } = useTamboV1ThreadInput();
    const { messages, isIdle } = useTamboV1(threadId);
    const tamboClient = useTamboClient();
    const { componentList, toolRegistry, componentToolAssociations } = useTamboRegistry();
    const [selectedSuggestionId, setSelectedSuggestionId] = useState(null);
    const latestMessage = messages[messages.length - 1];
    const isLatestFromAssistant = latestMessage?.role === "assistant";
    const latestMessageId = latestMessage?.id;
    // Reset selected suggestion when the message changes
    useEffect(() => {
        setSelectedSuggestionId(null);
    }, [latestMessageId]);
    const shouldGenerateSuggestions = latestMessageId && isLatestFromAssistant && isIdle && threadId;
    // Use React Query to fetch suggestions when conditions are met
    const suggestionsResult = useTamboQuery({
        queryKey: [
            "v1-suggestions",
            shouldGenerateSuggestions ? latestMessageId : null,
        ],
        queryFn: async () => {
            if (!shouldGenerateSuggestions || !threadId || !latestMessageId) {
                return [];
            }
            // Get registered components from the registry
            const components = getAvailableComponents(componentList, toolRegistry, componentToolAssociations);
            const response = await tamboClient.beta.threads.suggestions.generate(latestMessageId, {
                id: threadId,
                maxSuggestions,
                availableComponents: components,
            });
            return normalizeSuggestionGenerateResponse(response);
        },
        enabled: Boolean(shouldGenerateSuggestions),
        refetchOnWindowFocus: false,
        refetchOnReconnect: false,
        retry: false,
    });
    // Accept suggestion mutation
    const acceptMutationState = useTamboMutation({
        mutationFn: async ({ suggestion, shouldSubmit = false }) => {
            const text = suggestion.detailedSuggestion?.trim();
            if (!text) {
                throw new Error("Suggestion has no detailed content");
            }
            if (shouldSubmit) {
                // Set the value first, then submit
                setValue(text);
                await submit();
            }
            else {
                // Just update the shared input value
                setValue(text);
            }
            setSelectedSuggestionId(suggestion.id);
        },
    });
    // Generate suggestions mutation (for manual refresh)
    const generateMutationState = useTamboMutation({
        mutationFn: async (abortController) => {
            if (!shouldGenerateSuggestions || !threadId || !latestMessageId) {
                return [];
            }
            const components = getAvailableComponents(componentList, toolRegistry, componentToolAssociations);
            const response = await tamboClient.beta.threads.suggestions.generate(latestMessageId, {
                id: threadId,
                maxSuggestions,
                availableComponents: components,
            }, { signal: abortController.signal });
            return normalizeSuggestionGenerateResponse(response);
        },
        retry: false,
    });
    // Use query data if available, otherwise use mutation data
    const suggestions = isLatestFromAssistant
        ? (suggestionsResult.data ?? generateMutationState.data ?? [])
        : [];
    const accept = useCallback(async (acceptOptions) => {
        await acceptMutationState.mutateAsync(acceptOptions);
    }, [acceptMutationState]);
    return {
        suggestions,
        accept,
        selectedSuggestionId,
        acceptResult: acceptMutationState,
        generateResult: generateMutationState,
        suggestionsResult,
        ...combineMutationResults(acceptMutationState, generateMutationState),
    };
}
//# sourceMappingURL=use-tambo-v1-suggestions.js.map