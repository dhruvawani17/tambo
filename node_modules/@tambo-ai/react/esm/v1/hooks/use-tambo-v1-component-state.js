"use client";
/**
 * useTamboV1ComponentState - Component State Hook for v1 API
 *
 * Provides bidirectional state synchronization between React components
 * and the Tambo backend. State changes are debounced before syncing to
 * the server, and server state updates are reflected in the component.
 *
 * Must be used within a component rendered via the component renderer.
 */
import { useCallback, useEffect, useState, useRef } from "react";
import { useDebouncedCallback } from "use-debounce";
import { deepEqual } from "fast-equals";
import { useTamboClient } from "../../providers/tambo-client-provider";
import { useV1ComponentContent } from "../utils/component-renderer";
import { useStreamState } from "../providers/tambo-v1-stream-context";
/**
 * Find a component content block by ID in a specific thread.
 * Only searches the specified thread to prevent cross-thread data access
 * and improve performance (O(m*k) instead of O(n*m*k)).
 * @param streamState - The current stream state
 * @param threadId - The thread ID to search in
 * @param componentId - The component ID to find
 * @returns The component content block, or undefined if not found
 */
function findComponentContent(streamState, threadId, componentId) {
    // Only search the specified thread (not all threads)
    const threadState = streamState.threadMap[threadId];
    if (!threadState) {
        return undefined;
    }
    for (const message of threadState.thread.messages) {
        for (const content of message.content) {
            if (content.type === "component" && content.id === componentId) {
                return content;
            }
        }
    }
    return undefined;
}
export function useTamboV1ComponentState(keyName, initialValue, debounceTime = 500) {
    const client = useTamboClient();
    const { componentId, threadId } = useV1ComponentContent();
    const streamState = useStreamState();
    // Find the component content to get server state (only search current thread)
    const componentContent = findComponentContent(streamState, threadId, componentId);
    const serverState = componentContent?.state;
    const serverValue = serverState?.[keyName];
    // Local state - initialized from server state or initial value
    const [localState, setLocalState] = useState(() => serverValue ?? initialValue);
    // Track pending state and errors
    const [isPending, setIsPending] = useState(false);
    const [error, setError] = useState(null);
    // Track the last value we sent to avoid overwriting with stale server state
    const lastSentValueRef = useRef(undefined);
    // Track whether there's a pending local change that hasn't synced yet
    const hasPendingLocalChangeRef = useRef(false);
    // Track in-flight sync requests to avoid stale completions clearing pending state
    const syncSeqRef = useRef(0);
    // Debounced function to sync state to server
    const syncToServer = useDebouncedCallback(async (newState) => {
        const seq = ++syncSeqRef.current;
        setIsPending(true);
        setError(null);
        lastSentValueRef.current = newState;
        try {
            await client.threads.state.updateState(componentId, {
                threadId,
                state: { [keyName]: newState },
            });
            // Clear pending flag after successful sync
            hasPendingLocalChangeRef.current = false;
        }
        catch (err) {
            // Clear pending flag on error to allow server reconciliation
            hasPendingLocalChangeRef.current = false;
            const syncError = err instanceof Error ? err : new Error(String(err));
            setError(syncError);
            console.error(`[useTamboV1ComponentState] Failed to sync state for ${componentId}:`, syncError);
        }
        finally {
            // Only clear isPending if this is the most recent request
            if (seq === syncSeqRef.current) {
                setIsPending(false);
            }
        }
    }, debounceTime);
    // setState function that updates local state and triggers debounced sync
    const setState = useCallback((newState) => {
        setLocalState((prev) => {
            const nextState = typeof newState === "function"
                ? newState(prev)
                : newState;
            // Mark that we have a pending local change
            hasPendingLocalChangeRef.current = true;
            // Trigger debounced sync to server
            void syncToServer(nextState);
            return nextState;
        });
    }, [syncToServer]);
    // Sync from server state when it changes (e.g., from streaming events)
    useEffect(() => {
        if (serverValue === undefined) {
            return;
        }
        // Don't overwrite local changes that haven't synced yet
        if (hasPendingLocalChangeRef.current) {
            return;
        }
        // Only sync if the server value is different from what we last sent
        // This prevents overwriting local state with stale server values
        if (lastSentValueRef.current !== undefined &&
            deepEqual(serverValue, lastSentValueRef.current)) {
            return;
        }
        // Use functional update to avoid localState in deps
        setLocalState((prev) => deepEqual(serverValue, prev) ? prev : serverValue);
    }, [serverValue]);
    // Flush pending updates on unmount
    useEffect(() => {
        return () => {
            void syncToServer.flush();
        };
    }, [syncToServer]);
    // Flush function for immediate sync
    const flush = useCallback(() => {
        void syncToServer.flush();
    }, [syncToServer]);
    return [localState, setState, { isPending, error, flush }];
}
//# sourceMappingURL=use-tambo-v1-component-state.js.map