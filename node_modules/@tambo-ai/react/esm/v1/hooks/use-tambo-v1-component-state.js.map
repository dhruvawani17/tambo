{"version":3,"file":"use-tambo-v1-component-state.js","sourceRoot":"","sources":["../../../src/v1/hooks/use-tambo-v1-component-state.ts"],"names":[],"mappings":"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","sourcesContent":["\"use client\";\n\n/**\n * useTamboV1ComponentState - Component State Hook for v1 API\n *\n * Provides bidirectional state synchronization between React components\n * and the Tambo backend. State changes are debounced before syncing to\n * the server, and server state updates are reflected in the component.\n *\n * Must be used within a component rendered via the component renderer.\n */\n\nimport { useCallback, useEffect, useState, useRef } from \"react\";\nimport { useDebouncedCallback } from \"use-debounce\";\nimport { deepEqual } from \"fast-equals\";\nimport { useTamboClient } from \"../../providers/tambo-client-provider\";\nimport { useV1ComponentContent } from \"../utils/component-renderer\";\nimport { useStreamState } from \"../providers/tambo-v1-stream-context\";\nimport type { V1ComponentContent } from \"../types/message\";\n\n/**\n * Return type for useTamboV1ComponentState hook.\n * Similar to useState but with additional metadata.\n */\nexport type UseTamboV1ComponentStateReturn<S> = [\n  currentState: S,\n  setState: (newState: S | ((prev: S) => S)) => void,\n  meta: {\n    isPending: boolean;\n    error: Error | null;\n    flush: () => void;\n  },\n];\n\n/**\n * Find a component content block by ID in a specific thread.\n * Only searches the specified thread to prevent cross-thread data access\n * and improve performance (O(m*k) instead of O(n*m*k)).\n * @param streamState - The current stream state\n * @param threadId - The thread ID to search in\n * @param componentId - The component ID to find\n * @returns The component content block, or undefined if not found\n */\nfunction findComponentContent(\n  streamState: ReturnType<typeof useStreamState>,\n  threadId: string,\n  componentId: string,\n): V1ComponentContent | undefined {\n  // Only search the specified thread (not all threads)\n  const threadState = streamState.threadMap[threadId];\n  if (!threadState) {\n    return undefined;\n  }\n\n  for (const message of threadState.thread.messages) {\n    for (const content of message.content) {\n      if (content.type === \"component\" && content.id === componentId) {\n        return content;\n      }\n    }\n  }\n  return undefined;\n}\n\n/**\n * Hook for managing component state with bidirectional server sync.\n *\n * This hook acts like useState but automatically syncs state changes\n * to the Tambo backend. Server-side state updates are also reflected\n * in the component.\n *\n * Must be used within a component rendered via the component renderer.\n * @param keyName - The unique key to identify this state value within the component's state\n * @param initialValue - Initial value for the state (used if no server state exists)\n * @param debounceTime - Debounce time in milliseconds (default: 500ms)\n * @returns Tuple of [currentState, setState, meta]\n * @example\n * ```tsx\n * function Counter() {\n *   const [count, setCount, { isPending }] = useTamboV1ComponentState('count', 0);\n *\n *   return (\n *     <div>\n *       <span>{count}</span>\n *       <button onClick={() => setCount(c => c + 1)} disabled={isPending}>\n *         Increment\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n */\nexport function useTamboV1ComponentState<S = undefined>(\n  keyName: string,\n  initialValue?: S,\n  debounceTime?: number,\n): UseTamboV1ComponentStateReturn<S | undefined>;\nexport function useTamboV1ComponentState<S>(\n  keyName: string,\n  initialValue: S,\n  debounceTime?: number,\n): UseTamboV1ComponentStateReturn<S>;\nexport function useTamboV1ComponentState<S>(\n  keyName: string,\n  initialValue?: S,\n  debounceTime = 500,\n): UseTamboV1ComponentStateReturn<S> {\n  const client = useTamboClient();\n  const { componentId, threadId } = useV1ComponentContent();\n  const streamState = useStreamState();\n\n  // Find the component content to get server state (only search current thread)\n  const componentContent = findComponentContent(\n    streamState,\n    threadId,\n    componentId,\n  );\n  const serverState = componentContent?.state as\n    | Record<string, unknown>\n    | undefined;\n  const serverValue = serverState?.[keyName] as S | undefined;\n\n  // Local state - initialized from server state or initial value\n  const [localState, setLocalState] = useState<S>(\n    () => serverValue ?? (initialValue as S),\n  );\n\n  // Track pending state and errors\n  const [isPending, setIsPending] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  // Track the last value we sent to avoid overwriting with stale server state\n  const lastSentValueRef = useRef<S | undefined>(undefined);\n\n  // Track whether there's a pending local change that hasn't synced yet\n  const hasPendingLocalChangeRef = useRef(false);\n\n  // Track in-flight sync requests to avoid stale completions clearing pending state\n  const syncSeqRef = useRef(0);\n\n  // Debounced function to sync state to server\n  const syncToServer = useDebouncedCallback(async (newState: S) => {\n    const seq = ++syncSeqRef.current;\n    setIsPending(true);\n    setError(null);\n    lastSentValueRef.current = newState;\n\n    try {\n      await client.threads.state.updateState(componentId, {\n        threadId,\n        state: { [keyName]: newState },\n      });\n      // Clear pending flag after successful sync\n      hasPendingLocalChangeRef.current = false;\n    } catch (err) {\n      // Clear pending flag on error to allow server reconciliation\n      hasPendingLocalChangeRef.current = false;\n      const syncError = err instanceof Error ? err : new Error(String(err));\n      setError(syncError);\n      console.error(\n        `[useTamboV1ComponentState] Failed to sync state for ${componentId}:`,\n        syncError,\n      );\n    } finally {\n      // Only clear isPending if this is the most recent request\n      if (seq === syncSeqRef.current) {\n        setIsPending(false);\n      }\n    }\n  }, debounceTime);\n\n  // setState function that updates local state and triggers debounced sync\n  const setState = useCallback(\n    (newState: S | ((prev: S) => S)) => {\n      setLocalState((prev) => {\n        const nextState =\n          typeof newState === \"function\"\n            ? (newState as (prev: S) => S)(prev)\n            : newState;\n\n        // Mark that we have a pending local change\n        hasPendingLocalChangeRef.current = true;\n\n        // Trigger debounced sync to server\n        void syncToServer(nextState);\n\n        return nextState;\n      });\n    },\n    [syncToServer],\n  );\n\n  // Sync from server state when it changes (e.g., from streaming events)\n  useEffect(() => {\n    if (serverValue === undefined) {\n      return;\n    }\n\n    // Don't overwrite local changes that haven't synced yet\n    if (hasPendingLocalChangeRef.current) {\n      return;\n    }\n\n    // Only sync if the server value is different from what we last sent\n    // This prevents overwriting local state with stale server values\n    if (\n      lastSentValueRef.current !== undefined &&\n      deepEqual(serverValue, lastSentValueRef.current)\n    ) {\n      return;\n    }\n\n    // Use functional update to avoid localState in deps\n    setLocalState((prev) =>\n      deepEqual(serverValue, prev) ? prev : serverValue,\n    );\n  }, [serverValue]);\n\n  // Flush pending updates on unmount\n  useEffect(() => {\n    return () => {\n      void syncToServer.flush();\n    };\n  }, [syncToServer]);\n\n  // Flush function for immediate sync\n  const flush = useCallback(() => {\n    void syncToServer.flush();\n  }, [syncToServer]);\n\n  return [localState, setState, { isPending, error, flush }];\n}\n"]}