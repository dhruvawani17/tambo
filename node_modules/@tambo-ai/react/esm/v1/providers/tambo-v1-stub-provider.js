"use client";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import React, { useMemo } from "react";
import { TamboClientContext } from "../../providers/tambo-client-provider";
import { TamboRegistryContext } from "../../providers/tambo-registry-provider";
import { TamboV1ConfigContext } from "./tambo-v1-provider";
import { TamboV1StreamProvider, } from "./tambo-v1-stream-context";
import { TamboV1ThreadInputContext, } from "./tambo-v1-thread-input-provider";
/**
 * Creates a default TamboV1Thread from messages or returns the full thread.
 * @returns A normalized thread object
 */
function normalizeThread(threadData, threadId) {
    if (!threadData) {
        return {
            id: threadId,
            messages: [],
            status: "idle",
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
        };
    }
    if ("id" in threadData && "status" in threadData) {
        return threadData;
    }
    return {
        id: threadId,
        messages: threadData.messages,
        status: "idle",
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
    };
}
/**
 * TamboV1StubProvider provides mock implementations of all v1 contexts
 * for testing components that use Tambo hooks.
 *
 * All operations are no-ops by default, returning stub data.
 * Override specific behaviors via props as needed for testing.
 * Stream state is derived once from props and is not updated by thread management.
 * @returns A provider wrapper suitable for tests
 */
export function TamboV1StubProvider({ children, thread: threadData, threadId: providedThreadId, components = [], tools = [], userKey, inputValue: initialInputValue = "", isStreaming = false, onSubmit, onSetValue, onStartNewThread, onSwitchThread, onInitThread, }) {
    // Determine thread ID
    const threadId = providedThreadId ??
        (threadData && "id" in threadData ? threadData.id : "stub_thread");
    // Normalize thread data
    const thread = normalizeThread(threadData, threadId);
    // Create stub QueryClient
    const queryClient = useMemo(() => new QueryClient({
        defaultOptions: {
            queries: { retry: false },
            mutations: { retry: false },
        },
    }), []);
    // Create stub client
    const stubClient = useMemo(() => ({}), []);
    // Build component registry
    const componentList = useMemo(() => {
        const list = {};
        for (const component of components) {
            list[component.name] = {
                component: component.component,
                loadingComponent: component.loadingComponent,
                name: component.name,
                description: component.description,
                props: component.propsDefinition ?? {},
                contextTools: [],
            };
        }
        return list;
    }, [components]);
    // Build tool registry
    const toolRegistry = useMemo(() => {
        return tools.reduce((acc, tool) => {
            acc[tool.name] = tool;
            return acc;
        }, {});
    }, [tools]);
    // Stream state
    const streamState = useMemo(() => {
        const threadState = {
            thread,
            streaming: {
                status: isStreaming ? "streaming" : "idle",
            },
            accumulatingToolArgs: new Map(),
        };
        return {
            threadMap: { [threadId]: threadState },
            currentThreadId: threadId,
        };
    }, [thread, threadId, isStreaming]);
    // Stream dispatch (no-op)
    const streamDispatch = useMemo(() => () => { }, []);
    // Thread management
    const threadManagement = useMemo(() => ({
        initThread: onInitThread ?? (() => { }),
        switchThread: onSwitchThread ?? (() => { }),
        startNewThread: onStartNewThread ??
            (() => {
                const newId = `stub_${crypto.randomUUID()}`;
                return newId;
            }),
    }), [onInitThread, onSwitchThread, onStartNewThread]);
    // Config context
    const config = useMemo(() => ({ userKey }), [userKey]);
    // Input state (managed internally for stub)
    const [inputValue, setInputValueInternal] = React.useState(initialInputValue);
    // Thread input context
    const threadInputContext = useMemo(() => {
        const setValue = onSetValue ?? setInputValueInternal;
        const submit = onSubmit ??
            (async () => {
                return { threadId };
            });
        return {
            value: inputValue,
            setValue,
            submit,
            threadId,
            setThreadId: () => { },
            images: [],
            addImage: async () => { },
            addImages: async () => { },
            removeImage: () => { },
            clearImages: () => { },
            isPending: false,
            isError: false,
            error: null,
            isIdle: true,
            isSuccess: false,
            status: "idle",
            data: undefined,
            variables: undefined,
            failureCount: 0,
            failureReason: null,
            reset: () => { },
            context: undefined,
            submittedAt: 0,
            isPaused: false,
        };
    }, [inputValue, threadId, onSubmit, onSetValue, setInputValueInternal]);
    // Registry context
    const registryContext = useMemo(() => ({
        componentList,
        toolRegistry,
        componentToolAssociations: {},
        mcpServerInfos: [],
        resources: [],
        resourceSource: null,
        onCallUnregisteredTool: undefined,
        registerComponent: () => { },
        registerTool: () => { },
        registerTools: () => { },
        addToolAssociation: () => { },
        registerMcpServer: () => { },
        registerMcpServers: () => { },
        registerResource: () => { },
        registerResources: () => { },
        registerResourceSource: () => { },
    }), [componentList, toolRegistry]);
    // Client context
    const clientContext = useMemo(() => ({
        client: stubClient,
        queryClient,
        isUpdatingToken: false,
    }), [stubClient, queryClient]);
    return (React.createElement(QueryClientProvider, { client: queryClient },
        React.createElement(TamboClientContext.Provider, { value: clientContext },
            React.createElement(TamboRegistryContext.Provider, { value: registryContext },
                React.createElement(TamboV1ConfigContext.Provider, { value: config },
                    React.createElement(TamboV1StreamProvider, { state: streamState, dispatch: streamDispatch, threadManagement: threadManagement },
                        React.createElement(TamboV1ThreadInputContext.Provider, { value: threadInputContext }, children)))))));
}
//# sourceMappingURL=tambo-v1-stub-provider.js.map