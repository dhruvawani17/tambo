{"version":3,"file":"component-metadata.js","sourceRoot":"","sources":["../../src/model/component-metadata.ts"],"names":[],"mappings":"","sourcesContent":["import type { ToolAnnotations as MCPToolAnnotations } from \"@modelcontextprotocol/sdk/types.js\";\nimport type { StandardSchemaV1 } from \"@standard-schema/spec\";\nimport TamboAI from \"@tambo-ai/typescript-sdk\";\nimport { JSONSchema7 } from \"json-schema\";\nimport { ComponentType } from \"react\";\n\n/**\n * A schema type that accepts either a Standard Schema compliant validator\n * (e.g., Zod, Valibot, ArkType) or a raw JSON Schema object.\n *\n * Standard Schema is a specification that provides a unified interface for\n * TypeScript validation libraries. Libraries like Zod implement this spec,\n * allowing us to accept any compliant validator without depending on a specific library.\n * @see https://standardschema.dev/\n */\nexport type SupportedSchema<Input = unknown, Output = Input> =\n  | StandardSchemaV1<Input, Output>\n  | JSONSchema7;\n\n/**\n * Annotations describing a tool's behavior, aligned with the MCP (Model Context Protocol)\n * specification. These hints help clients understand how tools behave and can be used\n * to optimize tool execution strategies.\n * @see https://modelcontextprotocol.io/specification/2025-06-18/schema#toolannotations\n */\nexport type ToolAnnotations = MCPToolAnnotations & {\n  /**\n   * Indicates that the tool is safe to be called repeatedly while a response is\n   * being streamed. This is typically used for read-only tools that do not\n   * cause side effects.\n   */\n  tamboStreamableHint?: boolean;\n};\n\n/** Extension of the ToolParameters interface from Tambo AI to include JSONSchema definition */\nexport type ParameterSpec = TamboAI.ToolParameters & {\n  schema?: JSONSchema7;\n};\n\n/**\n * Extends the base ContextTool interface from Tambo AI to include schema information\n * for parameter validation.\n */\nexport interface ComponentContextToolMetadata\n  extends TamboAI.ComponentContextToolMetadata {\n  parameters: ParameterSpec[];\n  /**\n   * Optional per-tool call limit. When set, this overrides the project's\n   * global tool call limit for this specific tool.\n   *\n   * This is useful for tools that should only be called once or twice\n   * regardless of the project's global limit.\n   */\n  maxCalls?: number;\n  /**\n   * Annotations describing the tool's behavior. See {@link ToolAnnotations}.\n   */\n  annotations?: ToolAnnotations;\n}\n\nexport interface ComponentContextTool {\n  getComponentContext: (...args: any[]) => Promise<any>;\n  definition: ComponentContextToolMetadata;\n}\n\nexport interface RegisteredComponent extends TamboAI.AvailableComponent {\n  component: ComponentType<any>;\n  loadingComponent?: ComponentType<any>;\n}\n\nexport type ComponentRegistry = Record<string, RegisteredComponent>;\n\nexport type TamboToolRegistry = Record<string, TamboTool>;\n\n/**\n * A JSON Schema that is compatible with the MCP.\n * This is a simplified JSON Schema that is compatible with the MCPClient and the tool's inputSchema.\n *\n * Do not export this type from the SDK.\n */\nexport type JSONSchemaLite = JSONSchema7 & {\n  description?: string;\n};\n\ntype MaybeAsync<T> = T | Promise<T>;\n\n/**\n * TamboTool is a type that represents a tool that can be registered with Tambo.\n *\n * It is preferable to use the `defineTool` helper function to create tools, as\n * it provides better type inference and safety.\n * @example\n * ```ts\n * import { TamboTool, defineTool } from \"@tambo-ai/react\";\n * import { z } from \"zod\";\n *\n * const locationToLatLon = defineTool({\n *   name: \"location_to_latlon\",\n *   description:\n *     \"Fetch latitude and longitude from a location string. Returns an object with 'lat' and 'lon' properties.\",\n *   tool: async ({ location }) => getLatLonFromLocation(location),\n *   inputSchema: z.object({\n *     location: z.string(),\n *   }),\n *   outputSchema: z.object({\n *     lat: z.number(),\n *     lon: z.number(),\n *   }),\n * });\n * ```\n */\nexport interface TamboTool<\n  Params = any,\n  Returns = any,\n  Rest extends any[] = [],\n> {\n  /**\n   * Unique identifier for the tool\n   */\n  name: string;\n  /**\n   * Description of what the tool does - used by AI to determine when to use it\n   */\n  description: string;\n  /**\n   * Optional human-readable name of the tool for display purposes.\n   */\n  title?: string;\n  /**\n   * Optional limit for how many times this tool may be called while\n   * generating a single response. If present, this value overrides the\n   * project's global `maxToolCallLimit` for this tool.\n   * @example 1\n   */\n  maxCalls?: number;\n  /**\n   * Annotations describing the tool's behavior, aligned with the MCP specification.\n   * Use `tamboStreamableHint: true` to enable streaming execution of partial tool calls.\n   * @see {@link ToolAnnotations}\n   * @example\n   * ```ts\n   * const setTextTool: TamboTool<{ text: string }> = {\n   *   name: \"set_text\",\n   *   description: \"Set the displayed text\",\n   *   annotations: {\n   *     tamboStreamableHint: true, // tool is safe for streaming calls\n   *   },\n   *   tool: ({ text }) => setText(text),\n   *   inputSchema: z.object({ text: z.string() }),\n   *   outputSchema: z.void(),\n   * };\n   * ```\n   */\n  annotations?: ToolAnnotations;\n\n  /**\n   * The function that implements the tool's logic. This function will be called\n   * by Tambo when the model decides to invoke the tool.\n   * @param params - The input parameters for the tool. These are validated\n   * against the inputSchema before being passed so are guaranteed to be correct\n   * when called by the model.\n   * @returns The result of the tool execution, which can be a value or a\n   * Promise resolving to a value\n   */\n  tool: (params: Params, ...rest: Rest) => MaybeAsync<Returns>;\n\n  /**\n   * The schema for the tool's input parameters. This can be a validator from\n   * any Standard Schema compliant library (Zod 3.24+, Zod 4.x) or a\n   * raw JSON Schema object.\n   *\n   * This schema is used to validate and parse the parameters before passing\n   * them to the tool function.\n   */\n  inputSchema: SupportedSchema<Params>;\n\n  /**\n   * The schema for the tool's output/return value. This can be any Standard Schema\n   * compliant validator (Zod 3.24+, Zod 4.x) or a raw JSON Schema object.\n   *\n   * This is used to inform the model about the structure of the tool's return value\n   * and is not used for runtime validation at this stage.\n   */\n  outputSchema: SupportedSchema<Returns>;\n\n  /**\n   * Optional function to transform the tool's return value into an array of content parts.\n   * If not provided, the return value will be converted to a string and wrapped in a text content part.\n   * @param result - The result returned by the tool function\n   * @returns An array of content parts to be sent back to the AI\n   */\n  transformToContent?: (\n    result: any,\n  ) =>\n    | Promise<TamboAI.Beta.Threads.ChatCompletionContentPart[]>\n    | TamboAI.Beta.Threads.ChatCompletionContentPart[];\n}\n\n/**\n * A tool that uses JSON Schema compliant input and output schemas.\n * This does not provide type safety for the tool's parameters and return value.\n * @internal\n */\nexport type TamboToolJSONSchema<\n  Args extends unknown[] = unknown[],\n  Returns = unknown,\n> = Omit<TamboTool<Args, Returns>, \"tool\" | \"inputSchema\" | \"outputSchema\"> & {\n  tool: (...args: Args) => MaybeAsync<Returns>;\n  inputSchema: JSONSchemaLite;\n  outputSchema: JSONSchemaLite;\n};\n\n/**\n * A tool that could not be matched to any known schema types.\n * This means type safety cannot be guaranteed.\n * @internal\n */\nexport type TamboToolUnknown = Omit<\n  TamboTool,\n  \"tool\" | \"inputSchema\" | \"outputSchema\"\n> & {\n  tool: (...args: unknown[]) => MaybeAsync<unknown>;\n  inputSchema: SupportedSchema;\n  outputSchema: SupportedSchema;\n};\n\n/**\n * A tool that uses Standard Schema compliant input and output schemas.\n * This provides full type safety for the tool's parameters and return value.\n * @internal\n */\nexport type TamboToolStandardSchema<\n  Input extends StandardSchemaV1 = StandardSchemaV1,\n  Output extends StandardSchemaV1 = StandardSchemaV1,\n> = Omit<\n  TamboTool<\n    StandardSchemaV1.InferOutput<Input>,\n    StandardSchemaV1.InferOutput<Output>\n  >,\n  \"tool\" | \"inputSchema\" | \"outputSchema\"\n> & {\n  tool: (\n    ...args: [StandardSchemaV1.InferOutput<Input>]\n  ) => MaybeAsync<StandardSchemaV1.InferOutput<Output>>;\n  inputSchema: Input;\n  outputSchema: Output;\n};\n\n/**\n * If you're seeing this type, it means that you are using a deprecated and now\n * unsupported schema type for defining Tambo tools.\n *\n * Follow the migration guide to update your tool definitions to use\n * inputSchema and outputSchema with either Standard Schema compliant validators\n * (like Zod 3.25.76, Zod 4.x) or raw JSON Schema objects.\n * @deprecated replace `toolSchema` with `inputSchema` and `outputSchema` instead.\n * @see {@link https://docs.tambo.ai/api-reference/migration/toolschema}\n */\nexport type UnsupportedSchemaTamboTool = Omit<\n  TamboTool,\n  \"tool\" | \"inputSchema\" | \"outputSchema\"\n> & {\n  /**\n   * @deprecated replace `toolSchema` with `inputSchema` and `outputSchema` instead.\n   */\n  toolSchema: any;\n  tool: (...args: any[]) => MaybeAsync<any>;\n  inputSchema?: never;\n  outputSchema?: never;\n};\n\nexport type TamboToolAssociations = Record<string, string[]>;\n/**\n * A component that can be registered with the TamboRegistryProvider.\n */\n\nexport interface TamboComponent {\n  /** The name of the component */\n  name: string;\n  /** The description of the component */\n  description: string;\n  /**\n   * The React component to render.\n   *\n   * Make sure to pass the Component itself, not an instance of the component. For example,\n   * if you have a component like this:\n   *\n   * ```tsx\n   * const MyComponent = () => {\n   *   return <div>My Component</div>;\n   * };\n   * ```\n   *\n   * You should pass the `Component`:\n   *\n   * ```tsx\n   * const components = [MyComponent];\n   * <TamboRegistryProvider components={components} />\n   * ```\n   */\n  component: ComponentType<any>;\n\n  /**\n   * Schema describing the component's props. Accepts any Standard Schema\n   * compliant validator (Zod, Valibot, ArkType, etc.) or a raw JSON Schema\n   * object.\n   *\n   * Either this or propsDefinition must be provided, but not both.\n   * @example\n   * ```typescript\n   * import { z } from \"zod/v4\";\n   *\n   * const component: TamboComponent = {\n   *   name: \"MyComponent\",\n   *   description: \"A sample component\",\n   *   component: MyComponent,\n   *   propsSchema: z.object({\n   *     title: z.string(),\n   *     count: z.number().optional()\n   *   })\n   * };\n   * ```\n   */\n  propsSchema?: SupportedSchema;\n  /**\n   * The props definition of the component as a JSON object.\n   * Either this or propsSchema must be provided, but not both.\n   * @deprecated Use propsSchema instead.\n   */\n  propsDefinition?: any;\n  /** The loading component to render while the component is loading */\n  loadingComponent?: ComponentType<any>;\n  /** The tools that are associated with the component */\n  associatedTools?: TamboTool[];\n  /** Annotations describing the component's behavior. */\n  annotations?: ToolAnnotations;\n}\n\ntype OptionalSchemaProps<T> = Omit<T, \"inputSchema\" | \"outputSchema\"> & {\n  inputSchema?: T extends { inputSchema: infer I } ? I : never;\n  outputSchema?: T extends { outputSchema: infer O } ? O : never;\n};\n\n/**\n * Registers one or more Tambo tools.\n * @param tools - An array of Tambo tools to register\n * @param warnOnOverwrite - Whether to warn if any tool is being overwritten\n */\nexport interface RegisterToolsFn {\n  /**\n   * @deprecated Follow the {@link https://docs.tambo.ai/api-reference/migration/toolschema | Migration Guide} to update\n   * your tool definitions to use `inputSchema` and `outputSchema` instead.\n   */\n  (tools: UnsupportedSchemaTamboTool[], warnOnOverwrite?: boolean): void;\n  /**\n   * Register one or more Tambo tools. For better type inference, consider registering tools individually using the\n   * `registerTool` function or use the `defineTool` helper when defining your tools.\n   * @example\n   * ```typescript\n   * import { defineTool } from \"@tambo-ai/react\";\n   * const tools = [\n   *   defineTool({...});\n   *   defineTool({...});\n   * ];\n   * registerTools(tools);\n   * @param tools - An array of Tambo tools to register\n   * @param warnOnOverwrite - Whether to warn if any tool is being overwritten\n   */\n  (tools: TamboTool[], warnOnOverwrite?: boolean): void;\n}\n\n/**\n * Function interface for registering a Tambo tool with full type inference.\n * This function has multiple overloads to handle different schema types. This\n * is a utility function and does not perform any runtime logic.\n */\nexport interface RegisterToolFn {\n  <Args extends StandardSchemaV1, Returns extends StandardSchemaV1>(\n    tool: TamboToolStandardSchema<Args, Returns>,\n    warnOnOverwrite?: boolean,\n  ): void;\n  <Args extends any[], Returns = any>(\n    tool: TamboToolJSONSchema<Args, Returns>,\n    warnOnOverwrite?: boolean,\n  ): void;\n  (tool: TamboToolUnknown, warnOnOverwrite?: boolean): void;\n  (tool: TamboTool, warnOnOverwrite?: boolean): void;\n  /**\n   * @deprecated Follow the {@link https://docs.tambo.ai/api-reference/migration/toolschema | Migration Guide} to update\n   * your tool definitions to use `inputSchema` and `outputSchema` instead.\n   * @param tool - The unsupported schema Tambo tool to register\n   * @param warnOnOverwrite - Whether to warn if the tool is being overwritten\n   */\n  (tool: UnsupportedSchemaTamboTool, warnOnOverwrite?: boolean): void;\n}\n\n/**\n * Function interface for defining a Tambo tool with full type inference. This function has multiple overloads to handle\n * different schema types. This is a utility function and does not perform any runtime logic.\n */\nexport interface DefineToolFn {\n  /**\n   * @deprecated Follow the {@link https://docs.tambo.ai/api-reference/migration/toolschema | Migration Guide} to update\n   * your tool definitions to use `inputSchema` and `outputSchema` instead.\n   * @param tool The tool definition to register\n   * @returns The registered tool definition\n   */\n  (tool: UnsupportedSchemaTamboTool): typeof tool;\n  /**\n   * Provides type safety for defining a Tambo Tool.\n   *\n   * Tambo uses the [standard-schema.dev](https://standard-schema.dev) spec which means you can use any Standard Schema\n   * compliant validator (Zod 3.24+, Zod 4.x). This definition ensures the input and output types are correctly\n   * inferred from the provided schemas.\n   * @example\n   * ```typescript\n   * import { z } from \"zod/v4\";\n   *\n   * const myTool = defineTool({\n   *   name: \"myTool\",\n   *   description: \"An example tool\",\n   *   inputSchema: z.object({\n   *     input: z.string().describe(\"Input description\")\n   *   }),\n   *   outputSchema: z.number().describe(\"Result description\"),\n   *   tool: ({ input }) => input.length,\n   * });\n   * ```\n   * @see {@link https://standard-schema.dev/}\n   * @param tool The tool definition to register\n   * @returns The registered tool definition\n   */\n  <Input extends StandardSchemaV1, Output extends StandardSchemaV1>(\n    tool: OptionalSchemaProps<TamboToolStandardSchema<Input, Output>>,\n  ): TamboToolStandardSchema<Input, Output>;\n  /**\n   * Provides type safety for defining a Tambo Tool with JSON Schema input and output.\n   *\n   * This overload is used when providing raw JSON Schema objects instead of StandardSchema validators.\n   * Type inference is limited when using raw JSON Schema.\n   * @see {@link https://standard-schema.dev/}\n   * @param tool The tool definition to register\n   * @returns The registered tool definition\n   */\n  <I extends any[], O = any>(\n    tool: OptionalSchemaProps<TamboToolJSONSchema<I, O>>,\n  ): TamboToolJSONSchema<I, O>;\n  /**\n   * Provides type safety for defining a Tambo Tool.\n   *\n   * This overload is used when the schema types could not be matched to known types.\n   * Type safety cannot be guaranteed.\n   * @param tool The tool definition to register\n   * @returns The registered tool definition\n   */\n  (tool: OptionalSchemaProps<TamboToolUnknown>): TamboToolUnknown;\n  /**\n   * Provides type safety for defining a Tambo Tool.\n   *\n   * This overload is used when providing a fully defined TamboTool.\n   * @param tool The tool definition to register\n   * @returns The registered tool definition\n   */\n  (tool: OptionalSchemaProps<TamboTool>): TamboTool;\n}\n"]}