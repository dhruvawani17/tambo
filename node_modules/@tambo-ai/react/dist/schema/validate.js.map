{"version":3,"file":"validate.js","sourceRoot":"","sources":["../../src/schema/validate.ts"],"names":[],"mappings":"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","sourcesContent":["import type { JSONSchema7 } from \"json-schema\";\nimport { schemaToJsonSchema } from \"./schema\";\nimport { isStandardSchema } from \"./standard-schema\";\n\n/*\n * Check if a JSON Schema represents a record type (map with dynamic keys).\n *\n * For our purposes, any `object` schema with `additionalProperties` defined\n * as a nested schema (not just `true`/`false`) is treated as a record, even\n * if it also declares some explicit `properties`.\n * @param schema - The JSON Schema to check\n * @returns True if the schema represents a record-like type\n */\nfunction isRecordJsonSchema(schema: JSONSchema7): boolean {\n  return (\n    schema.type === \"object\" &&\n    typeof schema.additionalProperties === \"object\" &&\n    schema.additionalProperties !== null\n  );\n}\n\n/**\n * Recursively walks a JSON Schema and throws when it encounters a record type.\n * Records are not supported because they use dynamic keys which don't serialize\n * well for the Tambo backend.\n * @param schema - The JSON Schema to check\n * @param path - Current path in the schema (for error messages)\n * @param contextName - Human-readable context name for error messages\n */\nfunction assertNoRecordInJsonSchema(\n  schema: JSONSchema7,\n  path: string[],\n  contextName: string,\n): void {\n  if (isRecordJsonSchema(schema)) {\n    const joined = path.length ? path.join(\".\") : \"(root)\";\n    throw new Error(\n      `Record types (objects with dynamic keys) are not supported in ${contextName}. ` +\n        `Found at path \"${joined}\". ` +\n        \"Replace it with an object using explicit keys.\",\n    );\n  }\n  if (schema.properties) {\n    for (const [key, propSchema] of Object.entries(schema.properties)) {\n      if (typeof propSchema === \"object\" && propSchema !== null) {\n        assertNoRecordInJsonSchema(propSchema, [...path, key], contextName);\n      }\n    }\n  }\n  if (\n    typeof schema.additionalProperties === \"object\" &&\n    schema.additionalProperties !== null\n  ) {\n    assertNoRecordInJsonSchema(\n      schema.additionalProperties,\n      [...path, \"[*]\"],\n      contextName,\n    );\n  }\n  if (schema.items) {\n    if (Array.isArray(schema.items)) {\n      // Tuple (JSON Schema draft-07): check each item schema\n      schema.items.forEach((itemSchema, index) => {\n        if (typeof itemSchema === \"object\" && itemSchema !== null) {\n          assertNoRecordInJsonSchema(\n            itemSchema,\n            [...path, `${index}`],\n            contextName,\n          );\n        }\n      });\n    } else if (typeof schema.items === \"object\") {\n      // Array: check the item schema\n      assertNoRecordInJsonSchema(schema.items, [...path, \"[]\"], contextName);\n    }\n  }\n  const prefixItems = (schema as Record<string, unknown>).prefixItems;\n  if (Array.isArray(prefixItems)) {\n    prefixItems.forEach((itemSchema, index) => {\n      if (typeof itemSchema === \"object\" && itemSchema !== null) {\n        assertNoRecordInJsonSchema(\n          itemSchema as JSONSchema7,\n          [...path, `${index}`],\n          contextName,\n        );\n      }\n    });\n  }\n  if (schema.allOf) {\n    schema.allOf.forEach((subSchema, index) => {\n      if (typeof subSchema === \"object\" && subSchema !== null) {\n        assertNoRecordInJsonSchema(\n          subSchema,\n          [...path, `&${index}`],\n          contextName,\n        );\n      }\n    });\n  }\n  if (schema.anyOf) {\n    schema.anyOf.forEach((subSchema, index) => {\n      if (typeof subSchema === \"object\" && subSchema !== null) {\n        assertNoRecordInJsonSchema(\n          subSchema,\n          [...path, `|${index}`],\n          contextName,\n        );\n      }\n    });\n  }\n  if (schema.oneOf) {\n    schema.oneOf.forEach((subSchema, index) => {\n      if (typeof subSchema === \"object\" && subSchema !== null) {\n        assertNoRecordInJsonSchema(\n          subSchema,\n          [...path, `|${index}`],\n          contextName,\n        );\n      }\n    });\n  }\n  if (typeof schema.not === \"object\" && schema.not !== null) {\n    assertNoRecordInJsonSchema(schema.not, [...path, \"!\"], contextName);\n  }\n  if (typeof schema.if === \"object\" && schema.if !== null) {\n    assertNoRecordInJsonSchema(schema.if, [...path, \"if\"], contextName);\n  }\n  if (typeof schema.then === \"object\" && schema.then !== null) {\n    assertNoRecordInJsonSchema(schema.then, [...path, \"then\"], contextName);\n  }\n  if (typeof schema.else === \"object\" && schema.else !== null) {\n    assertNoRecordInJsonSchema(schema.else, [...path, \"else\"], contextName);\n  }\n}\n\n/**\n * Asserts that a schema does not contain record types (objects with dynamic keys).\n * Records are not serializable to JSON Schema in a way that the Tambo backend\n * understands, so they are disallowed.\n *\n * This function accepts Standard Schema validators (Zod, Valibot, ArkType, etc.)\n * or JSON Schema objects. It converts them to JSON Schema and checks for record patterns.\n *\n * For tool schemas that are function types, this extracts and validates the input parameters.\n * @param schema - The schema to validate (Standard Schema or JSON Schema)\n * @param contextName - A human-readable label echoed in the error message\n */\nexport function assertNoRecordSchema(\n  schema: unknown,\n  contextName = \"schema\",\n): void {\n  if (!schema) {\n    return;\n  }\n\n  let jsonSchema: JSONSchema7;\n\n  try {\n    if (isStandardSchema(schema)) {\n      // Handle function schemas specially - extract input parameters\n      const converted = schemaToJsonSchema(schema);\n\n      // If it's a function schema that couldn't be converted, the input params\n      // were extracted in registry.ts, so we can skip validation here\n      if (!converted || Object.keys(converted).length === 0) {\n        return;\n      }\n\n      jsonSchema = converted;\n    } else if (\n      typeof schema === \"object\" &&\n      schema !== null &&\n      \"type\" in schema\n    ) {\n      // Already JSON Schema\n      jsonSchema = schema as JSONSchema7;\n    } else {\n      // Unknown schema type - skip validation\n      return;\n    }\n  } catch {\n    // If schema conversion fails, skip validation\n    // This can happen for function schemas or other special types\n    return;\n  }\n\n  assertNoRecordInJsonSchema(jsonSchema, [], contextName);\n}\n"]}