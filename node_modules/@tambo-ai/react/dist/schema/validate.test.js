"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const v4_1 = require("zod/v4");
const validate_1 = require("./validate");
describe("assertNoRecordSchema", () => {
    describe("falsy inputs", () => {
        it("should return early for null", () => {
            expect(() => (0, validate_1.assertNoRecordSchema)(null)).not.toThrow();
        });
        it("should return early for undefined", () => {
            expect(() => (0, validate_1.assertNoRecordSchema)(undefined)).not.toThrow();
        });
        it("should return early for empty string", () => {
            expect(() => (0, validate_1.assertNoRecordSchema)("")).not.toThrow();
        });
        it("should return early for zero", () => {
            expect(() => (0, validate_1.assertNoRecordSchema)(0)).not.toThrow();
        });
    });
    describe("unknown schema types", () => {
        it("should skip validation for unknown object types without type property", () => {
            const unknownSchema = { foo: "bar", baz: 123 };
            expect(() => (0, validate_1.assertNoRecordSchema)(unknownSchema)).not.toThrow();
        });
        it("should skip validation for arrays", () => {
            expect(() => (0, validate_1.assertNoRecordSchema)([1, 2, 3])).not.toThrow();
        });
    });
    describe("schema conversion errors", () => {
        it("should skip validation when Standard Schema conversion fails", () => {
            // Create a mock that looks like Standard Schema but will fail conversion
            const brokenSchema = {
                "~standard": {
                    version: 1,
                    vendor: "broken-vendor",
                    validate: () => ({ value: {} }),
                },
            };
            // Should not throw, just skip validation
            expect(() => (0, validate_1.assertNoRecordSchema)(brokenSchema)).not.toThrow();
        });
    });
    describe("empty converted schemas", () => {
        it("should skip validation for function schemas that return empty JSON Schema", () => {
            // Function schemas can't be directly converted to JSON Schema
            const funcSchema = v4_1.z.function({
                input: [v4_1.z.string()],
                output: v4_1.z.void(),
            });
            // Should not throw - function schemas are handled specially
            expect(() => (0, validate_1.assertNoRecordSchema)(funcSchema)).not.toThrow();
        });
    });
    it("should allow valid schemas without records", () => {
        const schema = v4_1.z.object({
            name: v4_1.z.string(),
            age: v4_1.z.number(),
            tags: v4_1.z.array(v4_1.z.string()),
            address: v4_1.z.object({
                street: v4_1.z.string(),
                city: v4_1.z.string(),
            }),
        });
        expect(() => (0, validate_1.assertNoRecordSchema)(schema)).not.toThrow();
    });
    it("should throw when encountering a record at root level", () => {
        const schema = v4_1.z.record(v4_1.z.string(), v4_1.z.string());
        expect(() => (0, validate_1.assertNoRecordSchema)(schema)).toThrow('Record types (objects with dynamic keys) are not supported in schema. Found at path "(root)". Replace it with an object using explicit keys.');
    });
    it("should throw when encountering a nested record", () => {
        const schema = v4_1.z.object({
            name: v4_1.z.string(),
            metadata: v4_1.z.record(v4_1.z.string(), v4_1.z.string()),
        });
        expect(() => (0, validate_1.assertNoRecordSchema)(schema)).toThrow('Record types (objects with dynamic keys) are not supported in schema. Found at path "metadata". Replace it with an object using explicit keys.');
    });
    it("should throw when encountering a record in an array", () => {
        const schema = v4_1.z.object({
            items: v4_1.z.array(v4_1.z.record(v4_1.z.string(), v4_1.z.string())),
        });
        expect(() => (0, validate_1.assertNoRecordSchema)(schema)).toThrow('Record types (objects with dynamic keys) are not supported in schema. Found at path "items.[]". Replace it with an object using explicit keys.');
    });
    it("should throw when encountering a record in a union", () => {
        const schema = v4_1.z.union([v4_1.z.string(), v4_1.z.record(v4_1.z.string(), v4_1.z.number())]);
        expect(() => (0, validate_1.assertNoRecordSchema)(schema)).toThrow('Record types (objects with dynamic keys) are not supported in schema. Found at path "|1". Replace it with an object using explicit keys.');
    });
    it("should throw when encountering a record in an intersection", () => {
        const schema = v4_1.z.intersection(v4_1.z.object({ name: v4_1.z.string() }), v4_1.z.object({ metadata: v4_1.z.record(v4_1.z.string(), v4_1.z.string()) }));
        expect(() => (0, validate_1.assertNoRecordSchema)(schema)).toThrow(/Record types \(objects with dynamic keys\) are not supported in schema\. Found at path "(&1\.)?metadata"\. Replace it with an object using explicit keys\./);
    });
    it("should throw when encountering a record in a discriminated union", () => {
        const schema = v4_1.z.discriminatedUnion("type", [
            v4_1.z.object({ type: v4_1.z.literal("string"), value: v4_1.z.string() }),
            v4_1.z.object({
                type: v4_1.z.literal("record"),
                value: v4_1.z.record(v4_1.z.string(), v4_1.z.number()),
            }),
        ]);
        expect(() => (0, validate_1.assertNoRecordSchema)(schema)).toThrow(/Record types \(objects with dynamic keys\) are not supported in schema\. Found at path "\|1\.value"\. Replace it with an object using explicit keys\./);
    });
    it("should throw when encountering a record in an optional field", () => {
        const schema = v4_1.z.object({
            optional: v4_1.z.optional(v4_1.z.record(v4_1.z.string(), v4_1.z.string())),
        });
        expect(() => (0, validate_1.assertNoRecordSchema)(schema)).toThrow('Record types (objects with dynamic keys) are not supported in schema. Found at path "optional". Replace it with an object using explicit keys.');
    });
    it("should throw when encountering a record in a nullable field", () => {
        const schema = v4_1.z.object({
            nullable: v4_1.z.nullable(v4_1.z.record(v4_1.z.string(), v4_1.z.string())),
        });
        // Nullable creates a oneOf in JSON Schema, so the path includes the union index
        expect(() => (0, validate_1.assertNoRecordSchema)(schema)).toThrow(/Record types \(objects with dynamic keys\) are not supported in schema\. Found at path "nullable(\.\|0)?"\. Replace it with an object using explicit keys\./);
    });
    it("should throw when encountering a record in a tuple", () => {
        const schema = v4_1.z.tuple([v4_1.z.string(), v4_1.z.record(v4_1.z.string(), v4_1.z.number())]);
        expect(() => (0, validate_1.assertNoRecordSchema)(schema)).toThrow('Record types (objects with dynamic keys) are not supported in schema. Found at path "1". Replace it with an object using explicit keys.');
    });
    it("should use custom context name in error message", () => {
        const schema = v4_1.z.record(v4_1.z.string(), v4_1.z.string());
        expect(() => (0, validate_1.assertNoRecordSchema)(schema, "mySchema")).toThrow('Record types (objects with dynamic keys) are not supported in mySchema. Found at path "(root)". Replace it with an object using explicit keys.');
    });
    describe("JSON Schema conditional keywords", () => {
        it("should throw when encountering a record in if clause", () => {
            const jsonSchema = {
                type: "object",
                if: {
                    type: "object",
                    additionalProperties: { type: "string" },
                },
                then: {
                    properties: { name: { type: "string" } },
                },
            };
            expect(() => (0, validate_1.assertNoRecordSchema)(jsonSchema)).toThrow('Record types (objects with dynamic keys) are not supported in schema. Found at path "if". Replace it with an object using explicit keys.');
        });
        it("should throw when encountering a record in then clause", () => {
            const jsonSchema = {
                type: "object",
                if: {
                    properties: { type: { const: "map" } },
                },
                then: {
                    type: "object",
                    additionalProperties: { type: "number" },
                },
            };
            expect(() => (0, validate_1.assertNoRecordSchema)(jsonSchema)).toThrow('Record types (objects with dynamic keys) are not supported in schema. Found at path "then". Replace it with an object using explicit keys.');
        });
        it("should throw when encountering a record in else clause", () => {
            const jsonSchema = {
                type: "object",
                if: {
                    properties: { type: { const: "simple" } },
                },
                then: {
                    properties: { value: { type: "string" } },
                },
                else: {
                    type: "object",
                    additionalProperties: { type: "boolean" },
                },
            };
            expect(() => (0, validate_1.assertNoRecordSchema)(jsonSchema)).toThrow('Record types (objects with dynamic keys) are not supported in schema. Found at path "else". Replace it with an object using explicit keys.');
        });
        it("should throw when encountering a record in not clause", () => {
            const jsonSchema = {
                type: "object",
                not: {
                    type: "object",
                    additionalProperties: { type: "string" },
                },
            };
            expect(() => (0, validate_1.assertNoRecordSchema)(jsonSchema)).toThrow('Record types (objects with dynamic keys) are not supported in schema. Found at path "!". Replace it with an object using explicit keys.');
        });
        it("should throw when encountering a record in oneOf", () => {
            const jsonSchema = {
                type: "object",
                oneOf: [
                    { type: "string" },
                    {
                        type: "object",
                        additionalProperties: { type: "number" },
                    },
                ],
            };
            expect(() => (0, validate_1.assertNoRecordSchema)(jsonSchema)).toThrow('Record types (objects with dynamic keys) are not supported in schema. Found at path "|1". Replace it with an object using explicit keys.');
        });
    });
    describe("nested records in additionalProperties", () => {
        it("should throw for nested record inside additionalProperties value schema", () => {
            const jsonSchema = {
                type: "object",
                additionalProperties: {
                    type: "object",
                    properties: {
                        nested: {
                            type: "object",
                            additionalProperties: { type: "string" },
                        },
                    },
                },
            };
            // First it finds the root level record
            expect(() => (0, validate_1.assertNoRecordSchema)(jsonSchema)).toThrow('Record types (objects with dynamic keys) are not supported in schema. Found at path "(root)". Replace it with an object using explicit keys.');
        });
    });
    describe("prefixItems (JSON Schema 2020-12)", () => {
        it("should throw when encountering a record in prefixItems", () => {
            // Using JSON Schema 2020-12 style tuple
            const jsonSchema = {
                type: "array",
                prefixItems: [
                    { type: "string" },
                    {
                        type: "object",
                        additionalProperties: { type: "number" },
                    },
                ],
            };
            expect(() => (0, validate_1.assertNoRecordSchema)(jsonSchema)).toThrow('Record types (objects with dynamic keys) are not supported in schema. Found at path "1". Replace it with an object using explicit keys.');
        });
    });
    it("should handle ZodLazy schemas", () => {
        const schema = v4_1.z.lazy(() => v4_1.z.record(v4_1.z.string(), v4_1.z.string()));
        expect(() => (0, validate_1.assertNoRecordSchema)(schema)).toThrow('Record types (objects with dynamic keys) are not supported in schema. Found at path "(root)". Replace it with an object using explicit keys.');
    });
    it("should allow z.function() with valid arguments", () => {
        const schema = v4_1.z.function({
            input: [v4_1.z.string(), v4_1.z.number()],
            output: v4_1.z.string(),
        });
        // Function schemas can't be converted to JSON Schema directly,
        // so they should not throw (validation happens on the extracted parameters)
        expect(() => (0, validate_1.assertNoRecordSchema)(schema)).not.toThrow();
    });
    it("should allow JSON Schema without records", () => {
        const jsonSchema = {
            type: "object",
            properties: {
                name: { type: "string" },
                age: { type: "number" },
            },
            required: ["name"],
        };
        expect(() => (0, validate_1.assertNoRecordSchema)(jsonSchema)).not.toThrow();
    });
    it("should throw when JSON Schema has record pattern", () => {
        const jsonSchema = {
            type: "object",
            additionalProperties: { type: "string" },
        };
        expect(() => (0, validate_1.assertNoRecordSchema)(jsonSchema)).toThrow('Record types (objects with dynamic keys) are not supported in schema. Found at path "(root)". Replace it with an object using explicit keys.');
    });
    it("should treat JSON Schema with properties and additionalProperties as a record", () => {
        const jsonSchema = {
            type: "object",
            properties: {
                id: { type: "string" },
            },
            additionalProperties: { type: "number" },
        };
        expect(() => (0, validate_1.assertNoRecordSchema)(jsonSchema)).toThrow('Record types (objects with dynamic keys) are not supported in schema. Found at path "(root)". Replace it with an object using explicit keys.');
    });
    it("should throw when nested JSON Schema has record pattern", () => {
        const jsonSchema = {
            type: "object",
            properties: {
                metadata: {
                    type: "object",
                    additionalProperties: { type: "string" },
                },
            },
        };
        expect(() => (0, validate_1.assertNoRecordSchema)(jsonSchema)).toThrow('Record types (objects with dynamic keys) are not supported in schema. Found at path "metadata". Replace it with an object using explicit keys.');
    });
});
//# sourceMappingURL=validate.test.js.map