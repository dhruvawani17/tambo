{"version":3,"file":"validate.test.js","sourceRoot":"","sources":["../../src/schema/validate.test.ts"],"names":[],"mappings":"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","sourcesContent":["import type { JSONSchema7 } from \"json-schema\";\nimport { z } from \"zod/v4\";\nimport { assertNoRecordSchema } from \"./validate\";\n\ndescribe(\"assertNoRecordSchema\", () => {\n  describe(\"falsy inputs\", () => {\n    it(\"should return early for null\", () => {\n      expect(() => assertNoRecordSchema(null)).not.toThrow();\n    });\n\n    it(\"should return early for undefined\", () => {\n      expect(() => assertNoRecordSchema(undefined)).not.toThrow();\n    });\n\n    it(\"should return early for empty string\", () => {\n      expect(() => assertNoRecordSchema(\"\")).not.toThrow();\n    });\n\n    it(\"should return early for zero\", () => {\n      expect(() => assertNoRecordSchema(0)).not.toThrow();\n    });\n  });\n\n  describe(\"unknown schema types\", () => {\n    it(\"should skip validation for unknown object types without type property\", () => {\n      const unknownSchema = { foo: \"bar\", baz: 123 };\n      expect(() => assertNoRecordSchema(unknownSchema)).not.toThrow();\n    });\n\n    it(\"should skip validation for arrays\", () => {\n      expect(() => assertNoRecordSchema([1, 2, 3])).not.toThrow();\n    });\n  });\n\n  describe(\"schema conversion errors\", () => {\n    it(\"should skip validation when Standard Schema conversion fails\", () => {\n      // Create a mock that looks like Standard Schema but will fail conversion\n      const brokenSchema = {\n        \"~standard\": {\n          version: 1,\n          vendor: \"broken-vendor\",\n          validate: () => ({ value: {} }),\n        },\n      };\n\n      // Should not throw, just skip validation\n      expect(() => assertNoRecordSchema(brokenSchema)).not.toThrow();\n    });\n  });\n\n  describe(\"empty converted schemas\", () => {\n    it(\"should skip validation for function schemas that return empty JSON Schema\", () => {\n      // Function schemas can't be directly converted to JSON Schema\n      const funcSchema = z.function({\n        input: [z.string()],\n        output: z.void(),\n      });\n\n      // Should not throw - function schemas are handled specially\n      expect(() => assertNoRecordSchema(funcSchema)).not.toThrow();\n    });\n  });\n\n  it(\"should allow valid schemas without records\", () => {\n    const schema = z.object({\n      name: z.string(),\n      age: z.number(),\n      tags: z.array(z.string()),\n      address: z.object({\n        street: z.string(),\n        city: z.string(),\n      }),\n    });\n\n    expect(() => assertNoRecordSchema(schema)).not.toThrow();\n  });\n\n  it(\"should throw when encountering a record at root level\", () => {\n    const schema = z.record(z.string(), z.string());\n\n    expect(() => assertNoRecordSchema(schema)).toThrow(\n      'Record types (objects with dynamic keys) are not supported in schema. Found at path \"(root)\". Replace it with an object using explicit keys.',\n    );\n  });\n\n  it(\"should throw when encountering a nested record\", () => {\n    const schema = z.object({\n      name: z.string(),\n      metadata: z.record(z.string(), z.string()),\n    });\n\n    expect(() => assertNoRecordSchema(schema)).toThrow(\n      'Record types (objects with dynamic keys) are not supported in schema. Found at path \"metadata\". Replace it with an object using explicit keys.',\n    );\n  });\n\n  it(\"should throw when encountering a record in an array\", () => {\n    const schema = z.object({\n      items: z.array(z.record(z.string(), z.string())),\n    });\n\n    expect(() => assertNoRecordSchema(schema)).toThrow(\n      'Record types (objects with dynamic keys) are not supported in schema. Found at path \"items.[]\". Replace it with an object using explicit keys.',\n    );\n  });\n\n  it(\"should throw when encountering a record in a union\", () => {\n    const schema = z.union([z.string(), z.record(z.string(), z.number())]);\n\n    expect(() => assertNoRecordSchema(schema)).toThrow(\n      'Record types (objects with dynamic keys) are not supported in schema. Found at path \"|1\". Replace it with an object using explicit keys.',\n    );\n  });\n\n  it(\"should throw when encountering a record in an intersection\", () => {\n    const schema = z.intersection(\n      z.object({ name: z.string() }),\n      z.object({ metadata: z.record(z.string(), z.string()) }),\n    );\n\n    expect(() => assertNoRecordSchema(schema)).toThrow(\n      /Record types \\(objects with dynamic keys\\) are not supported in schema\\. Found at path \"(&1\\.)?metadata\"\\. Replace it with an object using explicit keys\\./,\n    );\n  });\n\n  it(\"should throw when encountering a record in a discriminated union\", () => {\n    const schema = z.discriminatedUnion(\"type\", [\n      z.object({ type: z.literal(\"string\"), value: z.string() }),\n      z.object({\n        type: z.literal(\"record\"),\n        value: z.record(z.string(), z.number()),\n      }),\n    ]);\n\n    expect(() => assertNoRecordSchema(schema)).toThrow(\n      /Record types \\(objects with dynamic keys\\) are not supported in schema\\. Found at path \"\\|1\\.value\"\\. Replace it with an object using explicit keys\\./,\n    );\n  });\n\n  it(\"should throw when encountering a record in an optional field\", () => {\n    const schema = z.object({\n      optional: z.optional(z.record(z.string(), z.string())),\n    });\n\n    expect(() => assertNoRecordSchema(schema)).toThrow(\n      'Record types (objects with dynamic keys) are not supported in schema. Found at path \"optional\". Replace it with an object using explicit keys.',\n    );\n  });\n\n  it(\"should throw when encountering a record in a nullable field\", () => {\n    const schema = z.object({\n      nullable: z.nullable(z.record(z.string(), z.string())),\n    });\n\n    // Nullable creates a oneOf in JSON Schema, so the path includes the union index\n    expect(() => assertNoRecordSchema(schema)).toThrow(\n      /Record types \\(objects with dynamic keys\\) are not supported in schema\\. Found at path \"nullable(\\.\\|0)?\"\\. Replace it with an object using explicit keys\\./,\n    );\n  });\n\n  it(\"should throw when encountering a record in a tuple\", () => {\n    const schema = z.tuple([z.string(), z.record(z.string(), z.number())]);\n\n    expect(() => assertNoRecordSchema(schema)).toThrow(\n      'Record types (objects with dynamic keys) are not supported in schema. Found at path \"1\". Replace it with an object using explicit keys.',\n    );\n  });\n\n  it(\"should use custom context name in error message\", () => {\n    const schema = z.record(z.string(), z.string());\n\n    expect(() => assertNoRecordSchema(schema, \"mySchema\")).toThrow(\n      'Record types (objects with dynamic keys) are not supported in mySchema. Found at path \"(root)\". Replace it with an object using explicit keys.',\n    );\n  });\n\n  describe(\"JSON Schema conditional keywords\", () => {\n    it(\"should throw when encountering a record in if clause\", () => {\n      const jsonSchema: JSONSchema7 = {\n        type: \"object\",\n        if: {\n          type: \"object\",\n          additionalProperties: { type: \"string\" },\n        },\n        then: {\n          properties: { name: { type: \"string\" } },\n        },\n      };\n\n      expect(() => assertNoRecordSchema(jsonSchema)).toThrow(\n        'Record types (objects with dynamic keys) are not supported in schema. Found at path \"if\". Replace it with an object using explicit keys.',\n      );\n    });\n\n    it(\"should throw when encountering a record in then clause\", () => {\n      const jsonSchema: JSONSchema7 = {\n        type: \"object\",\n        if: {\n          properties: { type: { const: \"map\" } },\n        },\n        then: {\n          type: \"object\",\n          additionalProperties: { type: \"number\" },\n        },\n      };\n\n      expect(() => assertNoRecordSchema(jsonSchema)).toThrow(\n        'Record types (objects with dynamic keys) are not supported in schema. Found at path \"then\". Replace it with an object using explicit keys.',\n      );\n    });\n\n    it(\"should throw when encountering a record in else clause\", () => {\n      const jsonSchema: JSONSchema7 = {\n        type: \"object\",\n        if: {\n          properties: { type: { const: \"simple\" } },\n        },\n        then: {\n          properties: { value: { type: \"string\" } },\n        },\n        else: {\n          type: \"object\",\n          additionalProperties: { type: \"boolean\" },\n        },\n      };\n\n      expect(() => assertNoRecordSchema(jsonSchema)).toThrow(\n        'Record types (objects with dynamic keys) are not supported in schema. Found at path \"else\". Replace it with an object using explicit keys.',\n      );\n    });\n\n    it(\"should throw when encountering a record in not clause\", () => {\n      const jsonSchema: JSONSchema7 = {\n        type: \"object\",\n        not: {\n          type: \"object\",\n          additionalProperties: { type: \"string\" },\n        },\n      };\n\n      expect(() => assertNoRecordSchema(jsonSchema)).toThrow(\n        'Record types (objects with dynamic keys) are not supported in schema. Found at path \"!\". Replace it with an object using explicit keys.',\n      );\n    });\n\n    it(\"should throw when encountering a record in oneOf\", () => {\n      const jsonSchema: JSONSchema7 = {\n        type: \"object\",\n        oneOf: [\n          { type: \"string\" },\n          {\n            type: \"object\",\n            additionalProperties: { type: \"number\" },\n          },\n        ],\n      };\n\n      expect(() => assertNoRecordSchema(jsonSchema)).toThrow(\n        'Record types (objects with dynamic keys) are not supported in schema. Found at path \"|1\". Replace it with an object using explicit keys.',\n      );\n    });\n  });\n\n  describe(\"nested records in additionalProperties\", () => {\n    it(\"should throw for nested record inside additionalProperties value schema\", () => {\n      const jsonSchema: JSONSchema7 = {\n        type: \"object\",\n        additionalProperties: {\n          type: \"object\",\n          properties: {\n            nested: {\n              type: \"object\",\n              additionalProperties: { type: \"string\" },\n            },\n          },\n        },\n      };\n\n      // First it finds the root level record\n      expect(() => assertNoRecordSchema(jsonSchema)).toThrow(\n        'Record types (objects with dynamic keys) are not supported in schema. Found at path \"(root)\". Replace it with an object using explicit keys.',\n      );\n    });\n  });\n\n  describe(\"prefixItems (JSON Schema 2020-12)\", () => {\n    it(\"should throw when encountering a record in prefixItems\", () => {\n      // Using JSON Schema 2020-12 style tuple\n      const jsonSchema = {\n        type: \"array\",\n        prefixItems: [\n          { type: \"string\" },\n          {\n            type: \"object\",\n            additionalProperties: { type: \"number\" },\n          },\n        ],\n      } as JSONSchema7;\n\n      expect(() => assertNoRecordSchema(jsonSchema)).toThrow(\n        'Record types (objects with dynamic keys) are not supported in schema. Found at path \"1\". Replace it with an object using explicit keys.',\n      );\n    });\n  });\n\n  it(\"should handle ZodLazy schemas\", () => {\n    const schema = z.lazy(() => z.record(z.string(), z.string()));\n\n    expect(() => assertNoRecordSchema(schema)).toThrow(\n      'Record types (objects with dynamic keys) are not supported in schema. Found at path \"(root)\". Replace it with an object using explicit keys.',\n    );\n  });\n\n  it(\"should allow z.function() with valid arguments\", () => {\n    const schema = z.function({\n      input: [z.string(), z.number()],\n      output: z.string(),\n    });\n\n    // Function schemas can't be converted to JSON Schema directly,\n    // so they should not throw (validation happens on the extracted parameters)\n    expect(() => assertNoRecordSchema(schema)).not.toThrow();\n  });\n\n  it(\"should allow JSON Schema without records\", () => {\n    const jsonSchema = {\n      type: \"object\" as const,\n      properties: {\n        name: { type: \"string\" as const },\n        age: { type: \"number\" as const },\n      },\n      required: [\"name\"],\n    };\n\n    expect(() => assertNoRecordSchema(jsonSchema)).not.toThrow();\n  });\n\n  it(\"should throw when JSON Schema has record pattern\", () => {\n    const jsonSchema = {\n      type: \"object\" as const,\n      additionalProperties: { type: \"string\" as const },\n    };\n\n    expect(() => assertNoRecordSchema(jsonSchema)).toThrow(\n      'Record types (objects with dynamic keys) are not supported in schema. Found at path \"(root)\". Replace it with an object using explicit keys.',\n    );\n  });\n\n  it(\"should treat JSON Schema with properties and additionalProperties as a record\", () => {\n    const jsonSchema = {\n      type: \"object\" as const,\n      properties: {\n        id: { type: \"string\" as const },\n      },\n      additionalProperties: { type: \"number\" as const },\n    };\n\n    expect(() => assertNoRecordSchema(jsonSchema)).toThrow(\n      'Record types (objects with dynamic keys) are not supported in schema. Found at path \"(root)\". Replace it with an object using explicit keys.',\n    );\n  });\n\n  it(\"should throw when nested JSON Schema has record pattern\", () => {\n    const jsonSchema = {\n      type: \"object\" as const,\n      properties: {\n        metadata: {\n          type: \"object\" as const,\n          additionalProperties: { type: \"string\" as const },\n        },\n      },\n    };\n\n    expect(() => assertNoRecordSchema(jsonSchema)).toThrow(\n      'Record types (objects with dynamic keys) are not supported in schema. Found at path \"metadata\". Replace it with an object using explicit keys.',\n    );\n  });\n});\n"]}