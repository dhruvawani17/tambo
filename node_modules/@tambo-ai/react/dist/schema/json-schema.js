"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.looksLikeJSONSchema = looksLikeJSONSchema;
exports.isJsonSchemaTuple = isJsonSchemaTuple;
exports.getJsonSchemaTupleItems = getJsonSchemaTupleItems;
exports.makeJsonSchemaPartial = makeJsonSchemaPartial;
const v4_1 = require("zod/v4");
const jsonSchemaType = v4_1.z.union([
    v4_1.z.literal("object"),
    v4_1.z.literal("array"),
    v4_1.z.literal("string"),
    v4_1.z.literal("number"),
    v4_1.z.literal("integer"),
    v4_1.z.literal("boolean"),
    v4_1.z.literal("null"),
    v4_1.z.array(v4_1.z.union([
        v4_1.z.literal("object"),
        v4_1.z.literal("array"),
        v4_1.z.literal("string"),
        v4_1.z.literal("number"),
        v4_1.z.literal("integer"),
        v4_1.z.literal("boolean"),
        v4_1.z.literal("null"),
    ])),
]);
const jsonSchemaTopLevel = v4_1.z
    .looseObject({
    type: jsonSchemaType.optional(),
    properties: v4_1.z.record(v4_1.z.string(), v4_1.z.unknown()).optional(),
    items: v4_1.z.union([v4_1.z.array(v4_1.z.unknown()), v4_1.z.unknown()]).optional(),
    required: v4_1.z.array(v4_1.z.string()).optional(),
    additionalProperties: v4_1.z.union([v4_1.z.boolean(), v4_1.z.unknown()]).optional(),
    enum: v4_1.z.array(v4_1.z.unknown()).optional(),
    const: v4_1.z.unknown().optional(),
    $ref: v4_1.z.string().optional(),
    $id: v4_1.z.string().optional(),
    $schema: v4_1.z.string().optional(),
    title: v4_1.z.string().optional(),
    description: v4_1.z.string().optional(),
})
    .refine((value) => {
    return (value.type !== undefined ||
        value.properties !== undefined ||
        value.items !== undefined ||
        value.enum !== undefined ||
        value.const !== undefined ||
        value.$ref !== undefined);
});
/**
 * Basic heuristic to check if an object looks like a JSON Schema at the top level.
 *
 * This uses a Zod schema to verify only top-level keys (type, properties, items,
 * etc.). It intentionally does not perform full JSON Schema validation; a more
 * thorough check should be done server-side.
 * @param obj - The value to check
 * @returns True if the value appears to be a JSON Schema
 */
function looksLikeJSONSchema(obj) {
    if (obj === null || typeof obj !== "object") {
        return false;
    }
    return jsonSchemaTopLevel.safeParse(obj).success;
}
/**
 * Checks if a JSON Schema represents a tuple (array with positional items).
 * Supports both draft-07 (items as array) and draft 2020-12 (prefixItems).
 * @param schema - The JSON Schema to check
 * @returns True if the schema represents a tuple
 */
function isJsonSchemaTuple(schema) {
    if (schema.type !== "array") {
        return false;
    }
    // Draft 2020-12: prefixItems array
    if (schema.prefixItems && Array.isArray(schema.prefixItems)) {
        return true;
    }
    // Draft-07: items as array (not object)
    if (Array.isArray(schema.items)) {
        return true;
    }
    return false;
}
/**
 * Gets the tuple items from a JSON Schema.
 * Supports both draft-07 (items as array) and draft 2020-12 (prefixItems).
 * @param schema - The JSON Schema tuple
 * @returns Array of item schemas, or undefined if not a tuple
 */
function getJsonSchemaTupleItems(schema) {
    if (schema.type !== "array") {
        return undefined;
    }
    // Draft 2020-12: prefixItems array
    if (schema.prefixItems && Array.isArray(schema.prefixItems)) {
        return schema.prefixItems;
    }
    // Draft-07: items as array
    if (Array.isArray(schema.items)) {
        return schema.items;
    }
    return undefined;
}
/**
 * Creates a partial version of a JSON Schema by removing required constraints.
 * This allows LLM to provide only the properties it wants to update.
 * @param schema - The JSON Schema to make partial
 * @returns A new JSON Schema with the required constraint removed
 */
function makeJsonSchemaPartial(schema) {
    const { required: _required, ...rest } = schema;
    return rest;
}
//# sourceMappingURL=json-schema.js.map