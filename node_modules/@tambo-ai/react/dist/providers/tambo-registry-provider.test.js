"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = require("@testing-library/react");
const react_2 = __importDefault(require("react"));
const v4_1 = require("zod/v4");
const registry_1 = require("../util/registry");
const tambo_registry_provider_1 = require("./tambo-registry-provider");
// Shared tool registry for all tests
const createMockTools = () => [
    (0, registry_1.defineTool)({
        name: "test-tool-1",
        description: "First test tool",
        tool: jest.fn().mockResolvedValue("test-tool-1-result"),
        inputSchema: v4_1.z.object({
            input: v4_1.z.string().describe("input parameter"),
        }),
        outputSchema: v4_1.z.string(),
    }),
    (0, registry_1.defineTool)({
        name: "test-tool-2",
        description: "Second test tool",
        tool: jest.fn().mockResolvedValue("test-tool-2-result"),
        inputSchema: v4_1.z.object({
            value: v4_1.z.number().describe("number parameter"),
        }),
        outputSchema: v4_1.z.string(),
    }),
];
const createMockComponents = (tools) => [
    {
        name: "TestComponent",
        component: () => react_2.default.createElement("div", null, "TestComponent"),
        description: "Test component",
        propsSchema: v4_1.z.object({
            test: v4_1.z.string(),
        }),
        associatedTools: tools,
    },
];
describe("TamboRegistryProvider", () => {
    const mockTools = createMockTools();
    const mockComponents = createMockComponents(mockTools);
    beforeEach(() => {
        jest.clearAllMocks();
    });
    describe("Component and tool registration", () => {
        it("should register components and tools correctly", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, { components: mockComponents }, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            expect(result.current.componentList).toHaveProperty("TestComponent");
            expect(result.current.toolRegistry).toHaveProperty("test-tool-1");
            expect(result.current.toolRegistry).toHaveProperty("test-tool-2");
            expect(result.current.componentToolAssociations).toHaveProperty("TestComponent");
            expect(result.current.componentToolAssociations.TestComponent).toEqual([
                "test-tool-1",
                "test-tool-2",
            ]);
        });
        it("should provide onCallUnregisteredTool in context", () => {
            const mockonCallUnregisteredTool = jest
                .fn()
                .mockResolvedValue("test-result");
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, { components: mockComponents, onCallUnregisteredTool: mockonCallUnregisteredTool }, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            // The onCallUnregisteredTool should be available in the context
            expect(result.current.onCallUnregisteredTool).toBeDefined();
            expect(typeof result.current.onCallUnregisteredTool).toBe("function");
        });
        it("should handle tool registration and association", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, null, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            // Register a new tool
            (0, react_1.act)(() => {
                result.current.registerTool(mockTools[0]);
            });
            expect(result.current.toolRegistry).toHaveProperty("test-tool-1");
            // Register a new component
            (0, react_1.act)(() => {
                result.current.registerComponent(mockComponents[0]);
            });
            expect(result.current.componentList).toHaveProperty("TestComponent");
            expect(result.current.componentToolAssociations).toHaveProperty("TestComponent");
        });
        it("should handle multiple tool registration", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, null, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            // Register multiple tools
            (0, react_1.act)(() => {
                result.current.registerTools(mockTools);
            });
            expect(result.current.toolRegistry).toHaveProperty("test-tool-1");
            expect(result.current.toolRegistry).toHaveProperty("test-tool-2");
            expect(Object.keys(result.current.toolRegistry)).toHaveLength(2);
        });
        it("should preserve maxCalls when registering a tool", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, null, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            const maxTool = {
                name: "max-tool",
                description: "Tool with maxCalls",
                tool: jest.fn().mockResolvedValue("ok"),
                inputSchema: v4_1.z.object({}),
                outputSchema: v4_1.z.object(),
                maxCalls: 4,
            };
            (0, react_1.act)(() => {
                result.current.registerTool(maxTool);
            });
            expect(result.current.toolRegistry["max-tool"].maxCalls).toBe(4);
        });
        it("should warn when overwriting an existing tool by default", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, null, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            const consoleWarnSpy = jest.spyOn(console, "warn").mockImplementation();
            // Register a tool
            (0, react_1.act)(() => {
                result.current.registerTool(mockTools[0]);
            });
            // Register the same tool again (should warn by default)
            (0, react_1.act)(() => {
                result.current.registerTool(mockTools[0]);
            });
            expect(consoleWarnSpy).toHaveBeenCalledWith(expect.stringContaining("Overwriting tool test-tool-1"));
            consoleWarnSpy.mockRestore();
        });
        it("should not warn when overwriting a tool if warnOnOverwrite is false", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, null, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            const consoleWarnSpy = jest.spyOn(console, "warn").mockImplementation();
            // Register a tool
            (0, react_1.act)(() => {
                result.current.registerTool(mockTools[0], false);
            });
            // Register the same tool again with warnOnOverwrite=false
            (0, react_1.act)(() => {
                result.current.registerTool(mockTools[0], false);
            });
            // Should not warn about "Registering new tool"
            expect(consoleWarnSpy).not.toHaveBeenCalledWith(expect.stringContaining("Overwriting tool test-tool-1"));
            consoleWarnSpy.mockRestore();
        });
        it("should handle tool association with components", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, { components: mockComponents }, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            // Add a new tool association
            const newTool = {
                name: "new-tool",
                description: "New tool",
                tool: jest.fn().mockResolvedValue("new-tool-result"),
                inputSchema: v4_1.z.object({
                    input: v4_1.z.string().describe("input"),
                }),
                outputSchema: v4_1.z.string(),
            };
            // First register the tool
            (0, react_1.act)(() => {
                result.current.registerTool(newTool);
            });
            // Then add the association
            (0, react_1.act)(() => {
                result.current.addToolAssociation("TestComponent", newTool);
            });
            expect(result.current.componentToolAssociations.TestComponent).toContain("new-tool");
        });
        it("should throw error when adding tool association to non-existent component", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, null, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            const newTool = {
                name: "new-tool",
                description: "New tool",
                tool: jest.fn().mockResolvedValue("new-tool-result"),
                inputSchema: v4_1.z.object({
                    input: v4_1.z.string().describe("input"),
                }),
                outputSchema: v4_1.z.string(),
            };
            expect(() => {
                (0, react_1.act)(() => {
                    result.current.addToolAssociation("NonExistentComponent", newTool);
                });
            }).toThrow("Component NonExistentComponent not found in registry");
        });
        it("should validate tool schemas and throw error for invalid schemas", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, null, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            const invalidTool = {
                name: "invalid-tool",
                description: "Invalid tool",
                tool: jest.fn().mockResolvedValue("result"),
                inputSchema: v4_1.z.record(v4_1.z.string(), v4_1.z.string()), // This should cause validation to fail
                outputSchema: v4_1.z.string(),
            };
            // This should throw during registration due to invalid schema
            expect(() => {
                (0, react_1.act)(() => {
                    result.current.registerTool(invalidTool);
                });
            }).toThrow('Record types (objects with dynamic keys) are not supported in inputSchema of tool "invalid-tool". Found at path "(root)". Replace it with an object using explicit keys.');
        });
        it("should validate component schemas and throw error for invalid schemas", () => {
            const invalidComponent = {
                name: "InvalidComponent",
                component: () => react_2.default.createElement("div", null, "Invalid"),
                description: "Invalid component",
                propsSchema: v4_1.z.record(v4_1.z.string(), v4_1.z.string()), // This should cause validation to fail
            };
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, null, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            // This should throw during registration due to invalid schema
            expect(() => {
                (0, react_1.act)(() => {
                    result.current.registerComponent(invalidComponent);
                });
            }).toThrow('Record types (objects with dynamic keys) are not supported in propsSchema of component "InvalidComponent"');
        });
        it("should throw error when component has both propsSchema and propsDefinition", () => {
            const invalidComponent = {
                name: "InvalidComponent",
                component: () => react_2.default.createElement("div", null, "Invalid"),
                description: "Invalid component",
                propsSchema: v4_1.z.object({ test: v4_1.z.string() }),
                propsDefinition: { test: "string" }, // Both defined - should throw
            };
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, null, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            expect(() => {
                (0, react_1.act)(() => {
                    result.current.registerComponent(invalidComponent);
                });
            }).toThrow("Component InvalidComponent cannot have both propsSchema and propsDefinition defined");
        });
        it("should throw error when component has neither propsSchema nor propsDefinition", () => {
            const invalidComponent = {
                name: "InvalidComponent",
                component: () => react_2.default.createElement("div", null, "Invalid"),
                description: "Invalid component",
                // Neither propsSchema nor propsDefinition defined - should throw
            };
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, null, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            expect(() => {
                (0, react_1.act)(() => {
                    result.current.registerComponent(invalidComponent);
                });
            }).toThrow("Component InvalidComponent must have either propsSchema (recommended) or propsDefinition defined");
        });
        it("should throw error when tool name contains spaces", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, null, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            const invalidTool = {
                name: "invalid tool name", // Contains spaces
                description: "Tool with spaces in name",
                tool: jest.fn().mockResolvedValue("result"),
                inputSchema: v4_1.z.object({
                    input: v4_1.z.string(),
                }),
                outputSchema: v4_1.z.string(),
            };
            expect(() => {
                (0, react_1.act)(() => {
                    result.current.registerTool(invalidTool);
                });
            }).toThrow('tool "invalid tool name" must only contain letters, numbers, underscores, and hyphens.');
        });
        it("should throw error when component name contains spaces", () => {
            const invalidComponent = {
                name: "Invalid Component Name", // Contains spaces
                component: () => react_2.default.createElement("div", null, "Invalid"),
                description: "Component with spaces in name",
                propsSchema: v4_1.z.object({ test: v4_1.z.string() }),
            };
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, null, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            expect(() => {
                (0, react_1.act)(() => {
                    result.current.registerComponent(invalidComponent);
                });
            }).toThrow('component "Invalid Component Name" must only contain letters, numbers, underscores, and hyphens.');
        });
    });
    describe("Tool call handling", () => {
        it("should provide onCallUnregisteredTool callback for handling unknown tools", async () => {
            const mockonCallUnregisteredTool = jest
                .fn()
                .mockResolvedValue("unknown-tool-result");
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, { components: mockComponents, onCallUnregisteredTool: mockonCallUnregisteredTool }, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            // Verify the callback is available
            expect(result.current.onCallUnregisteredTool).toBeDefined();
            expect(typeof result.current.onCallUnregisteredTool).toBe("function");
            // Simulate calling the unknown tool handler
            const toolName = "unknown-tool";
            const args = [{ parameterName: "input", parameterValue: "test-input" }];
            await (0, react_1.act)(async () => {
                if (result.current.onCallUnregisteredTool) {
                    await result.current.onCallUnregisteredTool(toolName, args);
                }
            });
            expect(mockonCallUnregisteredTool).toHaveBeenCalledWith(toolName, args);
        });
        it("should handle onCallUnregisteredTool being undefined", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, { components: mockComponents }, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            expect(result.current.onCallUnregisteredTool).toBeUndefined();
        });
    });
    describe("Resource registration", () => {
        it("should register static resources via props", () => {
            const staticResources = [
                {
                    uri: "file:///local/doc.txt",
                    name: "Local Document",
                    mimeType: "text/plain",
                },
                {
                    uri: "file:///local/image.png",
                    name: "Local Image",
                    mimeType: "image/png",
                },
            ];
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, { resources: staticResources }, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            expect(result.current.resources).toHaveLength(2);
            expect(result.current.resources[0].uri).toBe("file:///local/doc.txt");
            expect(result.current.resources[1].uri).toBe("file:///local/image.png");
        });
        it("should register resources dynamically via registerResource", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, null, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            const newResource = {
                uri: "file:///dynamic/doc.txt",
                name: "Dynamic Document",
                mimeType: "text/plain",
            };
            (0, react_1.act)(() => {
                result.current.registerResource(newResource);
            });
            expect(result.current.resources).toHaveLength(1);
            expect(result.current.resources[0].uri).toBe("file:///dynamic/doc.txt");
        });
        it("should register multiple resources via registerResources", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, null, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            const newResources = [
                {
                    uri: "file:///batch/doc1.txt",
                    name: "Batch Document 1",
                    mimeType: "text/plain",
                },
                {
                    uri: "file:///batch/doc2.txt",
                    name: "Batch Document 2",
                    mimeType: "text/plain",
                },
            ];
            (0, react_1.act)(() => {
                result.current.registerResources(newResources);
            });
            expect(result.current.resources).toHaveLength(2);
            expect(result.current.resources[0].uri).toBe("file:///batch/doc1.txt");
            expect(result.current.resources[1].uri).toBe("file:///batch/doc2.txt");
        });
        it("should register resource source via props", () => {
            const mockListResources = jest.fn().mockResolvedValue([]);
            const mockGetResource = jest.fn().mockResolvedValue({
                contents: [{ uri: "", mimeType: "text/plain", text: "" }],
            });
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, { listResources: mockListResources, getResource: mockGetResource }, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            expect(result.current.resourceSource).not.toBeNull();
            expect(result.current.resourceSource?.listResources).toBe(mockListResources);
            expect(result.current.resourceSource?.getResource).toBe(mockGetResource);
        });
        it("should register resource source via registerResourceSource", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, null, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            const mockListResources = jest.fn().mockResolvedValue([]);
            const mockGetResource = jest.fn().mockResolvedValue({
                contents: [{ uri: "", mimeType: "text/plain", text: "" }],
            });
            (0, react_1.act)(() => {
                result.current.registerResourceSource({
                    listResources: mockListResources,
                    getResource: mockGetResource,
                });
            });
            expect(result.current.resourceSource).not.toBeNull();
            expect(result.current.resourceSource?.listResources).toBe(mockListResources);
            expect(result.current.resourceSource?.getResource).toBe(mockGetResource);
        });
        it("should throw error when only listResources is provided", () => {
            const mockListResources = jest.fn().mockResolvedValue([]);
            expect(() => {
                const wrapper = ({ children }) => (react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, { listResources: mockListResources }, children));
                (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            }).toThrow("Both listResources and getResource must be provided together");
        });
        it("should throw error when only getResource is provided", () => {
            const mockGetResource = jest.fn().mockResolvedValue({
                contents: [{ uri: "", mimeType: "text/plain", text: "" }],
            });
            expect(() => {
                const wrapper = ({ children }) => (react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, { getResource: mockGetResource }, children));
                (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            }).toThrow("Both listResources and getResource must be provided together");
        });
        it("should validate resource has required uri field", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, null, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            const invalidResource = {
                name: "Document without URI",
                mimeType: "text/plain",
            };
            expect(() => {
                (0, react_1.act)(() => {
                    result.current.registerResource(invalidResource);
                });
            }).toThrow("Resource must have a 'uri' field");
        });
        it("should validate resource has required name field", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, null, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            const invalidResource = {
                uri: "file:///doc.txt",
                mimeType: "text/plain",
            };
            expect(() => {
                (0, react_1.act)(() => {
                    result.current.registerResource(invalidResource);
                });
            }).toThrow("Resource with URI 'file:///doc.txt' must have a 'name' field");
        });
    });
});
//# sourceMappingURL=tambo-registry-provider.test.js.map