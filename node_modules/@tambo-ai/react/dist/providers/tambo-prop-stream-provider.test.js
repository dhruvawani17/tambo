"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = require("@testing-library/react");
const react_2 = __importDefault(require("react"));
const use_current_message_1 = require("../hooks/use-current-message");
const generate_component_response_1 = require("../model/generate-component-response");
const tambo_thread_provider_1 = require("../providers/tambo-thread-provider");
const tambo_prop_stream_provider_1 = require("./tambo-prop-stream-provider");
// Mock the required providers
jest.mock("../providers/tambo-thread-provider", () => ({
    useTamboThread: jest.fn(),
    useTamboGenerationStage: jest.fn(),
}));
jest.mock("../hooks/use-current-message", () => ({
    useTamboCurrentMessage: jest.fn(),
}));
// Mock window for SSR tests
const originalWindow = global.window;
// Helper function to create mock ComponentDecisionV2
const createMockComponent = (props = {}) => ({
    componentName: "TestComponent",
    componentState: {},
    message: "Component generated",
    props,
    reasoning: "Test reasoning",
});
// Helper function to create mock TamboThreadMessage
const createMockMessage = (overrides = {}) => ({
    id: "test-message",
    componentState: {},
    content: [{ type: "text", text: "test content" }],
    createdAt: new Date().toISOString(),
    role: "assistant",
    threadId: "test-thread",
    ...overrides,
});
// Helper function to create mock CombinedTamboThreadContextProps
const createMockThreadContext = (overrides = {}) => {
    const mockThread = {
        id: "test-thread",
        projectId: "test-project",
        messages: [],
        name: "Test Thread",
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
    };
    return {
        // TamboThreadContextProps properties
        thread: mockThread,
        currentThreadId: mockThread.id,
        currentThread: mockThread,
        threadMap: { [mockThread.id]: mockThread },
        setThreadMap: jest.fn(),
        switchCurrentThread: jest.fn(),
        startNewThread: jest.fn(),
        updateThreadName: jest.fn(),
        generateThreadName: jest.fn(),
        addThreadMessage: jest.fn(),
        updateThreadMessage: jest.fn(),
        cancel: jest.fn(),
        streaming: false,
        sendThreadMessage: jest.fn(),
        // GenerationStageContextProps properties
        generationStage: generate_component_response_1.GenerationStage.IDLE,
        generationStatusMessage: "",
        isIdle: true,
        ...overrides,
    };
};
// Helper component to test hook usage
const TestHookComponent = ({ testKey = "default", }) => {
    const { streamStatus, getStatusForKey } = (0, tambo_prop_stream_provider_1.useTamboStream)();
    const status = getStatusForKey(testKey);
    return (react_2.default.createElement("div", null,
        react_2.default.createElement("div", { "data-testid": "stream-status" }, JSON.stringify(streamStatus)),
        react_2.default.createElement("div", { "data-testid": "key-status" }, JSON.stringify(status))));
};
describe("TamboPropStreamProvider", () => {
    beforeEach(() => {
        // Restore window for client-side tests
        global.window = originalWindow;
        // Default mock implementations
        jest.mocked(tambo_thread_provider_1.useTamboThread).mockReturnValue(createMockThreadContext());
        jest.mocked(tambo_thread_provider_1.useTamboGenerationStage).mockReturnValue({
            generationStage: generate_component_response_1.GenerationStage.IDLE,
            generationStatusMessage: "",
            isIdle: true,
        });
        jest.mocked(use_current_message_1.useTamboCurrentMessage).mockReturnValue({
            id: "test-message",
            component: {
                props: {},
            },
        });
    });
    afterEach(() => {
        jest.clearAllMocks();
    });
    describe("Hook Error Handling", () => {
        it("should throw error when useTamboStream is used outside provider", () => {
            // Suppress console.error for this test
            const originalError = console.error;
            console.error = jest.fn();
            expect(() => {
                (0, react_1.render)(react_2.default.createElement(TestHookComponent, null));
            }).toThrow("useTamboStream must be used within a TamboPropStreamProvider");
            console.error = originalError;
        });
    });
    describe("Compound Components", () => {
        describe("Streaming Component", () => {
            it("should render streaming when isPending is true", () => {
                jest.mocked(tambo_thread_provider_1.useTamboThread).mockReturnValue(createMockThreadContext({
                    generationStage: generate_component_response_1.GenerationStage.IDLE,
                }));
                jest.mocked(tambo_thread_provider_1.useTamboGenerationStage).mockReturnValue({
                    generationStage: generate_component_response_1.GenerationStage.IDLE,
                    generationStatusMessage: "",
                    isIdle: true,
                });
                jest.mocked(use_current_message_1.useTamboCurrentMessage).mockReturnValue(createMockMessage({
                    component: createMockComponent({ title: "" }),
                }));
                (0, react_1.render)(react_2.default.createElement(tambo_prop_stream_provider_1.TamboPropStreamProvider, null,
                    react_2.default.createElement(tambo_prop_stream_provider_1.TamboPropStreamProvider.Streaming, null,
                        react_2.default.createElement("div", { "data-testid": "loading" }, "Loading..."))));
                expect(react_1.screen.getByTestId("loading")).toBeInTheDocument();
            });
            it("should render streaming when isStreaming is true", () => {
                jest.mocked(tambo_thread_provider_1.useTamboThread).mockReturnValue(createMockThreadContext({
                    generationStage: generate_component_response_1.GenerationStage.STREAMING_RESPONSE,
                }));
                jest.mocked(tambo_thread_provider_1.useTamboGenerationStage).mockReturnValue({
                    generationStage: generate_component_response_1.GenerationStage.STREAMING_RESPONSE,
                    generationStatusMessage: "",
                    isIdle: false,
                });
                jest.mocked(use_current_message_1.useTamboCurrentMessage).mockReturnValue(createMockMessage({
                    component: createMockComponent({ title: "Partial" }),
                }));
                (0, react_1.render)(react_2.default.createElement(tambo_prop_stream_provider_1.TamboPropStreamProvider, null,
                    react_2.default.createElement(tambo_prop_stream_provider_1.TamboPropStreamProvider.Streaming, null,
                        react_2.default.createElement("div", { "data-testid": "loading" }, "Loading..."))));
                expect(react_1.screen.getByTestId("loading")).toBeInTheDocument();
            });
        });
        describe("Success Component", () => {
            it("should not render success when isSuccess is false", () => {
                jest.mocked(tambo_thread_provider_1.useTamboThread).mockReturnValue(createMockThreadContext({
                    generationStage: generate_component_response_1.GenerationStage.IDLE,
                }));
                jest.mocked(tambo_thread_provider_1.useTamboGenerationStage).mockReturnValue({
                    generationStage: generate_component_response_1.GenerationStage.IDLE,
                    generationStatusMessage: "",
                    isIdle: true,
                });
                jest.mocked(use_current_message_1.useTamboCurrentMessage).mockReturnValue(createMockMessage({
                    component: createMockComponent({ title: "" }),
                }));
                (0, react_1.render)(react_2.default.createElement(tambo_prop_stream_provider_1.TamboPropStreamProvider, null,
                    react_2.default.createElement(tambo_prop_stream_provider_1.TamboPropStreamProvider.Success, null,
                        react_2.default.createElement("div", { "data-testid": "complete" }, "Complete!"))));
                expect(react_1.screen.queryByTestId("complete")).not.toBeInTheDocument();
            });
        });
        describe("Pending Component", () => {
            it("should render pending when no active status", () => {
                jest.mocked(tambo_thread_provider_1.useTamboThread).mockReturnValue(createMockThreadContext({
                    generationStage: generate_component_response_1.GenerationStage.IDLE,
                }));
                jest.mocked(tambo_thread_provider_1.useTamboGenerationStage).mockReturnValue({
                    generationStage: generate_component_response_1.GenerationStage.IDLE,
                    generationStatusMessage: "",
                    isIdle: true,
                });
                jest.mocked(use_current_message_1.useTamboCurrentMessage).mockReturnValue(createMockMessage({
                    component: createMockComponent({ title: "" }),
                }));
                (0, react_1.render)(react_2.default.createElement(tambo_prop_stream_provider_1.TamboPropStreamProvider, null,
                    react_2.default.createElement(tambo_prop_stream_provider_1.TamboPropStreamProvider.Pending, null,
                        react_2.default.createElement("div", { "data-testid": "empty" }, "Empty!"))));
                expect(react_1.screen.getByTestId("empty")).toBeInTheDocument();
            });
            it("should not render pending when isPending is true", () => {
                jest.mocked(tambo_thread_provider_1.useTamboThread).mockReturnValue(createMockThreadContext({
                    generationStage: generate_component_response_1.GenerationStage.STREAMING_RESPONSE,
                }));
                jest.mocked(tambo_thread_provider_1.useTamboGenerationStage).mockReturnValue({
                    generationStage: generate_component_response_1.GenerationStage.STREAMING_RESPONSE,
                    generationStatusMessage: "",
                    isIdle: false,
                });
                jest.mocked(use_current_message_1.useTamboCurrentMessage).mockReturnValue(createMockMessage({
                    component: createMockComponent({ title: "Partial" }),
                }));
                (0, react_1.render)(react_2.default.createElement(tambo_prop_stream_provider_1.TamboPropStreamProvider, null,
                    react_2.default.createElement(tambo_prop_stream_provider_1.TamboPropStreamProvider.Pending, null,
                        react_2.default.createElement("div", { "data-testid": "empty" }, "Empty!"))));
                expect(react_1.screen.queryByTestId("empty")).not.toBeInTheDocument();
            });
        });
    });
    describe("Key-based Status", () => {
        it("should provide status for keys not in propStatus", () => {
            jest.mocked(tambo_thread_provider_1.useTamboThread).mockReturnValue(createMockThreadContext({
                generationStage: generate_component_response_1.GenerationStage.COMPLETE,
            }));
            jest.mocked(tambo_thread_provider_1.useTamboGenerationStage).mockReturnValue({
                generationStage: generate_component_response_1.GenerationStage.COMPLETE,
                generationStatusMessage: "",
                isIdle: false,
            });
            jest.mocked(use_current_message_1.useTamboCurrentMessage).mockReturnValue(createMockMessage({
                component: createMockComponent({ name: "John" }),
            }));
            (0, react_1.render)(react_2.default.createElement(tambo_prop_stream_provider_1.TamboPropStreamProvider, null,
                react_2.default.createElement(TestHookComponent, { testKey: "nonexistent" })));
            const keyStatus = JSON.parse(react_1.screen.getByTestId("key-status").textContent);
            expect(keyStatus.isPending).toBe(true);
        });
    });
    describe("Compound Components with Keys", () => {
        it("should render loading for specific key when pending", () => {
            jest.mocked(tambo_thread_provider_1.useTamboThread).mockReturnValue(createMockThreadContext({
                generationStage: generate_component_response_1.GenerationStage.STREAMING_RESPONSE,
            }));
            jest.mocked(tambo_thread_provider_1.useTamboGenerationStage).mockReturnValue({
                generationStage: generate_component_response_1.GenerationStage.STREAMING_RESPONSE,
                generationStatusMessage: "",
                isIdle: false,
            });
            jest.mocked(use_current_message_1.useTamboCurrentMessage).mockReturnValue(createMockMessage({
                component: createMockComponent({
                    name: "Partial",
                    age: 25,
                }),
            }));
            (0, react_1.render)(react_2.default.createElement(tambo_prop_stream_provider_1.TamboPropStreamProvider, null,
                react_2.default.createElement(tambo_prop_stream_provider_1.TamboPropStreamProvider.Streaming, { streamKey: "name" },
                    react_2.default.createElement("div", { "data-testid": "name-loading" }, "Name Loading...")),
                react_2.default.createElement(tambo_prop_stream_provider_1.TamboPropStreamProvider.Streaming, { streamKey: "age" },
                    react_2.default.createElement("div", { "data-testid": "age-loading" }, "Age Loading...")),
                react_2.default.createElement(tambo_prop_stream_provider_1.TamboPropStreamProvider.Success, { streamKey: "name" },
                    react_2.default.createElement("div", { "data-testid": "name-complete" }, "Name Complete!"))));
            // Both props should be loading since they're in streaming stage
            expect(react_1.screen.getByTestId("name-loading")).toBeInTheDocument();
            expect(react_1.screen.getByTestId("age-loading")).toBeInTheDocument();
            expect(react_1.screen.queryByTestId("name-complete")).not.toBeInTheDocument();
        });
    });
    describe("Styling", () => {
        it("should apply className to loading component", () => {
            jest.mocked(tambo_thread_provider_1.useTamboThread).mockReturnValue(createMockThreadContext({
                generationStage: generate_component_response_1.GenerationStage.STREAMING_RESPONSE,
            }));
            jest.mocked(tambo_thread_provider_1.useTamboGenerationStage).mockReturnValue({
                generationStage: generate_component_response_1.GenerationStage.STREAMING_RESPONSE,
                generationStatusMessage: "",
                isIdle: false,
            });
            jest.mocked(use_current_message_1.useTamboCurrentMessage).mockReturnValue(createMockMessage({
                component: createMockComponent({ title: "Partial" }),
            }));
            (0, react_1.render)(react_2.default.createElement(tambo_prop_stream_provider_1.TamboPropStreamProvider, null,
                react_2.default.createElement(tambo_prop_stream_provider_1.TamboPropStreamProvider.Streaming, { className: "loading-class" },
                    react_2.default.createElement("div", { "data-testid": "loading" }, "Loading..."))));
            const loadingElement = react_1.screen.getByTestId("loading").parentElement;
            expect(loadingElement).toHaveClass("loading-class");
        });
    });
});
//# sourceMappingURL=tambo-prop-stream-provider.test.js.map