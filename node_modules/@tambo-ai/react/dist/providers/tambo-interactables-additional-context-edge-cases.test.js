"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = require("@testing-library/react");
const react_2 = __importDefault(require("react"));
const v4_1 = require("zod/v4");
const with_tambo_interactable_1 = require("../hoc/with-tambo-interactable");
const tambo_context_helpers_provider_1 = require("./tambo-context-helpers-provider");
const tambo_interactable_provider_1 = require("./tambo-interactable-provider");
const tambo_stubs_1 = require("./tambo-stubs");
function wrapperWithProviders(children) {
    const thread = {
        id: "t-1",
        projectId: "p-1",
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        messages: [],
        metadata: {},
    };
    return (react_2.default.createElement(tambo_stubs_1.TamboStubProvider, { thread: thread, registerTool: () => { }, registerTools: () => { }, registerComponent: () => { }, addToolAssociation: () => { } },
        react_2.default.createElement(tambo_context_helpers_provider_1.TamboContextHelpersProvider, null, children)));
}
describe("Interactables AdditionalContext - Edge Cases & Advanced Scenarios", () => {
    test("handles components without propsSchema gracefully", async () => {
        const SimpleComponent = ({ text }) => (react_2.default.createElement("div", null, text));
        const InteractableSimpleComponent = (0, with_tambo_interactable_1.withTamboInteractable)(SimpleComponent, {
            componentName: "SimpleComponent",
            description: "A component without schema",
            // No propsSchema provided
        });
        let capturedContexts = [];
        const TestComponent = () => {
            const { getAdditionalContext } = (0, tambo_context_helpers_provider_1.useTamboContextHelpers)();
            react_2.default.useEffect(() => {
                let mounted = true;
                void getAdditionalContext().then((contexts) => {
                    if (mounted) {
                        capturedContexts = contexts;
                    }
                });
                return () => {
                    mounted = false;
                };
            }, [getAdditionalContext]);
            return react_2.default.createElement("div", { "data-testid": "ready" }, "ready");
        };
        const { getByTestId } = (0, react_1.render)(wrapperWithProviders(react_2.default.createElement(tambo_interactable_provider_1.TamboInteractableProvider, null,
            react_2.default.createElement(InteractableSimpleComponent, { text: "test" }),
            react_2.default.createElement(TestComponent, null))));
        await (0, react_1.waitFor)(() => {
            expect(getByTestId("ready")).toBeInTheDocument();
            const entry = capturedContexts.find((c) => c.name === "interactables");
            expect(entry).toBeDefined();
            const component = entry.context.components[0];
            expect(component.propsSchema).toBe("Not specified");
        });
    });
    test("handles component unmounting and remounting correctly", async () => {
        const Note = ({ title }) => react_2.default.createElement("div", null, title);
        const InteractableNote = (0, with_tambo_interactable_1.withTamboInteractable)(Note, {
            componentName: "Note",
            description: "A note",
            propsSchema: v4_1.z.object({ title: v4_1.z.string() }),
        });
        let capturedContexts = [];
        const TestComponent = () => {
            const { getAdditionalContext } = (0, tambo_context_helpers_provider_1.useTamboContextHelpers)();
            react_2.default.useEffect(() => {
                let mounted = true;
                const interval = setInterval(() => {
                    void getAdditionalContext().then((contexts) => {
                        if (mounted) {
                            capturedContexts = contexts;
                        }
                    });
                }, 50);
                return () => {
                    mounted = false;
                    clearInterval(interval);
                };
            }, [getAdditionalContext]);
            return react_2.default.createElement("div", { "data-testid": "ready" }, "ready");
        };
        const Host = () => {
            const [showNote, setShowNote] = react_2.default.useState(true);
            react_2.default.useEffect(() => {
                // Toggle the note on/off to test unmounting
                const timeout = setTimeout(() => setShowNote(false), 100);
                const timeout2 = setTimeout(() => setShowNote(true), 200);
                return () => {
                    clearTimeout(timeout);
                    clearTimeout(timeout2);
                };
            }, []);
            return (react_2.default.createElement(tambo_interactable_provider_1.TamboInteractableProvider, null,
                showNote && react_2.default.createElement(InteractableNote, { title: "dynamic note" }),
                react_2.default.createElement(TestComponent, null)));
        };
        const { getByTestId } = (0, react_1.render)(wrapperWithProviders(react_2.default.createElement(Host, null)));
        await (0, react_1.waitFor)(() => {
            expect(getByTestId("ready")).toBeInTheDocument();
        }, { timeout: 1000 });
        // Eventually should show the note again
        await (0, react_1.waitFor)(() => {
            const entry = capturedContexts.find((c) => c.name === "interactables");
            expect(entry?.context?.components).toHaveLength(1);
        }, { timeout: 1000 });
    });
    test("context helper updates when props change from parent", async () => {
        const Counter = ({ count, label = "Count", }) => (react_2.default.createElement("div", null,
            label,
            ": ",
            count));
        const InteractableCounter = (0, with_tambo_interactable_1.withTamboInteractable)(Counter, {
            componentName: "Counter",
            description: "A counter component",
            propsSchema: v4_1.z.object({
                count: v4_1.z.number(),
                label: v4_1.z.string().optional(),
            }),
        });
        let capturedContexts = [];
        const TestComponent = () => {
            const { getAdditionalContext } = (0, tambo_context_helpers_provider_1.useTamboContextHelpers)();
            react_2.default.useEffect(() => {
                let mounted = true;
                const interval = setInterval(() => {
                    void getAdditionalContext().then((contexts) => {
                        if (mounted) {
                            capturedContexts = contexts;
                        }
                    });
                }, 50);
                return () => {
                    mounted = false;
                    clearInterval(interval);
                };
            }, [getAdditionalContext]);
            return react_2.default.createElement("div", { "data-testid": "ready" }, "ready");
        };
        const Host = () => {
            const [count, setCount] = react_2.default.useState(0);
            const [label, setLabel] = react_2.default.useState("Items");
            react_2.default.useEffect(() => {
                const timeout1 = setTimeout(() => setCount(5), 100);
                const timeout2 = setTimeout(() => setLabel("Updated Items"), 200);
                return () => {
                    clearTimeout(timeout1);
                    clearTimeout(timeout2);
                };
            }, []);
            return (react_2.default.createElement(tambo_interactable_provider_1.TamboInteractableProvider, null,
                react_2.default.createElement(InteractableCounter, { count: count, label: label }),
                react_2.default.createElement(TestComponent, null)));
        };
        const { getByTestId } = (0, react_1.render)(wrapperWithProviders(react_2.default.createElement(Host, null)));
        await (0, react_1.waitFor)(() => {
            expect(getByTestId("ready")).toBeInTheDocument();
        });
        // Wait for updates to propagate
        await (0, react_1.waitFor)(() => {
            const entry = capturedContexts.find((c) => c.name === "interactables");
            if (entry?.context?.components?.[0]) {
                const props = entry.context.components[0].props;
                expect(props.count).toBe(5);
                expect(props.label).toBe("Updated Items");
            }
        }, { timeout: 1000 });
    });
    test("multiple providers with nested context helpers work correctly", async () => {
        const Note = ({ title }) => react_2.default.createElement("div", null, title);
        const InteractableNote = (0, with_tambo_interactable_1.withTamboInteractable)(Note, {
            componentName: "Note",
            description: "A note",
            propsSchema: v4_1.z.object({ title: v4_1.z.string() }),
        });
        let outerContexts = [];
        let innerContexts = [];
        const OuterTestComponent = () => {
            const { getAdditionalContext } = (0, tambo_context_helpers_provider_1.useTamboContextHelpers)();
            react_2.default.useEffect(() => {
                let mounted = true;
                void getAdditionalContext().then((contexts) => {
                    if (mounted) {
                        outerContexts = contexts;
                    }
                });
                return () => {
                    mounted = false;
                };
            }, [getAdditionalContext]);
            return react_2.default.createElement("div", { "data-testid": "outer-ready" }, "outer ready");
        };
        const InnerTestComponent = () => {
            const { getAdditionalContext } = (0, tambo_context_helpers_provider_1.useTamboContextHelpers)();
            react_2.default.useEffect(() => {
                let mounted = true;
                void getAdditionalContext().then((contexts) => {
                    if (mounted) {
                        innerContexts = contexts;
                    }
                });
                return () => {
                    mounted = false;
                };
            }, [getAdditionalContext]);
            return react_2.default.createElement("div", { "data-testid": "inner-ready" }, "inner ready");
        };
        const { getByTestId } = (0, react_1.render)(wrapperWithProviders(react_2.default.createElement(tambo_interactable_provider_1.TamboInteractableProvider, null,
            react_2.default.createElement(InteractableNote, { title: "outer note" }),
            react_2.default.createElement(OuterTestComponent, null),
            react_2.default.createElement(tambo_context_helpers_provider_1.TamboContextHelpersProvider, { contextHelpers: {
                    customContext: () => ({ custom: "inner" }),
                } },
                react_2.default.createElement(tambo_interactable_provider_1.TamboInteractableProvider, null,
                    react_2.default.createElement(InteractableNote, { title: "inner note" }),
                    react_2.default.createElement(InnerTestComponent, null))))));
        await (0, react_1.waitFor)(() => {
            expect(getByTestId("outer-ready")).toBeInTheDocument();
            expect(getByTestId("inner-ready")).toBeInTheDocument();
        });
        await (0, react_1.waitFor)(() => {
            // Outer context should have outer note
            const outerEntry = outerContexts.find((c) => c.name === "interactables");
            expect(outerEntry?.context?.components).toHaveLength(1);
            expect(outerEntry?.context?.components[0]?.props?.title).toBe("outer note");
            // Inner context should have inner note and custom context
            const innerEntry = innerContexts.find((c) => c.name === "interactables");
            expect(innerEntry?.context?.components).toHaveLength(1);
            expect(innerEntry?.context?.components[0]?.props?.title).toBe("inner note");
            const customEntry = innerContexts.find((c) => c.name === "customContext");
            expect(customEntry?.context).toEqual({ custom: "inner" });
        });
    });
    test("provider cleanup removes helper when last provider unmounts", async () => {
        const Note = ({ title }) => react_2.default.createElement("div", null, title);
        const InteractableNote = (0, with_tambo_interactable_1.withTamboInteractable)(Note, {
            componentName: "Note",
            description: "A note",
            propsSchema: v4_1.z.object({ title: v4_1.z.string() }),
        });
        let capturedContexts = [];
        const TestComponent = () => {
            const { getAdditionalContext } = (0, tambo_context_helpers_provider_1.useTamboContextHelpers)();
            react_2.default.useEffect(() => {
                let mounted = true;
                const interval = setInterval(() => {
                    void getAdditionalContext().then((contexts) => {
                        if (mounted) {
                            capturedContexts = contexts;
                        }
                    });
                }, 50);
                return () => {
                    mounted = false;
                    clearInterval(interval);
                };
            }, [getAdditionalContext]);
            return react_2.default.createElement("div", { "data-testid": "ready" }, "ready");
        };
        const Host = () => {
            const [showProvider, setShowProvider] = react_2.default.useState(true);
            react_2.default.useEffect(() => {
                const timeout = setTimeout(() => setShowProvider(false), 200);
                return () => clearTimeout(timeout);
            }, []);
            return (react_2.default.createElement(react_2.default.Fragment, null,
                showProvider && (react_2.default.createElement(tambo_interactable_provider_1.TamboInteractableProvider, null,
                    react_2.default.createElement(InteractableNote, { title: "will disappear" }))),
                react_2.default.createElement(TestComponent, null)));
        };
        const { getByTestId } = (0, react_1.render)(wrapperWithProviders(react_2.default.createElement(Host, null)));
        // Initially should have the context
        await (0, react_1.waitFor)(() => {
            expect(getByTestId("ready")).toBeInTheDocument();
            const entry = capturedContexts.find((c) => c.name === "interactables");
            expect(entry).toBeDefined();
        });
        // After provider unmounts, context should be gone
        await (0, react_1.waitFor)(() => {
            const entry = capturedContexts.find((c) => c.name === "interactables");
            expect(entry).toBeUndefined();
        }, { timeout: 1000 });
    });
    test("helper error handling doesn't crash the system", async () => {
        const Note = ({ title }) => react_2.default.createElement("div", null, title);
        const InteractableNote = (0, with_tambo_interactable_1.withTamboInteractable)(Note, {
            componentName: "Note",
            description: "A note",
            propsSchema: v4_1.z.object({ title: v4_1.z.string() }),
        });
        // Mock console.error to capture error logs
        const consoleSpy = jest
            .spyOn(console, "error")
            .mockImplementation(() => { });
        let capturedContexts = [];
        const TestComponent = () => {
            const { getAdditionalContext, addContextHelper } = (0, tambo_context_helpers_provider_1.useTamboContextHelpers)();
            react_2.default.useEffect(() => {
                // Add a helper that throws an error
                addContextHelper("errorHelper", () => {
                    throw new Error("Test error in helper");
                });
            }, [addContextHelper]);
            react_2.default.useEffect(() => {
                let mounted = true;
                getAdditionalContext()
                    .then((contexts) => {
                    if (mounted) {
                        capturedContexts = contexts;
                    }
                })
                    .catch(() => {
                    // Should not reach here - errors should be handled gracefully
                });
                return () => {
                    mounted = false;
                };
            }, [getAdditionalContext]);
            return react_2.default.createElement("div", { "data-testid": "ready" }, "ready");
        };
        const { getByTestId } = (0, react_1.render)(wrapperWithProviders(react_2.default.createElement(tambo_interactable_provider_1.TamboInteractableProvider, null,
            react_2.default.createElement(InteractableNote, { title: "test" }),
            react_2.default.createElement(TestComponent, null))));
        await (0, react_1.waitFor)(() => {
            expect(getByTestId("ready")).toBeInTheDocument();
            // Should still have the interactables context despite the error
            const entry = capturedContexts.find((c) => c.name === "interactables");
            expect(entry).toBeDefined();
            // Error helper should not be present (filtered out)
            const errorEntry = capturedContexts.find((c) => c.name === "errorHelper");
            expect(errorEntry).toBeUndefined();
        });
        consoleSpy.mockRestore();
    });
});
//# sourceMappingURL=tambo-interactables-additional-context-edge-cases.test.js.map