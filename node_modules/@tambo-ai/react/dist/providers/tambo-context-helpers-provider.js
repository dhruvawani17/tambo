"use strict";
"use client";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.useTamboContextHelpers = exports.TamboContextHelpersProvider = void 0;
const react_1 = __importStar(require("react"));
const registry_1 = require("../context-helpers/registry");
const TamboContextHelpersContext = (0, react_1.createContext)(null);
/**
 * Provider for managing additional context helpers.
 * Accepts a map of { key: () => any | null | undefined | Promise<any | null | undefined> }.
 * Returning null/undefined skips inclusion; returned values are wrapped as { name: key, context: value }.
 * @param props - The props for the TamboContextHelpersProvider.
 * @param props.contextHelpers - A dictionary of context helper functions keyed by context name.
 * @param props.children - The children to render.
 * @returns The provider that exposes context helper APIs via useTamboContextHelpers.
 */
const TamboContextHelpersProvider = ({ children, contextHelpers }) => {
    const [helpers, setHelpers] = (0, react_1.useState)({});
    const addContextHelper = (0, react_1.useCallback)((name, fn) => {
        setHelpers((prev) => ({ ...prev, [name]: fn }));
    }, []);
    const removeContextHelper = (0, react_1.useCallback)((name, fn) => {
        setHelpers((prev) => {
            const { [name]: registeredFn, ...rest } = prev;
            if (fn === undefined || registeredFn === fn) {
                return rest;
            }
            return prev;
        });
    }, []);
    // Hydrate the global registry with initial helpers (runs on prop changes)
    (0, react_1.useEffect)(() => {
        const addedEntries = [];
        if (contextHelpers) {
            for (const [name, fn] of Object.entries(contextHelpers)) {
                addContextHelper(name, fn);
                addedEntries.push([name, fn]);
            }
        }
        return () => {
            for (const [name, fn] of addedEntries) {
                // Only remove if the registry still points to the same function
                removeContextHelper(name, fn);
            }
        };
    }, [addContextHelper, contextHelpers, removeContextHelper]);
    const getAdditionalContext = (0, react_1.useCallback)(async () => {
        const contexts = await (0, registry_1.resolveAdditionalContext)(helpers);
        return contexts;
    }, [helpers]);
    const getContextHelpers = (0, react_1.useCallback)(() => {
        return helpers;
    }, [helpers]);
    const value = (0, react_1.useMemo)(() => ({
        getAdditionalContext,
        getContextHelpers,
        addContextHelper,
        removeContextHelper,
    }), [
        getAdditionalContext,
        getContextHelpers,
        addContextHelper,
        removeContextHelper,
    ]);
    return (react_1.default.createElement(TamboContextHelpersContext.Provider, { value: value }, children));
};
exports.TamboContextHelpersProvider = TamboContextHelpersProvider;
/**
 * Hook to access context helpers functionality.
 *
 * Behavior without a provider: this hook does NOT throw immediately. If it is
 * called outside of a `TamboContextHelpersProvider`, it returns a fallback
 * object whose methods will throw when invoked. This "lazy-throw" pattern is
 * intentional so the error surfaces at the actual point of use.
 * @returns The context helpers API when a provider is present; otherwise, a
 * fallback object whose methods throw if called.
 */
const useTamboContextHelpers = () => {
    const context = (0, react_1.useContext)(TamboContextHelpersContext);
    if (context)
        return context;
    // No provider present: return methods that throw with a helpful error when used
    return {
        getAdditionalContext: async () => {
            throw new Error("useTamboContextHelpers must be used within a TamboContextHelpersProvider");
        },
        getContextHelpers: () => {
            throw new Error("useTamboContextHelpers must be used within a TamboContextHelpersProvider");
        },
        addContextHelper: (_name, _helper) => {
            throw new Error("useTamboContextHelpers must be used within a TamboContextHelpersProvider");
        },
        removeContextHelper: (_name) => {
            throw new Error("useTamboContextHelpers must be used within a TamboContextHelpersProvider");
        },
    };
};
exports.useTamboContextHelpers = useTamboContextHelpers;
//# sourceMappingURL=tambo-context-helpers-provider.js.map