{"version":3,"file":"tambo-thread-provider.js","sourceRoot":"","sources":["../../src/providers/tambo-thread-provider.tsx"],"names":[],"mappings":"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","sourcesContent":["\"use client\";\nimport TamboAI, { advanceStream } from \"@tambo-ai/typescript-sdk\";\nimport { Thread } from \"@tambo-ai/typescript-sdk/resources/beta/threads/threads\";\nimport React, {\n  createContext,\n  PropsWithChildren,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport { TamboTool } from \"../model/component-metadata\";\nimport {\n  GenerationStage,\n  isIdleStage,\n  TamboThreadMessage,\n} from \"../model/generate-component-response\";\nimport { TamboThread } from \"../model/tambo-thread\";\nimport { toText } from \"../util/content-parts\";\nimport { renderComponentIntoMessage } from \"../util/generate-component\";\nimport {\n  getAvailableComponents,\n  getUnassociatedTools,\n  mapTamboToolToContextTool,\n} from \"../util/registry\";\nimport { handleToolCall } from \"../util/tool-caller\";\nimport { useTamboClient, useTamboQueryClient } from \"./tambo-client-provider\";\nimport { useTamboContextHelpers } from \"./tambo-context-helpers-provider\";\nimport { useTamboRegistry } from \"./tambo-registry-provider\";\n\n// Generation Stage Context - separate from thread context to prevent re-renders\nexport interface TamboGenerationStageContextProps {\n  generationStage: GenerationStage;\n  generationStatusMessage: string;\n  isIdle: boolean;\n}\n\nconst TamboGenerationStageContext = createContext<\n  TamboGenerationStageContextProps | undefined\n>(undefined);\n\ninterface TamboGenerationStageProviderProps {\n  generationStage: GenerationStage;\n  statusMessage: string;\n}\n\n/**\n *\n * This provider is used to provide the generation stage context to the descendants of the provider.\n * @param props - The props for the GenerationStageProvider\n * @param props.children - The children to wrap\n * @param props.generationStage - The generation stage to provide\n * @param props.statusMessage - The status message to provide\n * @returns The GenerationStageProvider component\n */\nexport const TamboGenerationStageProvider: React.FC<\n  PropsWithChildren<TamboGenerationStageProviderProps>\n> = ({ children, generationStage, statusMessage }) => {\n  const isIdle = isIdleStage(generationStage);\n\n  const contextValue = useMemo(() => {\n    return {\n      generationStage,\n      generationStatusMessage: statusMessage,\n      isIdle,\n    };\n  }, [generationStage, statusMessage, isIdle]);\n\n  return (\n    <TamboGenerationStageContext.Provider value={contextValue}>\n      {children}\n    </TamboGenerationStageContext.Provider>\n  );\n};\n\n// Type for partial message updates that requires threadId\ntype PartialTamboThreadMessageWithThreadId = Partial<TamboThreadMessage> & {\n  threadId: string;\n};\n\nexport interface TamboThreadContextProps {\n  /** The current thread */\n  thread: TamboThread;\n  /** The current thread ID */\n  currentThreadId: string | null;\n  /** The current thread (alias for thread, may be null) */\n  currentThread: TamboThread | null;\n  /** Map of all threads by ID */\n  threadMap: Record<string, TamboThread>;\n  /** Update the thread map (internal use only) */\n  setThreadMap: React.Dispatch<\n    React.SetStateAction<Record<string, TamboThread>>\n  >;\n  /** Switch to a different thread */\n  switchCurrentThread: (threadId: string, fetch?: boolean) => void;\n  /** Start a new thread */\n  startNewThread: () => void;\n  /** Update a thread's name */\n  updateThreadName: (name: string, threadId?: string) => void;\n  /** Let Tambo generate and set a thread's name based on the thread's messages */\n  generateThreadName: (threadId?: string) => Promise<Thread>;\n  /** Add a message to the current thread */\n  addThreadMessage: (\n    message: TamboThreadMessage,\n    sendToServer: boolean,\n  ) => Promise<TamboAI.Beta.Threads.ThreadMessage[]>;\n  /** Update a message in the current thread */\n  updateThreadMessage: (\n    id: string,\n    message: PartialTamboThreadMessageWithThreadId,\n    sendToServer: boolean,\n  ) => Promise<void>;\n  /** Cancel a thread */\n  cancel: (threadId?: string) => Promise<void>;\n  /** Whether the thread is streaming */\n  streaming: boolean;\n  /** Send a message to the current thread */\n  sendThreadMessage: (\n    message: string,\n    options?: {\n      threadId?: string;\n      streamResponse?: boolean;\n      contextKey?: string;\n      forceToolChoice?: string;\n      additionalContext?: Record<string, any>;\n      content?: TamboAI.Beta.Threads.ChatCompletionContentPart[];\n    },\n  ) => Promise<TamboThreadMessage>;\n  /** The context key to use for the thread */\n  contextKey?: string;\n}\n\n// Combined context interface that includes generation stage fields\nexport interface CombinedTamboThreadContextProps\n  extends TamboThreadContextProps, TamboGenerationStageContextProps {}\n\n/**\n * This is a stub entry for when the thread is not yet created, the first time\n * the user sends a message\n *\n * Note that the consumer needs to be careful never to send `PLACEHOLDER_THREAD.id` to the server,\n * as this doesn't really exist on the server side.\n */\nexport const PLACEHOLDER_THREAD: TamboThread = {\n  id: \"placeholder\",\n  messages: [],\n  createdAt: \"\",\n  projectId: \"\",\n  updatedAt: \"\",\n  metadata: {},\n};\n\nexport const TamboThreadContext = createContext<TamboThreadContextProps>({\n  thread: PLACEHOLDER_THREAD,\n  currentThreadId: PLACEHOLDER_THREAD.id,\n  currentThread: PLACEHOLDER_THREAD,\n  threadMap: { [PLACEHOLDER_THREAD.id]: PLACEHOLDER_THREAD },\n  setThreadMap: () => {\n    throw new Error(\"setThreadMap not implemented\");\n  },\n  /**\n   *\n   */\n  switchCurrentThread: () => {\n    throw new Error(\"switchCurrentThread not implemented\");\n  },\n  /**\n   *\n   */\n  startNewThread: () => {\n    throw new Error(\"startNewThread not implemented\");\n  },\n  /**\n   *\n   */\n  updateThreadName: () => {\n    throw new Error(\"updateThreadName not implemented\");\n  },\n  /**\n   *\n   */\n  generateThreadName: () => {\n    throw new Error(\"generateThreadName not implemented\");\n  },\n  /**\n   *\n   */\n  addThreadMessage: () => {\n    throw new Error(\"updateThreadMessageHistory not implemented\");\n  },\n  streaming: true,\n  /**\n   *\n   */\n  updateThreadMessage: () => {\n    throw new Error(\"updateThreadMessage not implemented\");\n  },\n  /**\n   *\n   */\n  sendThreadMessage: () => {\n    throw new Error(\"sendThreadMessage not implemented\");\n  },\n  /**\n   *\n   */\n  cancel: () => {\n    throw new Error(\"cancel not implemented\");\n  },\n});\n\nexport type InitialTamboThreadMessage = Pick<\n  TamboThreadMessage,\n  \"role\" | \"content\"\n> & {\n  /** Optional ID - will be auto-generated if not provided */\n  id?: string;\n  /** Optional creation timestamp - will be auto-generated if not provided */\n  createdAt?: string;\n  /** Optional additional context to include with the message */\n  additionalContext?: Record<string, any>;\n  /** Optional component state - will default to empty object if not provided */\n  componentState?: Record<string, any>;\n};\n\nexport interface TamboThreadProviderProps {\n  /** Whether to stream the response */\n  streaming?: boolean;\n  /** Initial messages to be included in new threads */\n  initialMessages?: InitialTamboThreadMessage[];\n  /** Whether to automatically generate thread names. Defaults to true. */\n  autoGenerateThreadName?: boolean;\n  /** The message count threshold at which the thread name will be auto-generated. Defaults to 3. */\n  autoGenerateNameThreshold?: number;\n  /** The context key to use for the thread */\n  contextKey?: string;\n}\n\n/**\n * The TamboThreadProvider is a React provider that provides a thread context\n * to the descendants of the provider.\n * @param props - The props for the TamboThreadProvider\n * @param props.children - The children to wrap\n * @param props.streaming - Whether to stream the response by default. Defaults to true.\n * @param props.initialMessages - Initial messages to be included in new threads\n * @param props.autoGenerateThreadName - Whether to automatically generate thread names. Defaults to true.\n * @param props.autoGenerateNameThreshold - The message count threshold at which the thread name will be auto-generated. Defaults to 3.\n * @param props.contextKey - The context key to use for thread isolation\n * @returns The TamboThreadProvider component\n */\nexport const TamboThreadProvider: React.FC<\n  PropsWithChildren<TamboThreadProviderProps>\n> = ({\n  children,\n  streaming = true,\n  initialMessages = [],\n  autoGenerateThreadName = true,\n  autoGenerateNameThreshold = 3,\n  contextKey,\n}) => {\n  // Create placeholder thread with initial messages\n  const placeholderThread: TamboThread = useMemo(\n    () => ({\n      id: \"placeholder\",\n      messages: initialMessages.map((msg) => ({\n        ...msg,\n        id: msg.id ?? crypto.randomUUID(),\n        threadId: \"placeholder\",\n        createdAt: msg.createdAt ?? new Date().toISOString(),\n        componentState: msg.componentState ?? {},\n      })),\n      createdAt: \"\",\n      projectId: \"\",\n      updatedAt: \"\",\n      metadata: {},\n      contextKey,\n    }),\n    [contextKey, initialMessages],\n  );\n\n  const [threadMap, setThreadMap] = useState<Record<string, TamboThread>>({\n    [placeholderThread.id]: placeholderThread,\n  });\n  const client = useTamboClient();\n  const queryClient = useTamboQueryClient();\n  const {\n    componentList,\n    toolRegistry,\n    componentToolAssociations,\n    onCallUnregisteredTool,\n  } = useTamboRegistry();\n  const { getAdditionalContext } = useTamboContextHelpers();\n  const [ignoreResponse, setIgnoreResponse] = useState(false);\n  const ignoreResponseRef = useRef(ignoreResponse);\n  const [currentThreadId, setCurrentThreadId] = useState<string>(\n    placeholderThread.id,\n  );\n  const currentThread: TamboThread | undefined = threadMap[currentThreadId];\n\n  // Generation stage props for GenerationStageProvider\n  const currentGenerationStage =\n    (currentThread?.generationStage as GenerationStage) ?? GenerationStage.IDLE;\n  const currentStatusMessage = currentThread?.statusMessage ?? \"\";\n\n  // Use existing messages from the current thread to avoid re-generating any components\n  const currentMessageCache = useMemo(() => {\n    const messageCache = new Map<string, TamboThreadMessage>();\n    if (currentThread) {\n      for (const message of currentThread.messages) {\n        messageCache.set(message.id, message);\n      }\n    }\n    return messageCache;\n  }, [currentThread]);\n\n  useEffect(() => {\n    ignoreResponseRef.current = ignoreResponse;\n  }, [ignoreResponse]);\n\n  const updateThreadsCache = useCallback(\n    async (\n      updateFn: (\n        old: TamboAI.Beta.Threads.ThreadsOffsetAndLimit | undefined,\n      ) => TamboAI.Beta.Threads.ThreadsOffsetAndLimit | undefined,\n      contextKey?: string,\n    ) => {\n      try {\n        const currentProject = await client.beta.projects.getCurrent();\n\n        queryClient.setQueryData(\n          [\"threads\", currentProject.id, contextKey],\n          updateFn,\n        );\n\n        await queryClient.invalidateQueries({\n          queryKey: [\"threads\"],\n        });\n      } catch (error) {\n        console.warn(\"Failed to update threads cache:\", error);\n      }\n    },\n    [client.beta.projects, queryClient],\n  );\n\n  const addThreadToCache = useCallback(\n    async (threadId: string, contextKey: string | undefined) => {\n      const optimisticThread = {\n        ...PLACEHOLDER_THREAD,\n        id: threadId,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n      };\n\n      await updateThreadsCache((old) => {\n        if (!old) return old;\n        return {\n          ...old,\n          items: [optimisticThread, ...(old.items ?? [])],\n          total: (old.total ?? 0) + 1,\n          count: (old.count ?? 0) + 1,\n        } as TamboAI.Beta.Threads.ThreadsOffsetAndLimit;\n      }, contextKey);\n    },\n    [updateThreadsCache],\n  );\n\n  const updateThreadInCache = useCallback(\n    async (\n      threadId: string,\n      updateFn: (\n        thread: TamboAI.Beta.Threads.Thread,\n      ) => TamboAI.Beta.Threads.Thread,\n      contextKey?: string,\n    ) => {\n      await updateThreadsCache((old) => {\n        if (!old?.items) return old;\n        return {\n          ...old,\n          items: old.items.map((thread) =>\n            thread.id === threadId ? updateFn(thread) : thread,\n          ),\n          total: old.total,\n          count: old.count,\n        } as TamboAI.Beta.Threads.ThreadsOffsetAndLimit;\n      }, contextKey);\n    },\n    [updateThreadsCache],\n  );\n\n  const fetchThread = useCallback(\n    async (threadId: string) => {\n      const thread = await client.beta.threads.retrieve(threadId);\n      const threadWithRenderedComponents = {\n        ...thread,\n        messages: thread.messages.map((message) => {\n          if (currentMessageCache.has(message.id)) {\n            const renderedMessage = currentMessageCache.get(message.id);\n            return {\n              ...renderedMessage,\n              ...message,\n            };\n          }\n          if (message.component?.componentName) {\n            const messageWithComponent = renderComponentIntoMessage(\n              message,\n              componentList,\n            );\n            return messageWithComponent;\n          }\n          return message;\n        }),\n      };\n\n      setThreadMap((prevMap) => {\n        const updatedThreadMap = {\n          ...prevMap,\n          [threadId]: threadWithRenderedComponents,\n        };\n        return updatedThreadMap;\n      });\n    },\n    [client.beta.threads, componentList, currentMessageCache],\n  );\n\n  useEffect(() => {\n    async function loadThread() {\n      try {\n        await fetchThread(currentThreadId);\n      } catch (error) {\n        console.error(\"Failed to fetch thread:\", error);\n      }\n    }\n\n    if (\n      currentThreadId &&\n      currentThreadId !== placeholderThread.id &&\n      !threadMap[currentThreadId]\n    ) {\n      loadThread().catch((err) => {\n        console.error(\"Unexpected error in loadThread:\", err);\n      });\n    }\n  }, [currentThreadId, fetchThread, threadMap, placeholderThread.id]);\n\n  const addThreadMessage = useCallback(\n    async (\n      message: TamboThreadMessage,\n      sendToServer = true,\n      createdAt: string = new Date().toISOString(),\n    ) => {\n      if (!currentThread) {\n        console.warn(\"Cannot add messages if we do not have a current thread\");\n        return [];\n      }\n\n      const chatMessage: TamboThreadMessage = {\n        ...message,\n        createdAt,\n      };\n      const threadId = message.threadId;\n      const messageId = chatMessage.id;\n      // optimistically update the thread in the local state\n      setThreadMap((prevMap) => {\n        if (!threadId) {\n          return prevMap;\n        }\n        const prevMessages = prevMap[threadId]?.messages || [];\n        const haveMessage = prevMessages.find((msg) => msg.id === messageId);\n        // Update in place if the message already exists\n        const updatedMessages = haveMessage\n          ? prevMessages.map((msg) => {\n              if (msg.id === messageId) {\n                return chatMessage;\n              }\n              return msg;\n            })\n          : [...prevMessages, chatMessage];\n\n        const updatedThreadMap = {\n          ...prevMap,\n          [threadId]: {\n            ...prevMap[threadId],\n            messages: updatedMessages,\n          },\n        };\n        return updatedThreadMap;\n      });\n\n      if (sendToServer) {\n        try {\n          await client.beta.threads.messages.create(message.threadId, {\n            content: message.content,\n            role: message.role,\n            additionalContext: chatMessage.additionalContext,\n          });\n        } catch (error) {\n          console.error(\"Failed to add message to server\", error);\n\n          // Revert optimistic local state update\n          setThreadMap((prev) => {\n            const prevMessages = prev[threadId]?.messages || [];\n\n            // addThreadMessage -> for new messages or simple updates\n            // On Fail -> remove the added/updated message (no prev state)\n            const updatedMessages = prevMessages.filter(\n              (msg) => msg.id !== messageId,\n            );\n            return {\n              ...prev,\n              [threadId]: {\n                ...prev[threadId],\n                messages: updatedMessages,\n              },\n            };\n          });\n          throw error;\n        }\n      }\n      return threadMap[threadId]?.messages || [];\n    },\n    [client.beta.threads.messages, currentThread, threadMap],\n  );\n\n  const updateThreadMessage = useCallback(\n    async (\n      id: string,\n      message: PartialTamboThreadMessageWithThreadId,\n      sendToServer = true,\n      createdAt: string = new Date().toISOString(),\n    ) => {\n      setThreadMap((prevMap) => {\n        const prevMessages = prevMap[message.threadId]?.messages || [];\n        const updatedMessages = prevMessages.map((msg) => {\n          if (msg.id === id) {\n            // Merge the partial update with the existing message\n            const updatedMessage: TamboThreadMessage = {\n              ...msg,\n              ...message,\n              id: msg.id,\n              createdAt: message.createdAt ?? msg.createdAt ?? createdAt,\n            };\n            return updatedMessage;\n          }\n          return msg;\n        });\n        return {\n          ...prevMap,\n          [message.threadId]: {\n            ...prevMap[message.threadId],\n            messages: updatedMessages,\n          },\n        };\n      });\n\n      if (sendToServer && message.content && message.role) {\n        try {\n          await client.beta.threads.messages.create(message.threadId, {\n            content: message.content,\n            role: message.role,\n            additionalContext: message.additionalContext,\n          });\n        } catch (error) {\n          console.error(\"Failed to update message on server\", error);\n\n          // Revert local state update by removing the optimistic message\n          setThreadMap((prev) => {\n            const updatedMessages = prev[message.threadId]?.messages?.filter(\n              (msg) => msg.id !== id,\n            );\n            return {\n              ...prev,\n              [message.threadId]: {\n                ...prev[message.threadId],\n                messages: updatedMessages,\n              },\n            };\n          });\n          throw error;\n        }\n      }\n    },\n    [client.beta.threads.messages],\n  );\n\n  const generateThreadName = useCallback(\n    async (threadId?: string, contextKey?: string) => {\n      threadId ??= currentThreadId;\n      if (threadId === placeholderThread.id) {\n        console.warn(\"Cannot generate name for empty thread\");\n        return threadMap[threadId];\n      }\n\n      const threadWithGeneratedName =\n        await client.beta.threads.generateName(threadId);\n\n      // Update local thread state\n      setThreadMap((prevMap) => {\n        if (!prevMap[threadId]) {\n          return prevMap;\n        }\n        return {\n          ...prevMap,\n          [threadId]: {\n            ...prevMap[threadId],\n            name: threadWithGeneratedName.name,\n          },\n        };\n      });\n\n      // Update threads cache to reflect the new name in the UI\n      await updateThreadInCache(\n        threadId,\n        (thread) => ({\n          ...thread,\n          name: threadWithGeneratedName.name,\n        }),\n        contextKey,\n      );\n\n      return threadWithGeneratedName;\n    },\n    [\n      client.beta.threads,\n      currentThreadId,\n      threadMap,\n      placeholderThread.id,\n      updateThreadInCache,\n    ],\n  );\n\n  const maybeAutoGenerateThreadName = useCallback(\n    (threadId: string, contextKey?: string) => {\n      // Use setThreadMap to access the latest state\n      setThreadMap((map) => {\n        const thread = map[threadId];\n\n        if (!thread || !autoGenerateThreadName) {\n          return map;\n        }\n\n        if (\n          autoGenerateNameThreshold == null ||\n          thread.id === placeholderThread.id\n        ) {\n          return map;\n        }\n\n        const messageCount = thread.messages.length;\n\n        // Only auto-generate if thread has no name and threshold is met\n        if (!thread.name && messageCount >= autoGenerateNameThreshold) {\n          // Generating a thread name is not critical, so we can fire-and-forget\n          void generateThreadName(threadId, contextKey).catch((error) => {\n            console.error(\"Failed to generate thread name:\", error);\n          });\n        }\n\n        return map;\n      });\n    },\n    [\n      autoGenerateThreadName,\n      autoGenerateNameThreshold,\n      placeholderThread.id,\n      generateThreadName,\n    ],\n  );\n\n  const startNewThread = useCallback(() => {\n    setCurrentThreadId(placeholderThread.id);\n    setThreadMap((prevMap) => {\n      return {\n        ...prevMap,\n        [placeholderThread.id]: placeholderThread,\n      };\n    });\n  }, [placeholderThread]);\n\n  const updateThreadName = useCallback(\n    async (name: string, threadId?: string) => {\n      threadId ??= currentThreadId;\n      const previousName = threadMap[threadId]?.name;\n\n      setThreadMap((prevMap) => {\n        if (!prevMap[threadId]) {\n          return prevMap;\n        }\n        return { ...prevMap, [threadId]: { ...prevMap[threadId], name } };\n      });\n\n      if (threadId !== placeholderThread.id) {\n        try {\n          const currentProject = await client.beta.projects.getCurrent();\n          await client.beta.threads.update(threadId, {\n            name,\n            projectId: currentProject.id,\n          });\n        } catch (error) {\n          console.error(\"Failed to update thread name on server\", error);\n          // Revert local state update\n          setThreadMap((prevMap) => {\n            if (!prevMap[threadId]) {\n              return prevMap;\n            }\n            return {\n              ...prevMap,\n              [threadId]: { ...prevMap[threadId], name: previousName },\n            };\n          });\n          throw error;\n        }\n      }\n    },\n    [\n      currentThreadId,\n      client.beta.projects,\n      client.beta.threads,\n      placeholderThread.id,\n      threadMap,\n    ],\n  );\n\n  const switchCurrentThread = useCallback(\n    async (threadId: string, fetch = true) => {\n      if (threadId === placeholderThread.id) {\n        console.warn(\"Switching to placeholder thread, may be a bug.\");\n        return;\n      }\n\n      setCurrentThreadId(threadId);\n      setThreadMap((prevMap) => {\n        if (prevMap[threadId]) {\n          return prevMap;\n        }\n        // If this is a new thread, add placeholder thread messages to the thread\n        const updatedThreadMap = {\n          ...prevMap,\n          [threadId]: {\n            ...prevMap[placeholderThread.id],\n            id: threadId,\n          },\n        };\n        return updatedThreadMap;\n      });\n\n      if (fetch) {\n        await fetchThread(threadId);\n      }\n    },\n    [fetchThread, placeholderThread],\n  );\n\n  const updateThreadStatus = useCallback(\n    (threadId: string, stage: GenerationStage, statusMessage?: string) => {\n      setThreadMap((prevMap) => {\n        const updatedThreadMap = {\n          ...prevMap,\n          [threadId]: {\n            ...prevMap[threadId],\n            generationStage: stage,\n            statusMessage: statusMessage,\n          },\n        };\n        return updatedThreadMap;\n      });\n    },\n    [],\n  );\n\n  const cancel = useCallback(\n    async (threadId?: string) => {\n      threadId ??= currentThreadId;\n      const currentGenerationStage =\n        currentThread?.generationStage ?? GenerationStage.IDLE;\n      if (isIdleStage(currentGenerationStage as GenerationStage)) {\n        return;\n      }\n      setIgnoreResponse(true);\n      setThreadMap((prevMap) => {\n        if (!prevMap[threadId]) {\n          return prevMap;\n        }\n\n        return {\n          ...prevMap,\n          [threadId]: {\n            ...prevMap[threadId],\n            generationStage: GenerationStage.CANCELLED,\n            messages: prevMap[threadId].messages.map((message) => {\n              if (\n                message.id ===\n                prevMap[threadId].messages[\n                  prevMap[threadId].messages.length - 1\n                ].id\n              ) {\n                return {\n                  ...message,\n                  isCancelled: true,\n                };\n              }\n              return message;\n            }),\n          },\n        };\n      });\n\n      await client.beta.threads.cancel(threadId);\n    },\n    [client.beta.threads, currentThreadId, currentThread?.generationStage],\n  );\n\n  const handleAdvanceStream = useCallback(\n    async (\n      stream: AsyncIterable<TamboAI.Beta.Threads.ThreadAdvanceResponse>,\n      params: TamboAI.Beta.Threads.ThreadAdvanceByIDParams,\n      threadId: string,\n      contextKey?: string,\n    ): Promise<TamboThreadMessage> => {\n      if (ignoreResponseRef.current) {\n        setIgnoreResponse(false);\n        return createEmptyMessage(threadId);\n      }\n      let finalMessage: Readonly<TamboThreadMessage> | undefined;\n      let hasSetThreadId = false;\n      updateThreadStatus(threadId, GenerationStage.STREAMING_RESPONSE);\n\n      for await (const chunk of stream) {\n        // Store MCP access token in thread data\n        if (chunk.mcpAccessToken) {\n          // note that we're only setting it positively during streaming, because it might\n          // not have been set yet in the chunk (i.e. we're not unsetting it in the chunk)\n          setThreadMap((prev) => {\n            const thread = prev[threadId];\n            if (thread) {\n              return {\n                ...prev,\n                [threadId]: {\n                  ...thread,\n                  mcpAccessToken: chunk.mcpAccessToken,\n                },\n              };\n            }\n            return prev;\n          });\n        }\n\n        if (chunk.responseMessageDto.toolCallRequest) {\n          const toolName = chunk.responseMessageDto.toolCallRequest.toolName;\n          updateThreadStatus(\n            chunk.responseMessageDto.threadId,\n            GenerationStage.FETCHING_CONTEXT,\n          );\n\n          await updateThreadMessage(\n            chunk.responseMessageDto.id,\n            {\n              ...chunk.responseMessageDto,\n            },\n            false,\n          );\n\n          const toolCallResponse = await handleToolCall(\n            chunk.responseMessageDto.toolCallRequest,\n            toolRegistry,\n            onCallUnregisteredTool,\n          );\n          if (ignoreResponseRef.current) {\n            setIgnoreResponse(false);\n            return createEmptyMessage(threadId);\n          }\n\n          const contentParts = await convertToolResponse(toolCallResponse);\n\n          const toolCallResponseParams: TamboAI.Beta.Threads.ThreadAdvanceByIDParams =\n            {\n              ...params,\n              // Exclude initialMessages from tool response since thread already exists\n              initialMessages: undefined,\n              ...(toolName\n                ? {\n                    toolCallCounts: {\n                      ...(params.toolCallCounts ?? {}),\n                      [toolName]: (params.toolCallCounts?.[toolName] ?? 0) + 1,\n                    },\n                  }\n                : {}),\n              messageToAppend: {\n                content: contentParts,\n                role: \"tool\",\n                actionType: \"tool_response\",\n                component: chunk.responseMessageDto.component,\n                tool_call_id: chunk.responseMessageDto.tool_call_id,\n                error: toolCallResponse.error,\n              },\n            };\n\n          await updateThreadMessage(\n            chunk.responseMessageDto.id,\n            {\n              ...chunk.responseMessageDto,\n              error: toolCallResponse.error,\n            },\n            false,\n          );\n\n          await addThreadMessage(\n            {\n              threadId: chunk.responseMessageDto.threadId,\n              content: contentParts,\n              role: \"tool\",\n              id: crypto.randomUUID(),\n              createdAt: new Date().toISOString(),\n              componentState: {},\n              actionType: \"tool_response\",\n              tool_call_id: chunk.responseMessageDto.tool_call_id,\n              error: toolCallResponse.error,\n            },\n            false,\n          );\n\n          updateThreadStatus(\n            chunk.responseMessageDto.threadId,\n            GenerationStage.STREAMING_RESPONSE,\n          );\n          const toolCallResponseStream = await advanceStream(\n            client,\n            toolCallResponseParams,\n            chunk.responseMessageDto.threadId,\n          );\n\n          return await handleAdvanceStream(\n            toolCallResponseStream,\n            toolCallResponseParams,\n            chunk.responseMessageDto.threadId,\n            contextKey,\n          );\n        } else {\n          if (ignoreResponseRef.current) {\n            setIgnoreResponse(false);\n            return finalMessage ?? createEmptyMessage(threadId);\n          }\n          if (\n            !hasSetThreadId &&\n            chunk.responseMessageDto.threadId &&\n            chunk.responseMessageDto.threadId !== currentThread?.id\n          ) {\n            hasSetThreadId = true;\n            const wasPlaceholderThread =\n              currentThreadId === PLACEHOLDER_THREAD.id;\n            await switchCurrentThread(chunk.responseMessageDto.threadId, false);\n\n            // If we're switching from placeholder to a real thread\n            // this means a new thread was created, so add it to cache\n            if (wasPlaceholderThread) {\n              await addThreadToCache(\n                chunk.responseMessageDto.threadId,\n                contextKey,\n              );\n              // Check if we should auto-generate name for the newly created thread\n              maybeAutoGenerateThreadName(\n                chunk.responseMessageDto.threadId,\n                contextKey,\n              );\n            }\n          }\n\n          if (!finalMessage) {\n            finalMessage = chunk.responseMessageDto.component?.componentName\n              ? renderComponentIntoMessage(\n                  chunk.responseMessageDto,\n                  componentList,\n                )\n              : chunk.responseMessageDto;\n            await addThreadMessage(finalMessage, false);\n          } else {\n            // Handle streaming tool calls\n            if (chunk.responseMessageDto.component?.toolCallRequest) {\n              const { toolName } =\n                chunk.responseMessageDto.component.toolCallRequest;\n              const tool = toolName ? toolRegistry[toolName] : undefined;\n\n              // if there is a tool call request on a component in a streaming chunk, and the tool\n              // is marked as streamable by the correct annotation, handle it\n              const isStreamable =\n                tool?.annotations?.tamboStreamableHint ?? false;\n\n              if (isStreamable) {\n                // We're not paying attention to the tool call response here - we only want the\n                // final tool call which is handled by the presence of a toolCallRequest on the\n                // top-level responseMessageDto\n                // see above: `if (chunk.responseMessageDto.toolCallRequest) { ... }`\n                void (await handleToolCall(\n                  chunk.responseMessageDto.component.toolCallRequest,\n                  toolRegistry,\n                  onCallUnregisteredTool,\n                ));\n              }\n            }\n\n            // Capture previous message ID before updating finalMessage\n            const previousMessageId = finalMessage.id;\n\n            if (chunk.responseMessageDto.component?.componentName) {\n              finalMessage = renderComponentIntoMessage(\n                chunk.responseMessageDto,\n                componentList,\n              );\n            } else {\n              finalMessage = chunk.responseMessageDto;\n            }\n\n            // if we start getting a new message mid-stream, put the previous one on screen\n            const isNewMessage =\n              chunk.responseMessageDto.id !== previousMessageId;\n            if (isNewMessage) {\n              await addThreadMessage(finalMessage, false);\n            } else {\n              await updateThreadMessage(finalMessage.id, finalMessage, false);\n            }\n          }\n        }\n      }\n\n      const completedThreadId = finalMessage?.threadId ?? threadId;\n\n      updateThreadStatus(completedThreadId, GenerationStage.COMPLETE);\n      maybeAutoGenerateThreadName(completedThreadId, contextKey);\n\n      return (\n        finalMessage ?? {\n          ...createEmptyMessage(completedThreadId),\n          content: [{ type: \"text\", text: \"Error processing stream\" }],\n        }\n      );\n    },\n    [\n      addThreadMessage,\n      addThreadToCache,\n      maybeAutoGenerateThreadName,\n      client,\n      componentList,\n      currentThread?.id,\n      currentThreadId,\n      onCallUnregisteredTool,\n      switchCurrentThread,\n      toolRegistry,\n      updateThreadMessage,\n      updateThreadStatus,\n    ],\n  );\n\n  const sendThreadMessage = useCallback(\n    async (\n      message: string,\n      options: {\n        threadId?: string;\n        streamResponse?: boolean;\n        forceToolChoice?: string;\n        contextKey?: string;\n        additionalContext?: Record<string, any>;\n        content?: TamboAI.Beta.Threads.ChatCompletionContentPart[];\n      } = {},\n    ): Promise<TamboThreadMessage> => {\n      setIgnoreResponse(false);\n      const {\n        threadId = currentThreadId ?? placeholderThread.id,\n        streamResponse = streaming,\n        forceToolChoice,\n        contextKey,\n        additionalContext,\n        content,\n      } = options;\n      if (!streamResponse) {\n        throw new Error(\n          \"Non-streaming mode is deprecated. Use streaming mode instead.\",\n        );\n      }\n      updateThreadStatus(threadId, GenerationStage.FETCHING_CONTEXT);\n\n      // Get additional context from enabled helpers\n      const helperContexts = await getAdditionalContext();\n\n      // Combine all contexts\n      const combinedContext: Record<string, any> = {\n        ...(additionalContext ?? {}),\n      };\n\n      // Add helper contexts to combinedContext\n      for (const helperContext of helperContexts) {\n        combinedContext[helperContext.name] = helperContext.context;\n      }\n\n      // Build and optimistically add user message (for revert on fail)\n      const optimiticMessageId = crypto.randomUUID();\n      const messageContent = content ?? [\n        { type: \"text\" as const, text: message },\n      ];\n\n      await addThreadMessage(\n        {\n          content: messageContent as any,\n          renderedComponent: null,\n          role: \"user\",\n          threadId: threadId,\n          id: optimiticMessageId,\n          createdAt: new Date().toISOString(),\n          componentState: {},\n          additionalContext: combinedContext,\n        },\n        false,\n      );\n\n      maybeAutoGenerateThreadName(threadId, contextKey);\n\n      const availableComponents = getAvailableComponents(\n        componentList,\n        toolRegistry,\n        componentToolAssociations,\n      );\n      const unassociatedTools = getUnassociatedTools(\n        toolRegistry,\n        componentToolAssociations,\n      );\n\n      // Track tool call counts for this message processing\n      const toolCallCounts: Record<string, number> = {};\n\n      const params: TamboAI.Beta.Threads.ThreadAdvanceByIDParams = {\n        messageToAppend: {\n          content: messageContent as any,\n          role: \"user\",\n          additionalContext: combinedContext,\n        },\n        contextKey,\n        availableComponents: availableComponents,\n        clientTools: unassociatedTools.map((tool) =>\n          mapTamboToolToContextTool(tool),\n        ),\n        forceToolChoice: forceToolChoice,\n        toolCallCounts,\n        ...(threadId === placeholderThread.id &&\n          initialMessages.length > 0 && {\n            initialMessages: initialMessages.map((msg) => ({\n              content: msg.content,\n              role: msg.role,\n              additionalContext: msg.additionalContext,\n            })),\n          }),\n      };\n\n      let advanceStreamResponse: AsyncIterable<TamboAI.Beta.Threads.ThreadAdvanceResponse>;\n      try {\n        advanceStreamResponse = await advanceStream(\n          client,\n          params,\n          threadId === placeholderThread.id ? undefined : threadId,\n        );\n      } catch (error) {\n        updateThreadStatus(threadId, GenerationStage.ERROR);\n        // Rollback the optimistic user message\n        setThreadMap((prev) => {\n          const thread = prev[threadId];\n          if (!thread) return prev;\n          return {\n            ...prev,\n            [threadId]: {\n              ...thread,\n              messages: thread.messages.filter(\n                (msg) => msg.id !== optimiticMessageId,\n              ),\n            },\n          };\n        });\n        throw error;\n      }\n      try {\n        const result = await handleAdvanceStream(\n          advanceStreamResponse,\n          params,\n          threadId,\n          contextKey,\n        );\n\n        return result;\n      } catch (error) {\n        updateThreadStatus(threadId, GenerationStage.ERROR);\n        // Rollback the optimistic user message\n        setThreadMap((prev) => {\n          const thread = prev[threadId];\n          if (!thread) return prev;\n          return {\n            ...prev,\n            [threadId]: {\n              ...thread,\n              messages: thread.messages.filter(\n                (msg) => msg.id !== optimiticMessageId,\n              ),\n            },\n          };\n        });\n        throw error;\n      }\n    },\n    [\n      componentList,\n      toolRegistry,\n      componentToolAssociations,\n      currentThreadId,\n      addThreadMessage,\n      client,\n      updateThreadStatus,\n      handleAdvanceStream,\n      streaming,\n      getAdditionalContext,\n      placeholderThread.id,\n      initialMessages,\n      maybeAutoGenerateThreadName,\n    ],\n  );\n\n  return (\n    <TamboThreadContext.Provider\n      value={{\n        thread: currentThread,\n        currentThreadId,\n        currentThread,\n        threadMap,\n        setThreadMap,\n        switchCurrentThread,\n        startNewThread,\n        updateThreadName,\n        generateThreadName,\n        addThreadMessage,\n        updateThreadMessage,\n        streaming,\n        cancel,\n        sendThreadMessage,\n        contextKey,\n      }}\n    >\n      <TamboGenerationStageProvider\n        generationStage={currentGenerationStage}\n        statusMessage={currentStatusMessage}\n      >\n        {children}\n      </TamboGenerationStageProvider>\n    </TamboThreadContext.Provider>\n  );\n};\n\n/**\n * The useTamboGenerationStage hook provides access to the generation stage context\n * to the descendants of the TamboThreadProvider.\n * @returns The generation stage context\n */\nexport const useTamboGenerationStage = (): TamboGenerationStageContextProps => {\n  const generationStageContext = useContext(TamboGenerationStageContext);\n\n  if (generationStageContext === undefined) {\n    throw new Error(\n      \"useTamboGenerationStage must be used within a TamboThreadProvider\",\n    );\n  }\n\n  return generationStageContext;\n};\n\n/**\n * The useTamboThread hook provides access to the current thread context\n * to the descendants of the TamboThreadProvider.\n * @returns All state and actions for the current thread\n */\nexport const useTamboThread = (): CombinedTamboThreadContextProps => {\n  const threadContext = useContext(TamboThreadContext);\n  const generationStageContext = useContext(TamboGenerationStageContext);\n\n  if (threadContext === undefined) {\n    throw new Error(\"useTamboThread must be used within a TamboThreadProvider\");\n  }\n\n  if (generationStageContext === undefined) {\n    throw new Error(\"useTamboThread must be used within a TamboThreadProvider\");\n  }\n\n  return {\n    ...threadContext,\n    ...generationStageContext,\n  };\n};\n\nasync function convertToolResponse(toolCallResponse: {\n  result: unknown;\n  error?: string;\n  tamboTool?: TamboTool;\n}): Promise<TamboAI.Beta.Threads.ChatCompletionContentPart[]> {\n  // If the tool call errored, surface that as text so the model reliably sees the error\n  if (toolCallResponse.error) {\n    return [{ type: \"text\", text: toText(toolCallResponse.result) }];\n  }\n\n  // Use custom transform when available\n  if (toolCallResponse.tamboTool?.transformToContent) {\n    return await toolCallResponse.tamboTool.transformToContent(\n      // result shape is user-defined; let the transform decide how to handle it\n      toolCallResponse.result as any,\n    );\n  }\n\n  // Default fallback to stringified text\n  return [{ type: \"text\", text: toText(toolCallResponse.result) }];\n}\n\n/**\n * Create a placeholder/cancelled message with default values\n * @param threadId - ID of the thread the message belongs to\n * @returns An empty TamboThreadMessage\n */\nfunction createEmptyMessage(threadId: string): TamboThreadMessage {\n  return {\n    threadId,\n    content: [{ type: \"text\", text: \"\" }],\n    role: \"assistant\",\n    createdAt: new Date().toISOString(),\n    id: crypto.randomUUID(),\n    componentState: {},\n  };\n}\n"]}