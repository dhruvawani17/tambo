"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_sdk_1 = require("@tambo-ai/typescript-sdk");
const react_1 = require("@testing-library/react");
const react_2 = __importDefault(require("react"));
const generate_component_response_1 = require("../model/generate-component-response");
const tambo_client_provider_1 = require("./tambo-client-provider");
const tambo_context_helpers_provider_1 = require("./tambo-context-helpers-provider");
const tambo_mcp_token_provider_1 = require("./tambo-mcp-token-provider");
const tambo_registry_provider_1 = require("./tambo-registry-provider");
const tambo_thread_provider_1 = require("./tambo-thread-provider");
// Mock crypto.randomUUID
Object.defineProperty(global, "crypto", {
    value: {
        randomUUID: jest.fn().mockReturnValue("test-uuid"),
    },
});
// Mock the required providers
jest.mock("./tambo-client-provider", () => {
    return {
        useTamboClient: jest.fn(),
        useTamboQueryClient: jest.fn(),
        TamboClientContext: react_2.default.createContext(undefined),
    };
});
jest.mock("@tambo-ai/typescript-sdk", () => ({
    advanceStream: jest.fn(),
}));
// Test utilities
const createMockMessage = (overrides = {}) => ({
    id: "test-message-1",
    content: [{ type: "text", text: "Hello" }],
    role: "user",
    threadId: "test-thread-1",
    createdAt: new Date().toISOString(),
    componentState: {},
    ...overrides,
});
// Test wrapper
const createWrapper = (initialMessages = [], tools = []) => {
    const TestWrapper = ({ children }) => {
        const client = (0, tambo_client_provider_1.useTamboClient)();
        const queryClient = (0, tambo_client_provider_1.useTamboQueryClient)();
        return (react_2.default.createElement(tambo_client_provider_1.TamboClientContext.Provider, { value: {
                client,
                queryClient,
                isUpdatingToken: false,
            } },
            react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, { components: [], tools: tools },
                react_2.default.createElement(tambo_context_helpers_provider_1.TamboContextHelpersProvider, null,
                    react_2.default.createElement(tambo_mcp_token_provider_1.TamboMcpTokenProvider, null,
                        react_2.default.createElement(tambo_thread_provider_1.TamboThreadProvider, { initialMessages: initialMessages, autoGenerateThreadName: false }, children))))));
    };
    TestWrapper.displayName = "TestWrapper";
    return TestWrapper;
};
describe("TamboThreadProvider with initial messages", () => {
    const mockClient = {
        beta: {
            threads: {
                advance: jest.fn(),
                advanceByID: jest.fn(),
                cancel: jest.fn(),
                messages: {
                    create: jest.fn(),
                },
            },
        },
    };
    beforeEach(() => {
        jest.clearAllMocks();
        tambo_client_provider_1.useTamboClient.mockReturnValue(mockClient);
        // Provide a minimal mock for the query client used by the provider
        const mockQueryClient = {
            setQueryData: jest.fn(),
            invalidateQueries: jest.fn(),
        };
        tambo_client_provider_1.useTamboQueryClient.mockReturnValue(mockQueryClient);
        typescript_sdk_1.advanceStream.mockImplementation(async function* () {
            yield {
                responseMessageDto: {
                    id: "response-1",
                    role: "assistant",
                    content: [{ type: "text", text: "Hello back!" }],
                    threadId: "new-thread-id",
                    componentState: {},
                    createdAt: new Date().toISOString(),
                },
                generationStage: generate_component_response_1.GenerationStage.COMPLETE,
            };
        });
    });
    it("should initialize with empty messages when no initial messages provided", () => {
        const { result } = (0, react_1.renderHook)(() => (0, tambo_thread_provider_1.useTamboThread)(), {
            wrapper: createWrapper(),
        });
        expect(result.current.thread.messages).toEqual([]);
    });
    it("should initialize with provided initial messages", () => {
        const initialMessages = [
            createMockMessage({
                id: "initial-1",
                role: "system",
                content: [{ type: "text", text: "You are a helpful assistant." }],
            }),
            createMockMessage({
                id: "initial-2",
                role: "user",
                content: [{ type: "text", text: "Hello!" }],
            }),
        ];
        const { result } = (0, react_1.renderHook)(() => (0, tambo_thread_provider_1.useTamboThread)(), {
            wrapper: createWrapper(initialMessages),
        });
        expect(result.current.thread.messages).toHaveLength(2);
        expect(result.current.thread.messages[0].content[0].text).toBe("You are a helpful assistant.");
        expect(result.current.thread.messages[1].content[0].text).toBe("Hello!");
    });
    it("should include initial messages when sending a message to a new thread", async () => {
        const initialMessages = [
            createMockMessage({
                id: "initial-1",
                role: "system",
                content: [{ type: "text", text: "You are a helpful assistant." }],
            }),
        ];
        const { result } = (0, react_1.renderHook)(() => (0, tambo_thread_provider_1.useTamboThread)(), {
            wrapper: createWrapper(initialMessages),
        });
        await (0, react_1.act)(async () => {
            await result.current.sendThreadMessage("Test message");
        });
        // Check that advanceStream was called with initial messages
        expect(typescript_sdk_1.advanceStream).toHaveBeenCalledWith(mockClient, expect.objectContaining({
            initialMessages: [
                {
                    content: [{ type: "text", text: "You are a helpful assistant." }],
                    role: "system",
                    additionalContext: undefined,
                },
            ],
        }), undefined);
    });
    it("should not include initial messages when sending to an existing thread", async () => {
        const initialMessages = [
            createMockMessage({
                id: "initial-1",
                role: "system",
                content: [{ type: "text", text: "You are a helpful assistant." }],
            }),
        ];
        const { result } = (0, react_1.renderHook)(() => (0, tambo_thread_provider_1.useTamboThread)(), {
            wrapper: createWrapper(initialMessages),
        });
        // Switch to an existing thread first
        await (0, react_1.act)(async () => {
            result.current.switchCurrentThread("existing-thread-id", false);
        });
        await (0, react_1.act)(async () => {
            await result.current.sendThreadMessage("Test message");
        });
        // Check that advanceStream was called without initial messages
        expect(typescript_sdk_1.advanceStream).toHaveBeenCalledWith(mockClient, expect.not.objectContaining({
            initialMessages: expect.anything(),
        }), "existing-thread-id");
    });
    it("should reset to initial messages when starting a new thread", () => {
        const initialMessages = [
            createMockMessage({
                id: "initial-1",
                role: "system",
                content: [{ type: "text", text: "You are a helpful assistant." }],
            }),
        ];
        const { result } = (0, react_1.renderHook)(() => (0, tambo_thread_provider_1.useTamboThread)(), {
            wrapper: createWrapper(initialMessages),
        });
        // Switch to an existing thread
        (0, react_1.act)(() => {
            result.current.switchCurrentThread("existing-thread-id", false);
        });
        // Start a new thread
        (0, react_1.act)(() => {
            result.current.startNewThread();
        });
        expect(result.current.thread.messages).toHaveLength(1);
        expect(result.current.thread.messages[0].content[0].text).toBe("You are a helpful assistant.");
    });
    it("should not include initial messages in tool response when first message triggers a tool", async () => {
        const initialMessages = [
            createMockMessage({
                id: "initial-1",
                role: "system",
                content: [{ type: "text", text: "You are a helpful assistant." }],
            }),
        ];
        // Create a test tool with JSON schema format
        const testTool = {
            name: "testTool",
            description: "A test tool",
            tool: jest.fn().mockResolvedValue({ result: "success" }),
            inputSchema: {
                type: "object",
                properties: {},
            },
            outputSchema: {
                type: "object",
                properties: {
                    result: { type: "string" },
                },
            },
        };
        // Mock advanceStream to simulate a tool call on first message
        let advanceStreamCallCount = 0;
        typescript_sdk_1.advanceStream.mockImplementation(async function* () {
            advanceStreamCallCount++;
            if (advanceStreamCallCount === 1) {
                // First call: user message triggers a tool
                yield {
                    responseMessageDto: {
                        id: "response-1",
                        role: "assistant",
                        content: [],
                        threadId: "new-thread-id",
                        componentState: {},
                        createdAt: new Date().toISOString(),
                        tool_call_id: "tool-call-1",
                        toolCallRequest: {
                            toolName: "testTool",
                            args: {},
                        },
                    },
                    generationStage: generate_component_response_1.GenerationStage.FETCHING_CONTEXT,
                };
            }
            else {
                // Second call: tool response should NOT have initialMessages
                yield {
                    responseMessageDto: {
                        id: "response-2",
                        role: "assistant",
                        content: [{ type: "text", text: "Tool executed successfully" }],
                        threadId: "new-thread-id",
                        componentState: {},
                        createdAt: new Date().toISOString(),
                    },
                    generationStage: generate_component_response_1.GenerationStage.COMPLETE,
                };
            }
        });
        const { result } = (0, react_1.renderHook)(() => (0, tambo_thread_provider_1.useTamboThread)(), {
            wrapper: createWrapper(initialMessages, [testTool]),
        });
        await (0, react_1.act)(async () => {
            await result.current.sendThreadMessage("Test message that triggers tool");
        });
        // First call should have initialMessages
        expect(typescript_sdk_1.advanceStream).toHaveBeenNthCalledWith(1, mockClient, expect.objectContaining({
            initialMessages: expect.any(Array),
        }), undefined);
        // Second call (tool response) should NOT have initialMessages
        expect(typescript_sdk_1.advanceStream).toHaveBeenNthCalledWith(2, mockClient, expect.objectContaining({
            messageToAppend: expect.objectContaining({
                role: "tool",
            }),
        }), "new-thread-id");
        // Verify that the second call does NOT contain initialMessages
        const secondCallParams = typescript_sdk_1.advanceStream.mock.calls[1][1];
        expect(secondCallParams.initialMessages).toBeUndefined();
    });
});
//# sourceMappingURL=tambo-thread-provider-initial-messages.test.js.map