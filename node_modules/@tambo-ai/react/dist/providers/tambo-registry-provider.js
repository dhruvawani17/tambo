"use strict";
"use client";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.useTamboMcpServerInfos = exports.useTamboRegistry = exports.TamboRegistryProvider = exports.TamboRegistryContext = void 0;
const react_1 = __importStar(require("react"));
const mcp_server_utils_1 = require("../util/mcp-server-utils");
const registry_validators_1 = require("../util/registry-validators");
const resource_validators_1 = require("../util/resource-validators");
exports.TamboRegistryContext = (0, react_1.createContext)({
    componentList: {},
    toolRegistry: {},
    componentToolAssociations: {},
    mcpServerInfos: [],
    resources: [],
    resourceSource: null,
    /**
     *
     */
    registerComponent: () => { },
    /**
     *
     */
    registerTool: () => { },
    /**
     *
     */
    registerTools: () => { },
    /**
     *
     */
    addToolAssociation: () => { },
    /**
     *
     */
    registerMcpServer: () => { },
    /**
     *
     */
    registerMcpServers: () => { },
    /**
     *
     */
    registerResource: () => { },
    /**
     *
     */
    registerResources: () => { },
    /**
     *
     */
    registerResourceSource: () => { },
});
/**
 * The TamboRegistryProvider is a React provider that provides a component
 * registry to the descendants of the provider.
 * @param props - The props for the TamboRegistryProvider
 * @param props.children - The children to wrap
 * @param props.components - The components to register
 * @param props.tools - The tools to register
 * @param props.mcpServers - The MCP servers to register
 * @param props.resources - The static resources to register
 * @param props.listResources - The dynamic resource search function (must be paired with getResource)
 * @param props.getResource - The dynamic resource fetch function (must be paired with listResources)
 * @param props.onCallUnregisteredTool - The function to call when an unknown tool is called (optional)
 * @returns The TamboRegistryProvider component
 */
const TamboRegistryProvider = ({ children, components: userComponents, tools: userTools, mcpServers: userMcpServers, resources: userResources, listResources: userListResources, getResource: userGetResource, onCallUnregisteredTool, }) => {
    const [componentList, setComponentList] = (0, react_1.useState)({});
    const [toolRegistry, setToolRegistry] = (0, react_1.useState)({});
    const [componentToolAssociations, setComponentToolAssociations] = (0, react_1.useState)({});
    const [staticMcpServerInfos, setStaticMcpServerInfos] = (0, react_1.useState)([]);
    const [dynamicMcpServerInfos, setDynamicMcpServerInfos] = (0, react_1.useState)([]);
    const [staticResources, setStaticResources] = (0, react_1.useState)([]);
    const [resourceSource, setResourceSource] = (0, react_1.useState)(null);
    const registryWithTool = (0, react_1.useCallback)((warnOnOverwrite) => {
        return (registry, tool) => {
            (0, registry_validators_1.validateTool)(tool);
            if (registry[tool.name] && warnOnOverwrite) {
                console.warn(`Overwriting tool ${tool.name}`);
            }
            return {
                ...registry,
                [tool.name]: tool,
            };
        };
    }, []);
    const registerTool = (0, react_1.useCallback)((tool, warnOnOverwrite = true) => {
        setToolRegistry((registry) => registryWithTool(warnOnOverwrite)(registry, tool));
    }, [registryWithTool]);
    const registerTools = (0, react_1.useCallback)((tools, warnOnOverwrite = true) => {
        setToolRegistry((existingRegistry) => tools.reduce(registryWithTool(warnOnOverwrite), existingRegistry));
    }, [registryWithTool]);
    const registerMcpServer = (0, react_1.useCallback)((info) => {
        const normalized = (0, mcp_server_utils_1.normalizeServerInfo)(info);
        setDynamicMcpServerInfos((prev) => [...prev, normalized]);
    }, []);
    const registerMcpServers = (0, react_1.useCallback)((infos) => {
        const normalized = infos.map(mcp_server_utils_1.normalizeServerInfo);
        setDynamicMcpServerInfos((prev) => [...prev, ...normalized]);
    }, []);
    const addToolAssociation = (0, react_1.useCallback)((componentName, tool) => {
        (0, registry_validators_1.validateToolAssociation)(componentName, tool.name, !!componentList[componentName], !!toolRegistry[tool.name]);
        setComponentToolAssociations((prev) => ({
            ...prev,
            [componentName]: [...(prev[componentName] || []), tool.name],
        }));
    }, [componentList, toolRegistry]);
    const registerComponent = (0, react_1.useCallback)((options, warnOnOverwrite = true) => {
        const { name, description, component, loadingComponent, associatedTools, } = options;
        const { props } = (0, registry_validators_1.validateAndPrepareComponent)(options);
        setComponentList((prev) => {
            if (prev[name] && warnOnOverwrite) {
                console.warn(`overwriting component ${name}`);
            }
            return {
                ...prev,
                [name]: {
                    component,
                    loadingComponent,
                    name,
                    description,
                    props,
                    contextTools: [],
                },
            };
        });
        if (associatedTools) {
            registerTools(associatedTools);
            setComponentToolAssociations((prev) => ({
                ...prev,
                [name]: associatedTools.map((tool) => tool.name),
            }));
        }
    }, [registerTools]);
    (0, react_1.useEffect)(() => {
        if (userComponents) {
            userComponents.forEach((component) => {
                registerComponent(component, false);
            });
        }
    }, [registerComponent, userComponents]);
    (0, react_1.useEffect)(() => {
        if (userTools) {
            registerTools(userTools, false);
        }
    }, [registerTools, userTools]);
    (0, react_1.useEffect)(() => {
        if (!userMcpServers || userMcpServers.length === 0) {
            setStaticMcpServerInfos([]);
            return;
        }
        // Normalize servers from props and ensure all have serverKey and transport
        const normalized = userMcpServers.map(mcp_server_utils_1.normalizeServerInfo);
        setStaticMcpServerInfos(normalized);
    }, [userMcpServers]);
    (0, react_1.useEffect)(() => {
        // Validate that listResources and getResource are both provided or both omitted
        (0, resource_validators_1.validateResourceSource)(userListResources, userGetResource);
        // Set static resources from props
        if (userResources) {
            userResources.forEach((resource) => (0, resource_validators_1.validateResource)(resource));
            setStaticResources(userResources);
        }
        else {
            setStaticResources([]);
        }
        // Set resource source from props
        if (userListResources && userGetResource) {
            setResourceSource({
                listResources: userListResources,
                getResource: userGetResource,
            });
        }
        else {
            setResourceSource(null);
        }
    }, [userResources, userListResources, userGetResource]);
    const registerResource = (0, react_1.useCallback)((resource) => {
        (0, resource_validators_1.validateResource)(resource);
        setStaticResources((prev) => [...prev, resource]);
    }, []);
    const registerResources = (0, react_1.useCallback)((resources) => {
        resources.forEach((resource) => (0, resource_validators_1.validateResource)(resource));
        setStaticResources((prev) => [...prev, ...resources]);
    }, []);
    const registerResourceSource = (0, react_1.useCallback)((source) => {
        (0, resource_validators_1.validateResourceSource)(source.listResources, source.getResource);
        setResourceSource(source);
    }, []);
    const mcpServerInfos = (0, react_1.useMemo)(() => {
        const allServers = [...staticMcpServerInfos, ...dynamicMcpServerInfos];
        return (0, mcp_server_utils_1.deduplicateMcpServers)(allServers);
    }, [staticMcpServerInfos, dynamicMcpServerInfos]);
    const value = {
        componentList,
        toolRegistry,
        componentToolAssociations,
        mcpServerInfos,
        resources: staticResources,
        resourceSource,
        registerComponent,
        registerTool,
        registerTools,
        addToolAssociation,
        registerMcpServer,
        registerMcpServers,
        registerResource,
        registerResources,
        registerResourceSource,
        onCallUnregisteredTool,
    };
    return (react_1.default.createElement(exports.TamboRegistryContext.Provider, { value: value }, children));
};
exports.TamboRegistryProvider = TamboRegistryProvider;
/**
 * The useTamboRegistry hook provides access to the component registry
 * to the descendants of the TamboRegistryProvider.
 * @returns The component registry
 */
const useTamboRegistry = () => {
    return (0, react_1.useContext)(exports.TamboRegistryContext);
};
exports.useTamboRegistry = useTamboRegistry;
/**
 * Hook to access the MCP server metadata from TamboRegistryProvider.
 * This provides access to the registered MCP server configurations (metadata only, not connections).
 *
 * This hook can be used anywhere within the TamboProvider hierarchy to access
 * the list of configured MCP servers without needing to be inside TamboMcpProvider.
 * @returns Array of MCP server metadata
 * @example
 * ```tsx
 * function MyComponent() {
 *   const mcpServers = useTamboMcpServerInfos();
 *
 *   return (
 *     <div>
 *       <h3>Configured MCP Servers:</h3>
 *       {mcpServers.map((server) => (
 *         <div key={server.url}>
 *           {server.name || server.url}
 *         </div>
 *       ))}
 *     </div>
 *   );
 * }
 * ```
 *
 * The returned objects are `NormalizedMcpServerInfo` instances, meaning both
 * `serverKey` and `transport` are always populated (with `transport`
 * defaulting to HTTP when not explicitly specified).
 */
const useTamboMcpServerInfos = () => {
    return (0, react_1.useContext)(exports.TamboRegistryContext).mcpServerInfos;
};
exports.useTamboMcpServerInfos = useTamboMcpServerInfos;
//# sourceMappingURL=tambo-registry-provider.js.map