"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = require("@testing-library/react");
const react_2 = __importDefault(require("react"));
const v4_1 = require("zod/v4");
const with_tambo_interactable_1 = require("../hoc/with-tambo-interactable");
const tambo_context_helpers_provider_1 = require("./tambo-context-helpers-provider");
const tambo_interactable_provider_1 = require("./tambo-interactable-provider");
const tambo_stubs_1 = require("./tambo-stubs");
function wrapperWithProviders(children) {
    const thread = {
        id: "t-1",
        projectId: "p-1",
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        messages: [],
        metadata: {},
    };
    return (react_2.default.createElement(tambo_stubs_1.TamboStubProvider, { thread: thread, registerTool: () => { }, registerTools: () => { }, registerComponent: () => { }, addToolAssociation: () => { } },
        react_2.default.createElement(tambo_context_helpers_provider_1.TamboContextHelpersProvider, null, children)));
}
describe("Interactables AdditionalContext (provider-based)", () => {
    test("registers default helper and returns payload with description and components", async () => {
        const Note = ({ title }) => react_2.default.createElement("div", null, title);
        const InteractableNote = (0, with_tambo_interactable_1.withTamboInteractable)(Note, {
            componentName: "Note",
            description: "A note",
            propsSchema: v4_1.z.object({ title: v4_1.z.string() }),
        });
        let capturedContexts = [];
        const TestComponent = () => {
            const { getAdditionalContext } = (0, tambo_context_helpers_provider_1.useTamboContextHelpers)();
            react_2.default.useEffect(() => {
                let mounted = true;
                void getAdditionalContext().then((contexts) => {
                    if (mounted) {
                        capturedContexts = contexts;
                    }
                });
                return () => {
                    mounted = false;
                };
            }, [getAdditionalContext]);
            return react_2.default.createElement("div", { "data-testid": "ready" }, "ready");
        };
        const { getByTestId } = (0, react_1.render)(wrapperWithProviders(react_2.default.createElement(tambo_interactable_provider_1.TamboInteractableProvider, null,
            react_2.default.createElement(InteractableNote, { title: "hello" }),
            react_2.default.createElement(TestComponent, null))));
        await (0, react_1.waitFor)(() => {
            expect(getByTestId("ready")).toBeInTheDocument();
            const entry = capturedContexts.find((c) => c.name === "interactables");
            expect(entry).toBeDefined();
            expect(Array.isArray(entry?.context?.components)).toBe(true);
            const comp = entry.context.components[0];
            expect(comp.componentName).toBe("Note");
            expect(comp.props).toEqual({ title: "hello" });
        });
    });
    test("returns null when no interactable components are present", async () => {
        let capturedContexts = [];
        const TestComponent = () => {
            const { getAdditionalContext } = (0, tambo_context_helpers_provider_1.useTamboContextHelpers)();
            react_2.default.useEffect(() => {
                let mounted = true;
                void getAdditionalContext().then((contexts) => {
                    if (mounted) {
                        capturedContexts = contexts;
                    }
                });
                return () => {
                    mounted = false;
                };
            }, [getAdditionalContext]);
            return react_2.default.createElement("div", { "data-testid": "ready" }, "ready");
        };
        const { getByTestId } = (0, react_1.render)(wrapperWithProviders(react_2.default.createElement(tambo_interactable_provider_1.TamboInteractableProvider, null,
            react_2.default.createElement("div", null, "No interactables here"),
            react_2.default.createElement(TestComponent, null))));
        await (0, react_1.waitFor)(() => {
            expect(getByTestId("ready")).toBeInTheDocument();
            const entry = capturedContexts.find((c) => c.name === "interactables");
            expect(entry).toBeUndefined(); // Should be filtered out when helper returns null
        });
    });
    test("context includes proper AI prompt with clear instructions", async () => {
        const Note = ({ title }) => react_2.default.createElement("div", null, title);
        const InteractableNote = (0, with_tambo_interactable_1.withTamboInteractable)(Note, {
            componentName: "Note",
            description: "A simple note",
            propsSchema: v4_1.z.object({ title: v4_1.z.string() }),
        });
        let capturedContexts = [];
        const TestComponent = () => {
            const { getAdditionalContext } = (0, tambo_context_helpers_provider_1.useTamboContextHelpers)();
            react_2.default.useEffect(() => {
                let mounted = true;
                void getAdditionalContext().then((contexts) => {
                    if (mounted) {
                        capturedContexts = contexts;
                    }
                });
                return () => {
                    mounted = false;
                };
            }, [getAdditionalContext]);
            return react_2.default.createElement("div", { "data-testid": "ready" }, "ready");
        };
        const { getByTestId } = (0, react_1.render)(wrapperWithProviders(react_2.default.createElement(tambo_interactable_provider_1.TamboInteractableProvider, null,
            react_2.default.createElement(InteractableNote, { title: "test" }),
            react_2.default.createElement(TestComponent, null))));
        await (0, react_1.waitFor)(() => {
            expect(getByTestId("ready")).toBeInTheDocument();
            const entry = capturedContexts.find((c) => c.name === "interactables");
            expect(entry).toBeDefined();
            expect(Array.isArray(entry?.context?.components)).toBe(true);
        });
    });
    test("includes component metadata in expected format", async () => {
        const Note = ({ title, color = "white", }) => react_2.default.createElement("div", { className: `note-${color}` }, title);
        const InteractableNote = (0, with_tambo_interactable_1.withTamboInteractable)(Note, {
            componentName: "Note",
            description: "A colorful note component",
            propsSchema: v4_1.z.object({
                title: v4_1.z.string(),
                color: v4_1.z.string().optional(),
            }),
        });
        let capturedContexts = [];
        const TestComponent = () => {
            const { getAdditionalContext } = (0, tambo_context_helpers_provider_1.useTamboContextHelpers)();
            react_2.default.useEffect(() => {
                let mounted = true;
                void getAdditionalContext().then((contexts) => {
                    if (mounted) {
                        capturedContexts = contexts;
                    }
                });
                return () => {
                    mounted = false;
                };
            }, [getAdditionalContext]);
            return react_2.default.createElement("div", { "data-testid": "ready" }, "ready");
        };
        const { getByTestId } = (0, react_1.render)(wrapperWithProviders(react_2.default.createElement(tambo_interactable_provider_1.TamboInteractableProvider, null,
            react_2.default.createElement(InteractableNote, { title: "test note", color: "blue" }),
            react_2.default.createElement(TestComponent, null))));
        await (0, react_1.waitFor)(() => {
            expect(getByTestId("ready")).toBeInTheDocument();
            const entry = capturedContexts.find((c) => c.name === "interactables");
            const component = entry.context.components[0];
            expect(component).toMatchObject({
                id: expect.any(String),
                componentName: "Note",
                description: "A colorful note component",
                props: { title: "test note", color: "blue" },
                propsSchema: "Available - use component-specific update tools",
            });
        });
    });
    test("snapshot hook returns immutable copies", async () => {
        const Note = ({ title }) => react_2.default.createElement("div", null, title);
        const InteractableNote = (0, with_tambo_interactable_1.withTamboInteractable)(Note, {
            componentName: "Note",
            description: "A note",
            propsSchema: v4_1.z.object({ title: v4_1.z.string() }),
        });
        const TestComponent = () => {
            const snapshot = (0, tambo_interactable_provider_1.useCurrentInteractablesSnapshot)();
            const [testResult, setTestResult] = react_2.default.useState("pending");
            react_2.default.useEffect(() => {
                if (snapshot.length > 0) {
                    const originalLength = snapshot.length;
                    // Try to mutate the returned array and props
                    snapshot.push({
                        id: "fake",
                        name: "Fake",
                        description: "",
                        component: () => null,
                        props: {},
                    });
                    snapshot[0].props.title = "MUTATED";
                    // The mutations should succeed on the returned copy, proving it's a separate object
                    if (snapshot.length === originalLength + 1 &&
                        snapshot[0].props.title === "MUTATED") {
                        setTestResult("mutation-successful-but-isolated");
                    }
                    else {
                        setTestResult("mutation-failed");
                    }
                }
            }, [snapshot]);
            return react_2.default.createElement("div", { "data-testid": "test-result" }, testResult);
        };
        const { getByTestId } = (0, react_1.render)(wrapperWithProviders(react_2.default.createElement(tambo_interactable_provider_1.TamboInteractableProvider, null,
            react_2.default.createElement(InteractableNote, { title: "immutable test" }),
            react_2.default.createElement(TestComponent, null))));
        await (0, react_1.waitFor)(() => {
            const result = getByTestId("test-result").textContent;
            expect(result).toBe("mutation-successful-but-isolated");
        });
    });
    test("multiple interactables from same provider appear in context", async () => {
        const Note = ({ title }) => react_2.default.createElement("div", null, title);
        const Counter = ({ count }) => (react_2.default.createElement("div", null, count));
        const InteractableNote = (0, with_tambo_interactable_1.withTamboInteractable)(Note, {
            componentName: "Note",
            description: "A note",
            propsSchema: v4_1.z.object({ title: v4_1.z.string() }),
        });
        const InteractableCounter = (0, with_tambo_interactable_1.withTamboInteractable)(Counter, {
            componentName: "Counter",
            description: "A counter",
            propsSchema: v4_1.z.object({ count: v4_1.z.number() }),
        });
        let capturedContexts = [];
        const TestComponent = () => {
            const { getAdditionalContext } = (0, tambo_context_helpers_provider_1.useTamboContextHelpers)();
            react_2.default.useEffect(() => {
                let mounted = true;
                void getAdditionalContext().then((contexts) => {
                    if (mounted) {
                        capturedContexts = contexts;
                    }
                });
                return () => {
                    mounted = false;
                };
            }, [getAdditionalContext]);
            return react_2.default.createElement("div", { "data-testid": "ready" }, "ready");
        };
        const { getByTestId } = (0, react_1.render)(wrapperWithProviders(react_2.default.createElement(tambo_interactable_provider_1.TamboInteractableProvider, null,
            react_2.default.createElement(InteractableNote, { title: "first" }),
            react_2.default.createElement(InteractableCounter, { count: 42 }),
            react_2.default.createElement(TestComponent, null))));
        await (0, react_1.waitFor)(() => {
            expect(getByTestId("ready")).toBeInTheDocument();
            const entry = capturedContexts.find((c) => c.name === "interactables");
            expect(entry?.context?.components).toHaveLength(2);
            const components = entry.context.components;
            expect(components[0].componentName).toBe("Note");
            expect(components[0].props).toEqual({ title: "first" });
            expect(components[1].componentName).toBe("Counter");
            expect(components[1].props).toEqual({ count: 42 });
        });
    });
    test("can be disabled by returning null", async () => {
        const Note = ({ title }) => react_2.default.createElement("div", null, title);
        const InteractableNote = (0, with_tambo_interactable_1.withTamboInteractable)(Note, {
            componentName: "Note",
            description: "A note",
            propsSchema: v4_1.z.object({ title: v4_1.z.string() }),
        });
        // Create a context helpers provider with a disabled interactables helper
        const DisabledContextHelpers = ({ children, }) => (react_2.default.createElement(tambo_context_helpers_provider_1.TamboContextHelpersProvider, { contextHelpers: {
                ["interactables"]: () => null,
            } }, children));
        let capturedContexts = [];
        const TestComponent = () => {
            const { getAdditionalContext } = (0, tambo_context_helpers_provider_1.useTamboContextHelpers)();
            react_2.default.useEffect(() => {
                let mounted = true;
                void getAdditionalContext().then((contexts) => {
                    if (mounted) {
                        capturedContexts = contexts;
                    }
                });
                return () => {
                    mounted = false;
                };
            }, [getAdditionalContext]);
            return react_2.default.createElement("div", { "data-testid": "ready" }, "ready");
        };
        const thread = {
            id: "t-1",
            projectId: "p-1",
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            messages: [],
            metadata: {},
        };
        const { getByTestId } = (0, react_1.render)(react_2.default.createElement(tambo_stubs_1.TamboStubProvider, { thread: thread, registerTool: () => { }, registerTools: () => { }, registerComponent: () => { }, addToolAssociation: () => { } },
            react_2.default.createElement(DisabledContextHelpers, null,
                react_2.default.createElement(tambo_interactable_provider_1.TamboInteractableProvider, null,
                    react_2.default.createElement(InteractableNote, { title: "should not appear" }),
                    react_2.default.createElement(TestComponent, null)))));
        await (0, react_1.waitFor)(() => {
            expect(getByTestId("ready")).toBeInTheDocument();
            const entry = capturedContexts.find((c) => c.name === "interactables");
            expect(entry).toBeUndefined(); // Should be filtered out when helper returns null
        });
    });
});
//# sourceMappingURL=tambo-interactables-additional-context.test.js.map