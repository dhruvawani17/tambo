"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = require("@testing-library/react");
const react_2 = __importDefault(require("react"));
const zod_1 = require("zod");
const tambo_interactable_provider_1 = require("./tambo-interactable-provider");
// Mock the context helpers
const mockAddContextHelper = jest.fn();
const mockRemoveContextHelper = jest.fn();
jest.mock("./tambo-context-helpers-provider", () => ({
    TamboContextHelpersProvider: ({ children, }) => react_2.default.createElement(react_2.default.Fragment, null, children),
    useTamboContextHelpers: () => ({
        addContextHelper: mockAddContextHelper,
        removeContextHelper: mockRemoveContextHelper,
    }),
}));
// Mock the component provider
const mockRegisterTool = jest.fn();
jest.mock("./tambo-component-provider", () => ({
    useTamboComponent: () => ({
        registerTool: mockRegisterTool,
    }),
}));
// Mock the context helper creation
jest.mock("../context-helpers/current-interactables-context-helper", () => ({
    createInteractablesContextHelper: () => jest.fn(() => ({
        name: "interactables",
        context: {
            description: "Test interactables context",
            components: [],
        },
    })),
}));
describe("TamboInteractableProvider - State Tracking", () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });
    const wrapper = ({ children }) => (react_2.default.createElement(tambo_interactable_provider_1.TamboInteractableProvider, null, children));
    it("should set and get state for a component", () => {
        const { result } = (0, react_1.renderHook)(() => (0, tambo_interactable_provider_1.useTamboInteractable)(), { wrapper });
        const component = {
            name: "TestComponent",
            description: "A test component",
            component: () => react_2.default.createElement("div", null, "Test"),
            props: { title: "Test" },
            propsSchema: zod_1.z.object({ title: zod_1.z.string() }),
        };
        let componentId = "";
        (0, react_1.act)(() => {
            componentId = result.current.addInteractableComponent(component);
        });
        (0, react_1.act)(() => {
            result.current.setInteractableState(componentId, "count", 10);
        });
        const state = result.current.getInteractableComponentState(componentId);
        expect(state).toEqual({ count: 10 });
    });
});
describe("TamboInteractableProvider - State Update Tool Registration", () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });
    const wrapper = ({ children }) => (react_2.default.createElement(tambo_interactable_provider_1.TamboInteractableProvider, null, children));
    it("should register both prop and state update tools when component is added", () => {
        const { result } = (0, react_1.renderHook)(() => (0, tambo_interactable_provider_1.useTamboInteractable)(), { wrapper });
        const component = {
            name: "TestComponent",
            description: "A test component",
            component: () => react_2.default.createElement("div", null, "Test"),
            props: { title: "Test" },
            propsSchema: zod_1.z.object({ title: zod_1.z.string() }),
        };
        let componentId = "";
        (0, react_1.act)(() => {
            componentId = result.current.addInteractableComponent(component);
        });
        // Should register both update_component_ and update_component_state_ tools
        const registeredToolNames = mockRegisterTool.mock.calls.map((call) => call[0].name);
        expect(registeredToolNames).toContain(`update_component_props_${componentId}`);
        expect(registeredToolNames).toContain(`update_component_state_${componentId}`);
    });
    it("should register state update tool with correct description", () => {
        const { result } = (0, react_1.renderHook)(() => (0, tambo_interactable_provider_1.useTamboInteractable)(), { wrapper });
        const component = {
            name: "MyComponent",
            description: "A test component",
            component: () => react_2.default.createElement("div", null, "Test"),
            props: {},
        };
        let componentId = "";
        (0, react_1.act)(() => {
            componentId = result.current.addInteractableComponent(component);
        });
        const stateToolCall = mockRegisterTool.mock.calls.find((call) => call[0].name.startsWith("update_component_state_"));
        expect(stateToolCall).toBeDefined();
        expect(stateToolCall[0].description).toContain(componentId);
        expect(stateToolCall[0].description).toContain("MyComponent");
    });
    it("should allow state update tool to update multiple state values", () => {
        const { result } = (0, react_1.renderHook)(() => (0, tambo_interactable_provider_1.useTamboInteractable)(), { wrapper });
        const component = {
            name: "TestComponent",
            description: "A test component",
            component: () => react_2.default.createElement("div", null, "Test"),
            props: {},
        };
        let componentId = "";
        (0, react_1.act)(() => {
            componentId = result.current.addInteractableComponent(component);
        });
        // Find the state update tool and call it
        const stateToolCall = mockRegisterTool.mock.calls.find((call) => call[0].name.startsWith("update_component_state_"));
        const toolFn = stateToolCall[0].tool;
        (0, react_1.act)(() => {
            toolFn({ componentId, newState: { count: 5, name: "test" } });
        });
        const state = result.current.getInteractableComponentState(componentId);
        expect(state).toEqual({ count: 5, name: "test" });
    });
    it("should preserve existing state when updating partial state", () => {
        const { result } = (0, react_1.renderHook)(() => (0, tambo_interactable_provider_1.useTamboInteractable)(), { wrapper });
        const component = {
            name: "TestComponent",
            description: "A test component",
            component: () => react_2.default.createElement("div", null, "Test"),
            props: {},
        };
        let componentId = "";
        (0, react_1.act)(() => {
            componentId = result.current.addInteractableComponent(component);
        });
        // Set initial state
        (0, react_1.act)(() => {
            result.current.setInteractableState(componentId, "existingKey", "value1");
        });
        // Find the state update tool and call it with a new key
        const stateToolCall = mockRegisterTool.mock.calls.find((call) => call[0].name.startsWith("update_component_state_"));
        const toolFn = stateToolCall[0].tool;
        (0, react_1.act)(() => {
            toolFn({ componentId, newState: { newKey: "value2" } });
        });
        const state = result.current.getInteractableComponentState(componentId);
        expect(state).toEqual({ existingKey: "value1", newKey: "value2" });
    });
    it("should use stateSchema when provided for tool registration", () => {
        const { result } = (0, react_1.renderHook)(() => (0, tambo_interactable_provider_1.useTamboInteractable)(), { wrapper });
        const stateSchema = zod_1.z.object({
            count: zod_1.z.number(),
            name: zod_1.z.string(),
        });
        const component = {
            name: "TestComponent",
            description: "A test component",
            component: () => react_2.default.createElement("div", null, "Test"),
            props: {},
            stateSchema,
        };
        (0, react_1.act)(() => {
            result.current.addInteractableComponent(component);
        });
        // Find the state update tool
        const stateToolCall = mockRegisterTool.mock.calls.find((call) => call[0].name.startsWith("update_component_state_"));
        expect(stateToolCall).toBeDefined();
        // The inputSchema should contain the partial stateSchema
        expect(stateToolCall[0].inputSchema).toBeDefined();
    });
    it("should return warning when updating state with empty object", () => {
        const { result } = (0, react_1.renderHook)(() => (0, tambo_interactable_provider_1.useTamboInteractable)(), { wrapper });
        const component = {
            name: "TestComponent",
            description: "A test component",
            component: () => react_2.default.createElement("div", null, "Test"),
            props: {},
        };
        let componentId = "";
        (0, react_1.act)(() => {
            componentId = result.current.addInteractableComponent(component);
        });
        // Find the state update tool and call it with empty state
        const stateToolCall = mockRegisterTool.mock.calls.find((call) => call[0].name.startsWith("update_component_state_"));
        const toolFn = stateToolCall[0].tool;
        let updateResult = "";
        (0, react_1.act)(() => {
            updateResult = toolFn({ componentId, newState: {} });
        });
        expect(updateResult).toContain("Warning");
        expect(updateResult).toContain("No state values provided");
    });
    it("should preserve stateSchema in interactable component", () => {
        const { result } = (0, react_1.renderHook)(() => (0, tambo_interactable_provider_1.useTamboInteractable)(), { wrapper });
        const stateSchema = zod_1.z.object({
            count: zod_1.z.number(),
        });
        const component = {
            name: "TestComponent",
            description: "A test component",
            component: () => react_2.default.createElement("div", null, "Test"),
            props: {},
            stateSchema,
        };
        let componentId = "";
        (0, react_1.act)(() => {
            componentId = result.current.addInteractableComponent(component);
        });
        const interactable = result.current.getInteractableComponent(componentId);
        expect(interactable?.stateSchema).toBe(stateSchema);
    });
    it("should convert stateSchema to partial JSON Schema (no required fields)", () => {
        const { result } = (0, react_1.renderHook)(() => (0, tambo_interactable_provider_1.useTamboInteractable)(), { wrapper });
        const stateSchema = zod_1.z.object({
            count: zod_1.z.number(),
            name: zod_1.z.string(),
        });
        const component = {
            name: "TestComponent",
            description: "A test component",
            component: () => react_2.default.createElement("div", null, "Test"),
            props: {},
            stateSchema,
        };
        (0, react_1.act)(() => {
            result.current.addInteractableComponent(component);
        });
        // Find the state update tool
        const stateToolCall = mockRegisterTool.mock.calls.find((call) => call[0].name.startsWith("update_component_state_"));
        expect(stateToolCall).toBeDefined();
        const inputSchema = stateToolCall[0].inputSchema;
        // The newState property should not have required fields (partial schema)
        expect(inputSchema.properties.newState).toBeDefined();
        expect(inputSchema.properties.newState.required).toBeUndefined();
        // But it should have the properties from the schema
        expect(inputSchema.properties.newState.properties).toBeDefined();
    });
    it("should use additionalProperties when no stateSchema provided", () => {
        const { result } = (0, react_1.renderHook)(() => (0, tambo_interactable_provider_1.useTamboInteractable)(), { wrapper });
        const component = {
            name: "TestComponent",
            description: "A test component",
            component: () => react_2.default.createElement("div", null, "Test"),
            props: {},
            // No stateSchema
        };
        (0, react_1.act)(() => {
            result.current.addInteractableComponent(component);
        });
        // Find the state update tool
        const stateToolCall = mockRegisterTool.mock.calls.find((call) => call[0].name.startsWith("update_component_state_"));
        expect(stateToolCall).toBeDefined();
        const inputSchema = stateToolCall[0].inputSchema;
        // The newState property should allow additional properties
        expect(inputSchema.properties.newState.additionalProperties).toBe(true);
    });
    it("should convert propsSchema to partial JSON Schema for props update tool", () => {
        const { result } = (0, react_1.renderHook)(() => (0, tambo_interactable_provider_1.useTamboInteractable)(), { wrapper });
        const propsSchema = zod_1.z.object({
            title: zod_1.z.string(),
            count: zod_1.z.number(),
        });
        const component = {
            name: "TestComponent",
            description: "A test component",
            component: () => react_2.default.createElement("div", null, "Test"),
            props: { title: "test", count: 0 },
            propsSchema,
        };
        (0, react_1.act)(() => {
            result.current.addInteractableComponent(component);
        });
        // Find the props update tool (not the state one)
        const propsToolCall = mockRegisterTool.mock.calls.find((call) => call[0].name.startsWith("update_component_") &&
            !call[0].name.includes("state"));
        expect(propsToolCall).toBeDefined();
        const inputSchema = propsToolCall[0].inputSchema;
        // The newProps property should not have required fields (partial schema)
        expect(inputSchema.properties.newProps).toBeDefined();
        expect(inputSchema.properties.newProps.required).toBeUndefined();
        // But it should have the properties from the schema
        expect(inputSchema.properties.newProps.properties).toBeDefined();
    });
    it("should use additionalProperties when no propsSchema provided", () => {
        const { result } = (0, react_1.renderHook)(() => (0, tambo_interactable_provider_1.useTamboInteractable)(), { wrapper });
        const component = {
            name: "TestComponent",
            description: "A test component",
            component: () => react_2.default.createElement("div", null, "Test"),
            props: { title: "test" },
            // No propsSchema
        };
        (0, react_1.act)(() => {
            result.current.addInteractableComponent(component);
        });
        // Find the props update tool
        const propsToolCall = mockRegisterTool.mock.calls.find((call) => call[0].name.startsWith("update_component_") &&
            !call[0].name.includes("state"));
        expect(propsToolCall).toBeDefined();
        const inputSchema = propsToolCall[0].inputSchema;
        // The newProps property should allow additional properties
        expect(inputSchema.properties.newProps.additionalProperties).toBe(true);
    });
});
//# sourceMappingURL=tambo-interactable-provider.test.js.map