"use strict";
// react-sdk/src/providers/tambo-interactable-provider.tsx
"use client";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.useCurrentInteractablesSnapshot = exports.useTamboInteractable = exports.TamboInteractableProvider = void 0;
const fast_equals_1 = require("fast-equals");
const react_1 = __importStar(require("react"));
const v3_1 = require("zod/v3");
const current_interactables_context_helper_1 = require("../context-helpers/current-interactables-context-helper");
const schema_1 = require("../schema");
const validate_component_name_1 = require("../util/validate-component-name");
const tambo_component_provider_1 = require("./tambo-component-provider");
const tambo_context_helpers_provider_1 = require("./tambo-context-helpers-provider");
const TamboInteractableContext = (0, react_1.createContext)({
    interactableComponents: [],
    addInteractableComponent: () => "",
    removeInteractableComponent: () => { },
    updateInteractableComponentProps: () => "",
    getInteractableComponent: () => undefined,
    getInteractableComponentsByName: () => [],
    clearAllInteractableComponents: () => { },
    setInteractableState: () => { },
    getInteractableComponentState: () => undefined,
    setInteractableSelected: () => { },
    clearInteractableSelections: () => { },
});
/**
 * The TamboInteractableProvider manages a list of components that are currently
 * interactable, allowing tambo to interact with them by updating their props. It also registers tools
 * for Tambo to perform CRUD operations on the components list.
 * @param props - The props for the TamboInteractableProvider
 * @param props.children - The children to wrap
 * @returns The TamboInteractableProvider component
 */
const TamboInteractableProvider = ({ children, }) => {
    const [interactableComponents, setInteractableComponents] = (0, react_1.useState)([]);
    const { registerTool } = (0, tambo_component_provider_1.useTamboComponent)();
    const { addContextHelper, removeContextHelper } = (0, tambo_context_helpers_provider_1.useTamboContextHelpers)();
    // Create a stable context helper function for interactable components
    const interactablesContextHelper = (0, react_1.useMemo)(() => (0, current_interactables_context_helper_1.createInteractablesContextHelper)(interactableComponents), [interactableComponents]);
    // Register the interactables context helper
    (0, react_1.useEffect)(() => {
        addContextHelper("interactables", interactablesContextHelper);
        return () => {
            removeContextHelper("interactables");
        };
    }, [interactablesContextHelper, addContextHelper, removeContextHelper]);
    (0, react_1.useEffect)(() => {
        if (interactableComponents.length > 0) {
            registerTool({
                name: "get_all_interactable_components",
                description: "Only use this tool if the user is asking about interactable components.Get all currently interactable components with their details including their current props. These are components that you can interact with on behalf of the user.",
                tool: () => {
                    return {
                        components: interactableComponents,
                    };
                },
                inputSchema: v3_1.z.object({}),
                outputSchema: v3_1.z.object({
                    components: v3_1.z.array(v3_1.z.object({
                        id: v3_1.z.string(),
                        name: v3_1.z.string(),
                        props: v3_1.z.record(v3_1.z.string(), v3_1.z.any()),
                        propsSchema: v3_1.z.record(v3_1.z.string(), v3_1.z.any()).optional(),
                    })),
                }),
            });
            registerTool({
                name: "get_interactable_component_by_id",
                description: "Get a specific interactable component by its ID",
                tool: ({ componentId }) => {
                    const component = interactableComponents.find((c) => c.id === componentId);
                    if (!component) {
                        return {
                            success: false,
                            error: `Component with ID ${componentId} not found`,
                        };
                    }
                    return {
                        success: true,
                        component: {
                            id: component.id,
                            componentName: component.name,
                            props: component.props,
                        },
                    };
                },
                inputSchema: v3_1.z.object({
                    componentId: v3_1.z.string().describe("The ID of the component"),
                }),
                outputSchema: v3_1.z.discriminatedUnion("success", [
                    v3_1.z.object({
                        success: v3_1.z.literal(true),
                        component: v3_1.z
                            .object({
                            id: v3_1.z.string(),
                            componentName: v3_1.z.string(),
                            props: v3_1.z.record(v3_1.z.string(), v3_1.z.any()),
                        })
                            .optional(),
                    }),
                    v3_1.z.object({
                        success: v3_1.z.literal(false),
                        error: v3_1.z.string(),
                    }),
                ]),
            });
            registerTool({
                name: "remove_interactable_component",
                description: "Remove an interactable component from the system",
                tool: ({ componentId }) => {
                    const component = interactableComponents.find((c) => c.id === componentId);
                    if (!component) {
                        return {
                            success: false,
                            error: `Component with ID ${componentId} not found`,
                        };
                    }
                    setInteractableComponents((prev) => prev.filter((c) => c.id !== componentId));
                    return {
                        success: true,
                        componentId,
                        removedComponent: {
                            id: component.id,
                            componentName: component.name,
                            props: component.props,
                        },
                    };
                },
                inputSchema: v3_1.z.object({
                    componentId: v3_1.z.string().describe("The ID of the component"),
                }),
                outputSchema: v3_1.z.discriminatedUnion("success", [
                    v3_1.z.object({
                        success: v3_1.z.literal(true),
                        componentId: v3_1.z.string(),
                        removedComponent: v3_1.z.object({
                            id: v3_1.z.string(),
                            componentName: v3_1.z.string(),
                            props: v3_1.z.record(v3_1.z.string(), v3_1.z.any()),
                        }),
                    }),
                    v3_1.z.object({
                        success: v3_1.z.literal(false),
                        error: v3_1.z.string(),
                    }),
                ]),
            });
        }
    }, [interactableComponents, registerTool]);
    const updateInteractableComponentProps = (0, react_1.useCallback)((id, newProps) => {
        if (!newProps || Object.keys(newProps).length === 0) {
            return `Warning: No props provided for component with ID ${id}.`;
        }
        setInteractableComponents((prev) => {
            const component = prev.find((c) => c.id === id);
            if (!component) {
                return prev;
            }
            // Compare props shallowly
            const propsChanged = Object.entries(newProps).some(([key, value]) => {
                return component.props[key] !== value;
            });
            if (!propsChanged) {
                return prev; // unchanged
            }
            // Apply partial update
            const updated = {
                ...component,
                props: { ...component.props, ...newProps },
            };
            const updatedComponents = [...prev];
            const idx = prev.findIndex((c) => c.id === id);
            updatedComponents[idx] = updated;
            return updatedComponents;
        });
        return "Updated successfully";
    }, []);
    const updateInteractableComponentState = (0, react_1.useCallback)((componentId, newState) => {
        if (!newState || Object.keys(newState).length === 0) {
            return `Warning: No state values provided for component with ID ${componentId}.`;
        }
        setInteractableComponents((components = []) => {
            const component = components.find((c) => c.id === componentId);
            if (!component)
                return components;
            const prevState = component.state ?? {};
            const updatedState = { ...prevState, ...newState };
            if ((0, fast_equals_1.deepEqual)(prevState, updatedState))
                return components;
            // TODO(lachieh): validate state against schema?
            const updated = {
                ...component,
                state: updatedState,
            };
            return components.map((c) => (c.id === componentId ? updated : c));
        });
        return "Updated successfully";
    }, []);
    const registerInteractableComponentPropsUpdateTool = (0, react_1.useCallback)((component, maxNameLength = 60) => {
        const tamboToolNamePart = `update_component_props_`;
        const availableLength = maxNameLength - tamboToolNamePart.length;
        if (component.id.length > availableLength) {
            throw new Error(`Interactable component id ${component.id} is too long. It must be less than ${availableLength} characters.`);
        }
        // Build newProps schema as JSON Schema
        let newPropsSchema;
        if (component.propsSchema) {
            // Convert any supported schema to JSON Schema, then make partial
            const fullSchema = (0, schema_1.schemaToJsonSchema)(component.propsSchema);
            newPropsSchema = (0, schema_1.makeJsonSchemaPartial)(fullSchema);
        }
        else {
            // No schema - allow any properties
            newPropsSchema = { type: "object", additionalProperties: true };
        }
        // Build the full input schema as JSON Schema
        const inputSchema = {
            type: "object",
            properties: {
                componentId: {
                    type: "string",
                    description: "The ID of the interactable component to update",
                },
                newProps: {
                    ...newPropsSchema,
                    description: "The props to update. Provide only the props you want to change.",
                },
            },
            required: ["componentId", "newProps"],
        };
        registerTool({
            name: `${tamboToolNamePart}${component.id}`,
            description: `Update the props of interactable component ${component.id} (${component.name}). Provide partial props (only props to change).`,
            tool: ({ componentId, newProps }) => {
                return updateInteractableComponentProps(componentId, newProps);
            },
            inputSchema,
            outputSchema: v3_1.z.string(),
        });
    }, [registerTool, updateInteractableComponentProps]);
    const registerInteractableComponentStateUpdateTool = (0, react_1.useCallback)((component, maxNameLength = 60) => {
        const tamboToolNamePart = `update_component_state_`;
        const availableLength = maxNameLength - tamboToolNamePart.length;
        if (component.id.length > availableLength) {
            throw new Error(`Interactable component id ${component.id} is too long. It must be less than ${availableLength} characters.`);
        }
        // Build newState schema as JSON Schema
        let newStateSchema = {
            type: "object",
            additionalProperties: true,
        };
        if (component.stateSchema) {
            // Convert any supported schema to JSON Schema, then make partial
            const fullSchema = (0, schema_1.schemaToJsonSchema)(component.stateSchema);
            newStateSchema = (0, schema_1.makeJsonSchemaPartial)(fullSchema);
        }
        // Build the full input schema as JSON Schema
        const inputSchema = {
            type: "object",
            properties: {
                componentId: {
                    type: "string",
                    description: "The ID of the interactable component to update",
                },
                newState: {
                    ...newStateSchema,
                    description: "The state values to update. Provide only the keys you want to change.",
                },
            },
            required: ["componentId", "newState"],
        };
        registerTool({
            name: `${tamboToolNamePart}${component.id}`,
            description: `Update the state of interactable component ${component.id} (${component.name}). You may provide partial state (only keys to change).`,
            tool: ({ componentId, newState }) => {
                return updateInteractableComponentState(componentId, newState);
            },
            inputSchema,
            outputSchema: v3_1.z.string(),
        });
    }, [registerTool, updateInteractableComponentState]);
    const addInteractableComponent = (0, react_1.useCallback)((component) => {
        // Validate component name
        (0, validate_component_name_1.assertValidName)(component.name, "component");
        // Add a random part to the component name to make it unique when using multiple instances of the same component.
        const tamboGeneratedNamePart = `-${Math.random().toString(36).slice(2, 5)}`;
        const id = `${component.name}${tamboGeneratedNamePart}`;
        const newComponent = {
            ...component,
            id,
            state: component.state ?? {},
        };
        registerInteractableComponentPropsUpdateTool(newComponent);
        registerInteractableComponentStateUpdateTool(newComponent);
        setInteractableComponents((prev) => {
            return [...prev, newComponent];
        });
        return id;
    }, [
        registerInteractableComponentPropsUpdateTool,
        registerInteractableComponentStateUpdateTool,
    ]);
    const removeInteractableComponent = (0, react_1.useCallback)((id) => {
        setInteractableComponents((prev) => prev.filter((c) => c.id !== id));
    }, []);
    const getInteractableComponent = (0, react_1.useCallback)((id) => {
        return interactableComponents.find((c) => c.id === id);
    }, [interactableComponents]);
    const getInteractableComponentsByName = (0, react_1.useCallback)((componentName) => {
        return interactableComponents.filter((c) => c.name === componentName);
    }, [interactableComponents]);
    const clearAllInteractableComponents = (0, react_1.useCallback)(() => {
        setInteractableComponents([]);
    }, []);
    const setInteractableStateValue = (0, react_1.useCallback)((componentId, key, value) => {
        setInteractableComponents((prev) => {
            const component = prev.find((c) => c.id === componentId);
            if (!component) {
                console.warn(`Tried to update state for component ${componentId} but it was not found.`);
                return prev;
            }
            const updated = {
                ...component,
                state: {
                    ...component.state,
                    [key]: value,
                },
            };
            const updatedComponents = prev.map((component) => {
                if (component.id === componentId) {
                    return updated;
                }
                return component;
            });
            return updatedComponents;
        });
    }, []);
    const getInteractableComponentState = (0, react_1.useCallback)((componentId) => {
        const component = interactableComponents.find((c) => c.id === componentId);
        return component?.state;
    }, [interactableComponents]);
    const setInteractableSelected = (0, react_1.useCallback)((componentId, isSelected) => {
        setInteractableComponents((prev) => {
            let found = false;
            const next = prev.map((component) => {
                if (component.id !== componentId)
                    return component;
                found = true;
                return component.isSelected === isSelected
                    ? component
                    : { ...component, isSelected: isSelected };
            });
            return found ? next : prev;
        });
    }, []);
    const clearInteractableSelections = (0, react_1.useCallback)(() => {
        setInteractableComponents((prev) => {
            if (!prev.some((c) => c.isSelected))
                return prev;
            return prev.map((c) => (c.isSelected ? { ...c, isSelected: false } : c));
        });
    }, []);
    const value = {
        interactableComponents,
        addInteractableComponent,
        removeInteractableComponent,
        updateInteractableComponentProps,
        getInteractableComponent,
        getInteractableComponentsByName,
        clearAllInteractableComponents,
        setInteractableState: setInteractableStateValue,
        getInteractableComponentState,
        setInteractableSelected,
        clearInteractableSelections,
    };
    return (react_1.default.createElement(TamboInteractableContext.Provider, { value: value }, children));
};
exports.TamboInteractableProvider = TamboInteractableProvider;
/**
 * The useTamboInteractable hook provides access to the interactable component
 * management functions.
 * @returns The interactable component management functions
 */
const useTamboInteractable = () => {
    return (0, react_1.useContext)(TamboInteractableContext);
};
exports.useTamboInteractable = useTamboInteractable;
/**
 * Hook to get a cloned snapshot of the current interactables.
 * Returns a shallow copy of the array with cloned items and props to prevent
 * external mutation from affecting internal state.
 * @returns The current interactables snapshot (cloned).
 */
const useCurrentInteractablesSnapshot = () => {
    const { interactableComponents } = (0, exports.useTamboInteractable)();
    // Clone the array and each item/props to prevent mutation
    const copy = interactableComponents.map((c) => ({
        ...c,
        props: { ...c.props },
    }));
    return copy;
};
exports.useCurrentInteractablesSnapshot = useCurrentInteractablesSnapshot;
//# sourceMappingURL=tambo-interactable-provider.js.map