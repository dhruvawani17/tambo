{"version":3,"file":"resource-content-resolver.js","sourceRoot":"","sources":["../../src/util/resource-content-resolver.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ReadResourceResult } from \"@modelcontextprotocol/sdk/types.js\";\nimport { REGISTRY_SERVER_KEY, ServerType } from \"../mcp/mcp-constants\";\nimport type { ConnectedMcpServer, McpServer } from \"../mcp/tambo-mcp-provider\";\nimport type { ResourceSource } from \"../model/resource-info\";\n\n/**\n * Type guard for narrowing McpServer to a connected server.\n * A connected server has a non-null client.\n * @param server - The MCP server to check\n * @returns True if the server is connected, false otherwise\n */\nfunction isConnectedMcpServer(server: McpServer): server is ConnectedMcpServer {\n  return \"client\" in server && server.client != null;\n}\n\n/**\n * Resolves content for client-side resources (MCP and registry).\n * Server-side (internal Tambo) resources are skipped - the backend can resolve them.\n * @param resourceUris - Prefixed URIs (e.g., \"linear:file://foo\", \"registry:file://bar\", \"tambo-abc:test://resource\")\n * @param mcpServers - Active MCP servers including virtual registry server\n * @param resourceSource - Registry resource source (listResources/getResource)\n * @returns Map of prefixedUri -> ReadResourceResult for resolved resources.\n *          Resources that failed to fetch or are internal server resources won't be in the map.\n */\nexport async function resolveResourceContents(\n  resourceUris: string[],\n  mcpServers: McpServer[],\n  resourceSource: ResourceSource | undefined,\n): Promise<Map<string, ReadResourceResult>> {\n  const results = new Map<string, ReadResourceResult>();\n\n  const fetchPromises = resourceUris.map(async (prefixedUri) => {\n    // Parse serverKey and original URI\n    // Format: serverKey:originalUri (e.g., \"linear:file://foo\", \"registry:docs://readme\")\n    const colonIndex = prefixedUri.indexOf(\":\");\n    if (colonIndex === -1) return;\n\n    const serverKey = prefixedUri.slice(0, colonIndex);\n    const originalUri = prefixedUri.slice(colonIndex + 1);\n\n    try {\n      // Handle registry resources directly - no server lookup needed\n      // Registry resources are local to the browser and resolved via resourceSource\n      if (serverKey === REGISTRY_SERVER_KEY) {\n        if (!resourceSource) {\n          console.warn(\n            `No resource source available to resolve registry resource: ${prefixedUri}`,\n          );\n          return;\n        }\n        const registryContent = await resourceSource.getResource(originalUri);\n        if (registryContent) {\n          results.set(prefixedUri, registryContent);\n        }\n        return;\n      }\n\n      // For non-registry resources, find the server by serverKey\n      const server = mcpServers.find((s) => s.serverKey === serverKey);\n      if (!server) {\n        console.warn(`No server found for resource: ${prefixedUri}`);\n        return;\n      }\n\n      switch (server.serverType) {\n        case ServerType.TAMBO_INTERNAL:\n          // Skip internal server resources - backend can resolve these\n          return;\n\n        case ServerType.TAMBO_REGISTRY:\n          // Should not reach here since we handle registry above, but keep for safety\n          return;\n\n        case ServerType.BROWSER_SIDE: {\n          // Client-side MCP resource\n          if (!isConnectedMcpServer(server)) {\n            console.warn(\n              `MCP server not connected for resource: ${prefixedUri}`,\n            );\n            return;\n          }\n          const mcpContent = (await server.client.client.readResource({\n            uri: originalUri,\n          })) as ReadResourceResult | null;\n          if (mcpContent) {\n            results.set(prefixedUri, mcpContent);\n          }\n          return;\n        }\n      }\n    } catch (error) {\n      // Graceful fallback - log warning and continue without content\n      console.warn(\n        `Failed to fetch resource content for ${prefixedUri}:`,\n        error,\n      );\n    }\n  });\n\n  await Promise.all(fetchPromises);\n  return results;\n}\n\n/**\n * Extracts resource URIs from text using the `@serverKey:uri` pattern.\n * @param text - Text potentially containing resource references\n * @returns Array of prefixed resource URIs (e.g., [\"linear:file://foo\", \"registry:file://bar\"])\n */\nexport function extractResourceUris(text: string): string[] {\n  const pattern = /@([a-zA-Z0-9-]+):(\\S+)/g;\n  const matches = Array.from(text.matchAll(pattern));\n  return matches.map(([, serverKey, uri]) => `${serverKey}:${uri}`);\n}\n"]}