{"version":3,"file":"registry-validators.js","sourceRoot":"","sources":["../../src/util/registry-validators.ts"],"names":[],"mappings":";;AAwDA,oCAyEC;AAgDD,kEA+BC;AAUD,0DAgBC;AAxOD,sCAKmB;AACnB,uEAA4D;AAE5D;;;;GAIG;AACH,SAAS,cAAc,CAAC,MAAmB;IACzC,OAAO,MAAM,CAAC,IAAI,KAAK,QAAQ,IAAI,MAAM,CAAC,UAAU,KAAK,SAAS,CAAC;AACrE,CAAC;AAED;;;;;GAKG;AACH,SAAS,kBAAkB,CAAC,MAAe,EAAE,OAAe;IAC1D,IAAI,UAAuB,CAAC;IAE5B,IAAI,IAAA,yBAAgB,EAAC,MAAM,CAAC,EAAE,CAAC;QAC7B,IAAI,CAAC;YACH,UAAU,GAAG,IAAA,2BAAkB,EAAC,MAAM,CAAC,CAAC;QAC1C,CAAC;QAAC,MAAM,CAAC;YACP,6DAA6D;YAC7D,OAAO;QACT,CAAC;IACH,CAAC;SAAM,IAAI,IAAA,4BAAmB,EAAC,MAAM,CAAC,EAAE,CAAC;QACvC,UAAU,GAAG,MAAM,CAAC;IACtB,CAAC;SAAM,CAAC;QACN,sCAAsC;QACtC,OAAO;IACT,CAAC;IAED,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,EAAE,CAAC;QAChC,MAAM,IAAI,KAAK,CACb,GAAG,OAAO,qDAAqD;YAC7D,mBAAmB,UAAU,CAAC,IAAI,IAAI,SAAS,KAAK;YACpD,yDAAyD,CAC5D,CAAC;IACJ,CAAC;AACH,CAAC;AAED;;;;GAIG;AACH,SAAgB,YAAY,CAAC,IAAa;IACxC,6CAA6C;IAC7C,IAAI,CAAC,IAAI,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE,CAAC;QACtC,MAAM,IAAI,KAAK,CAAC,wBAAwB,CAAC,CAAC;IAC5C,CAAC;IAED,8DAA8D;IAC9D,MAAM,QAAQ,GACZ,MAAM,IAAI,IAAI,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,WAAW,CAAC;IAE5E,4EAA4E;IAC5E,IAAI,YAAY,IAAI,IAAI,EAAE,CAAC;QACzB,MAAM,IAAI,KAAK,CACb,SAAS,QAAQ,2CAA2C;YAC1D,0DAA0D;YAC1D,iEAAiE,CACpE,CAAC;IACJ,CAAC;IAED,qCAAqC;IACrC,IAAI,CAAC,CAAC,MAAM,IAAI,IAAI,CAAC,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;QACvD,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC,CAAC;IACrE,CAAC;IAED,IAAI,CAAC,CAAC,aAAa,IAAI,IAAI,CAAC,IAAI,OAAO,IAAI,CAAC,WAAW,KAAK,QAAQ,EAAE,CAAC;QACrE,MAAM,IAAI,KAAK,CACb,SAAS,IAAI,CAAC,IAAI,qDAAqD,CACxE,CAAC;IACJ,CAAC;IAED,IAAI,CAAC,CAAC,MAAM,IAAI,IAAI,CAAC,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,UAAU,EAAE,CAAC;QACzD,MAAM,IAAI,KAAK,CACb,SAAS,IAAI,CAAC,IAAI,gDAAgD,CACnE,CAAC;IACJ,CAAC;IAED,IAAI,CAAC,CAAC,aAAa,IAAI,IAAI,CAAC,EAAE,CAAC;QAC7B,MAAM,IAAI,KAAK,CAAC,SAAS,IAAI,CAAC,IAAI,uCAAuC,CAAC,CAAC;IAC7E,CAAC;IAED,IAAI,CAAC,CAAC,cAAc,IAAI,IAAI,CAAC,EAAE,CAAC;QAC9B,MAAM,IAAI,KAAK,CAAC,SAAS,IAAI,CAAC,IAAI,wCAAwC,CAAC,CAAC;IAC9E,CAAC;IAED,4BAA4B;IAC5B,IAAA,yCAAe,EAAC,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;IAEnC,+DAA+D;IAC/D,IAAI,IAAI,CAAC,WAAW,EAAE,CAAC;QACrB,kBAAkB,CAAC,IAAI,CAAC,WAAW,EAAE,wBAAwB,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC;QAC3E,IAAA,6BAAoB,EAClB,IAAI,CAAC,WAAW,EAChB,wBAAwB,IAAI,CAAC,IAAI,GAAG,CACrC,CAAC;IACJ,CAAC;IAED,6DAA6D;IAC7D,IACE,UAAU,IAAI,IAAI;QAClB,IAAI,CAAC,QAAQ,KAAK,SAAS;QAC3B,IAAI,CAAC,QAAQ,KAAK,IAAI,EACtB,CAAC;QACD,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC/B,IACE,OAAO,QAAQ,KAAK,QAAQ;YAC5B,CAAC,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC;YAC3B,QAAQ,GAAG,CAAC,EACZ,CAAC;YACD,MAAM,IAAI,KAAK,CACb,sBAAsB,IAAI,CAAC,IAAI,8BAA8B,CAC9D,CAAC;QACJ,CAAC;IACH,CAAC;AACH,CAAC;AAED;;;;;;GAMG;AACH,SAAS,kBAAkB,CACzB,eAAwB,EACxB,WAAoB,EACpB,IAAY;IAEZ,IAAI,eAAe,EAAE,CAAC;QACpB,OAAO,CAAC,IAAI,CAAC,yDAAyD,CAAC,CAAC;QACxE,OAAO,eAA0C,CAAC;IACpD,CAAC;IAED,0DAA0D;IAC1D,IAAI,IAAA,yBAAgB,EAAC,WAAW,CAAC,EAAE,CAAC;QAClC,IAAI,CAAC;YACH,OAAO,IAAA,2BAAkB,EAAC,WAAW,CAA4B,CAAC;QACpE,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,OAAO,CAAC,KAAK,CACX,oBAAoB,IAAI,+BAA+B,EACvD,KAAK,CACN,CAAC;YACF,MAAM,IAAI,KAAK,CACb,oBAAoB,IAAI,iCAAiC,KAAK,EAAE,CACjE,CAAC;QACJ,CAAC;IACH,CAAC;IAED,wBAAwB;IACxB,IAAI,IAAA,4BAAmB,EAAC,WAAW,CAAC,EAAE,CAAC;QACrC,OAAO,WAAsC,CAAC;IAChD,CAAC;IAED,MAAM,IAAI,KAAK,CAAC,4BAA4B,IAAI,EAAE,CAAC,CAAC;AACtD,CAAC;AAED;;;;;GAKG;AACH,SAAgB,2BAA2B,CAAC,SAAyB;IAGnE,MAAM,EAAE,IAAI,EAAE,WAAW,EAAE,eAAe,EAAE,GAAG,SAAS,CAAC;IAEzD,0BAA0B;IAC1B,IAAA,yCAAe,EAAC,IAAI,EAAE,WAAW,CAAC,CAAC;IAEnC,0DAA0D;IAC1D,IAAI,CAAC,WAAW,IAAI,CAAC,eAAe,EAAE,CAAC;QACrC,MAAM,IAAI,KAAK,CACb,aAAa,IAAI,wEAAwE,CAC1F,CAAC;IACJ,CAAC;IAED,sDAAsD;IACtD,IAAI,WAAW,IAAI,eAAe,EAAE,CAAC;QACnC,MAAM,IAAI,KAAK,CACb,aAAa,IAAI,0GAA0G,CAC5H,CAAC;IACJ,CAAC;IAED,8DAA8D;IAC9D,IAAI,WAAW,EAAE,CAAC;QAChB,IAAA,6BAAoB,EAAC,WAAW,EAAE,6BAA6B,IAAI,GAAG,CAAC,CAAC;IAC1E,CAAC;IAED,kDAAkD;IAClD,MAAM,KAAK,GAAG,kBAAkB,CAAC,eAAe,EAAE,WAAW,EAAE,IAAI,CAAC,CAAC;IAErE,OAAO,EAAE,KAAK,EAAE,CAAC;AACnB,CAAC;AAED;;;;;;;GAOG;AACH,SAAgB,uBAAuB,CACrC,aAAqB,EACrB,QAAgB,EAChB,eAAwB,EACxB,UAAmB;IAEnB,oCAAoC;IACpC,IAAA,yCAAe,EAAC,aAAa,EAAE,WAAW,CAAC,CAAC;IAC5C,IAAA,yCAAe,EAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;IAElC,IAAI,CAAC,eAAe,EAAE,CAAC;QACrB,MAAM,IAAI,KAAK,CAAC,aAAa,aAAa,wBAAwB,CAAC,CAAC;IACtE,CAAC;IACD,IAAI,CAAC,UAAU,EAAE,CAAC;QAChB,MAAM,IAAI,KAAK,CAAC,QAAQ,QAAQ,wBAAwB,CAAC,CAAC;IAC5D,CAAC;AACH,CAAC","sourcesContent":["import type { JSONSchema7 } from \"json-schema\";\nimport type { TamboComponent, TamboTool } from \"../model/component-metadata\";\nimport {\n  assertNoRecordSchema,\n  isStandardSchema,\n  looksLikeJSONSchema,\n  schemaToJsonSchema,\n} from \"../schema\";\nimport { assertValidName } from \"./validate-component-name\";\n\n/**\n * Checks if a JSON Schema represents an object type.\n * @param schema - The JSON Schema to check\n * @returns True if the schema is an object type\n */\nfunction isObjectSchema(schema: JSONSchema7): boolean {\n  return schema.type === \"object\" || schema.properties !== undefined;\n}\n\n/**\n * Validates that a schema is an object type.\n * Throws an error if it's not.\n * @param schema - The schema to validate (Standard Schema or JSON Schema)\n * @param context - Description of where the schema is used (for error messages)\n */\nfunction assertObjectSchema(schema: unknown, context: string): void {\n  let jsonSchema: JSONSchema7;\n\n  if (isStandardSchema(schema)) {\n    try {\n      jsonSchema = schemaToJsonSchema(schema);\n    } catch {\n      // If conversion fails, we can't validate - let it fail later\n      return;\n    }\n  } else if (looksLikeJSONSchema(schema)) {\n    jsonSchema = schema;\n  } else {\n    // Unknown schema type, can't validate\n    return;\n  }\n\n  if (!isObjectSchema(jsonSchema)) {\n    throw new Error(\n      `${context} must be an object schema (e.g., z.object({...})). ` +\n        `Received type: \"${jsonSchema.type ?? \"unknown\"}\". ` +\n        `Tool parameters are passed as a single object argument.`,\n    );\n  }\n}\n\n/**\n * Validates a tool before registration.\n * Throws an error if the tool is invalid.\n * @param tool - The tool to validate\n */\nexport function validateTool(tool: unknown): asserts tool is TamboTool {\n  // Basic runtime type checks before narrowing\n  if (!tool || typeof tool !== \"object\") {\n    throw new Error(\"Tool must be an object\");\n  }\n\n  // Extract name for error messages (before we know it's valid)\n  const toolName =\n    \"name\" in tool && typeof tool.name === \"string\" ? tool.name : \"<unknown>\";\n\n  // Check for deprecated toolSchema - throw error with migration instructions\n  if (\"toolSchema\" in tool) {\n    throw new Error(\n      `Tool \"${toolName}\" uses deprecated \"toolSchema\" property. ` +\n        `Migrate to \"inputSchema\" and \"outputSchema\" properties. ` +\n        `See migration guide: https://tambo.ai/docs/migration/toolschema`,\n    );\n  }\n\n  // Validate required properties exist\n  if (!(\"name\" in tool) || typeof tool.name !== \"string\") {\n    throw new Error(\"Tool must have a 'name' property of type string\");\n  }\n\n  if (!(\"description\" in tool) || typeof tool.description !== \"string\") {\n    throw new Error(\n      `Tool \"${tool.name}\" must have a 'description' property of type string`,\n    );\n  }\n\n  if (!(\"tool\" in tool) || typeof tool.tool !== \"function\") {\n    throw new Error(\n      `Tool \"${tool.name}\" must have a 'tool' property of type function`,\n    );\n  }\n\n  if (!(\"inputSchema\" in tool)) {\n    throw new Error(`Tool \"${tool.name}\" must have an 'inputSchema' property`);\n  }\n\n  if (!(\"outputSchema\" in tool)) {\n    throw new Error(`Tool \"${tool.name}\" must have an 'outputSchema' property`);\n  }\n\n  // Validate tool name format\n  assertValidName(tool.name, \"tool\");\n\n  // Validate tool schemas - inputSchema must be an object schema\n  if (tool.inputSchema) {\n    assertObjectSchema(tool.inputSchema, `inputSchema of tool \"${tool.name}\"`);\n    assertNoRecordSchema(\n      tool.inputSchema,\n      `inputSchema of tool \"${tool.name}\"`,\n    );\n  }\n\n  // Validate maxCalls if provided - must be a positive integer\n  if (\n    \"maxCalls\" in tool &&\n    tool.maxCalls !== undefined &&\n    tool.maxCalls !== null\n  ) {\n    const maxCalls = tool.maxCalls;\n    if (\n      typeof maxCalls !== \"number\" ||\n      !Number.isInteger(maxCalls) ||\n      maxCalls < 0\n    ) {\n      throw new Error(\n        `maxCalls for tool \"${tool.name}\" must be a positive integer`,\n      );\n    }\n  }\n}\n\n/**\n * Converts a props schema to a serialized JSON Schema format.\n * @param propsDefinition - Deprecated: legacy props definition (will log warning)\n * @param propsSchema - The props schema (Standard Schema or JSON Schema)\n * @param name - Component/tool name for error messages\n * @returns Serialized JSON Schema object\n */\nfunction getSerializedProps(\n  propsDefinition: unknown,\n  propsSchema: unknown,\n  name: string,\n): Record<string, unknown> {\n  if (propsDefinition) {\n    console.warn(`propsDefinition is deprecated. Use propsSchema instead.`);\n    return propsDefinition as Record<string, unknown>;\n  }\n\n  // Check for Standard Schema (Zod, Valibot, ArkType, etc.)\n  if (isStandardSchema(propsSchema)) {\n    try {\n      return schemaToJsonSchema(propsSchema) as Record<string, unknown>;\n    } catch (error) {\n      console.error(\n        `Error converting ${name} props schema to JSON Schema:`,\n        error,\n      );\n      throw new Error(\n        `Error converting ${name} props schema to JSON Schema: ${error}`,\n      );\n    }\n  }\n\n  // Check for JSON Schema\n  if (looksLikeJSONSchema(propsSchema)) {\n    return propsSchema as Record<string, unknown>;\n  }\n\n  throw new Error(`Invalid props schema for ${name}`);\n}\n\n/**\n * Validates a component and prepares its props for registration.\n * Throws an error if the component is invalid.\n * @param component - The component to validate and prepare\n * @returns Object containing the serialized props\n */\nexport function validateAndPrepareComponent(component: TamboComponent): {\n  props: Record<string, unknown>;\n} {\n  const { name, propsSchema, propsDefinition } = component;\n\n  // Validate component name\n  assertValidName(name, \"component\");\n\n  // Validate that at least one props definition is provided\n  if (!propsSchema && !propsDefinition) {\n    throw new Error(\n      `Component ${name} must have either propsSchema (recommended) or propsDefinition defined`,\n    );\n  }\n\n  // Validate that only one props definition is provided\n  if (propsSchema && propsDefinition) {\n    throw new Error(\n      `Component ${name} cannot have both propsSchema and propsDefinition defined. Use only one. We recommend using propsSchema.`,\n    );\n  }\n\n  // Validate that the propsSchema does not include record types\n  if (propsSchema) {\n    assertNoRecordSchema(propsSchema, `propsSchema of component \"${name}\"`);\n  }\n\n  // Convert propsSchema to JSON Schema if it exists\n  const props = getSerializedProps(propsDefinition, propsSchema, name);\n\n  return { props };\n}\n\n/**\n * Validates a tool association between a component and tool.\n * Throws an error if the association is invalid.\n * @param componentName - The component name\n * @param toolName - The tool name\n * @param componentExists - Whether the component exists in the registry\n * @param toolExists - Whether the tool exists in the registry\n */\nexport function validateToolAssociation(\n  componentName: string,\n  toolName: string,\n  componentExists: boolean,\n  toolExists: boolean,\n): void {\n  // Validate component and tool names\n  assertValidName(componentName, \"component\");\n  assertValidName(toolName, \"tool\");\n\n  if (!componentExists) {\n    throw new Error(`Component ${componentName} not found in registry`);\n  }\n  if (!toolExists) {\n    throw new Error(`Tool ${toolName} not found in registry`);\n  }\n}\n"]}