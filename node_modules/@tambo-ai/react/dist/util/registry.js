"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defineTool = exports.mapTamboToolToContextTool = exports.getComponentFromRegistry = exports.convertPropsToJsonSchema = exports.getUnassociatedTools = exports.getAvailableComponents = void 0;
const schema_1 = require("../schema");
/**
 * Get all the available components from the component registry
 * @param componentRegistry - The component registry
 * @param toolRegistry - The tool registry
 * @param toolAssociations - The tool associations
 * @returns The available components
 */
const getAvailableComponents = (componentRegistry, toolRegistry, toolAssociations) => {
    const availableComponents = [];
    for (const [name, componentEntry] of Object.entries(componentRegistry)) {
        const associatedToolNames = toolAssociations[name] || [];
        const contextTools = associatedToolNames
            .map((toolName) => {
            const tool = toolRegistry[toolName];
            if (!tool)
                return null;
            return (0, exports.mapTamboToolToContextTool)(tool);
        })
            .filter((tool) => tool !== null);
        availableComponents.push({
            name: componentEntry.name,
            description: componentEntry.description,
            props: componentEntry.props,
            contextTools,
        });
    }
    return availableComponents;
};
exports.getAvailableComponents = getAvailableComponents;
/**
 * Get tools from tool registry that are not associated with any component
 * @param toolRegistry - The tool registry
 * @param toolAssociations - The tool associations
 * @returns The tools that are not associated with any component
 */
const getUnassociatedTools = (toolRegistry, toolAssociations) => {
    return Object.values(toolRegistry).filter((tool) => {
        // Check if the tool's name appears in any of the tool association arrays
        return !Object.values(toolAssociations).flat().includes(tool.name);
    });
};
exports.getUnassociatedTools = getUnassociatedTools;
/**
 * Helper function to convert component props from Standard Schema or JSON Schema
 * @param component - The component to convert
 * @returns The converted props as JSON Schema
 */
const convertPropsToJsonSchema = (component) => {
    if (!component.props) {
        return component.props;
    }
    // Check if props is a Standard Schema (Zod, Valibot, ArkType, etc.)
    if ((0, schema_1.isStandardSchema)(component.props)) {
        return (0, schema_1.schemaToJsonSchema)(component.props);
    }
    // Already JSON Schema or unknown format - return as-is
    return component.props;
};
exports.convertPropsToJsonSchema = convertPropsToJsonSchema;
/**
 * Get a component by name from the component registry
 * @param componentName - The name of the component to get
 * @param componentRegistry - The component registry
 * @returns The component registration information
 */
const getComponentFromRegistry = (componentName, componentRegistry) => {
    const componentEntry = componentRegistry[componentName];
    if (!componentEntry) {
        throw new Error(`Tambo tried to use Component ${componentName}, but it was not found.`);
    }
    return componentEntry;
};
exports.getComponentFromRegistry = getComponentFromRegistry;
/**
 * Map a Tambo tool to a context tool
 * @param tool - The tool to map
 * @returns The context tool
 */
const mapTamboToolToContextTool = (tool) => {
    const parameters = (0, schema_1.getParametersFromToolSchema)(tool);
    return {
        name: tool.name,
        description: tool.description,
        parameters,
        ...("maxCalls" in tool && tool.maxCalls !== undefined
            ? { maxCalls: tool.maxCalls }
            : {}),
        ...("annotations" in tool && tool.annotations !== undefined
            ? { annotations: tool.annotations }
            : {}),
    };
};
exports.mapTamboToolToContextTool = mapTamboToolToContextTool;
/**
 * Provides type safety for defining a Tambo Tool.
 *
 * Tambo uses the [standard-schema.dev](https://standard-schema.dev) spec which means you can use any Standard Schema
 * compliant validator (Zod, Valibot, ArkType, etc.). This ensures the tool function args and output types are correctly
 * inferred from the provided schemas.
 * @example
 * ```typescript
 * import { z } from "zod/v4";
 *
 * const myTool = defineTamboTool({
 *   // ...
 * });
 * ```
 * @param tool The tool definition to register
 * @returns The registered tool definition
 */
const defineTool = (tool) => {
    if ("toolSchema" in tool) {
        return tool;
    }
    tool.inputSchema ??= { type: "object", properties: {}, required: [] };
    tool.outputSchema ??= { type: "object", properties: {}, required: [] };
    return tool;
};
exports.defineTool = defineTool;
//# sourceMappingURL=registry.js.map