"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const useCurrentMessage = __importStar(require("../hooks/use-current-message"));
const generate_component_1 = require("./generate-component");
// Track calls to wrapWithTamboMessageProvider
let wrapWithTamboMessageProviderSpy;
beforeEach(() => {
    wrapWithTamboMessageProviderSpy = jest.spyOn(useCurrentMessage, "wrapWithTamboMessageProvider");
});
afterEach(() => {
    wrapWithTamboMessageProviderSpy.mockRestore();
});
// Simple test component
const TestComponent = ({ title, count, }) => (react_1.default.createElement("div", { "data-testid": "test-component" },
    react_1.default.createElement("span", null, title),
    count !== undefined && react_1.default.createElement("span", null, count)));
// Create a mock Standard Schema for testing
const createMockStandardSchema = (validate) => ({
    "~standard": {
        version: 1,
        vendor: "test",
        validate: (data) => ({ value: validate(data) }),
    },
});
describe("renderComponentIntoMessage", () => {
    const baseMessage = {
        id: "msg-123",
        threadId: "thread-456",
        role: "assistant",
        content: [{ type: "text", text: "Here is your component" }],
        createdAt: "2024-01-01T00:00:00Z",
        componentState: {},
        component: {
            componentName: "TestComponent",
            props: { title: "Hello" },
            componentState: {},
            message: "",
        },
    };
    const baseRegistry = {
        TestComponent: {
            name: "TestComponent",
            description: "A test component",
            component: TestComponent,
            props: { type: "object" }, // JSON Schema
            contextTools: [],
        },
    };
    describe("component lookup", () => {
        it("throws error when component has no componentName", () => {
            const messageWithoutComponentName = {
                ...baseMessage,
                component: {
                    componentName: "",
                    props: {},
                    componentState: {},
                    message: "",
                },
            };
            expect(() => (0, generate_component_1.renderComponentIntoMessage)(messageWithoutComponentName, baseRegistry)).toThrow("Component not found");
        });
        it("throws error when component is null", () => {
            const messageWithNullComponent = {
                ...baseMessage,
                component: null,
            };
            expect(() => (0, generate_component_1.renderComponentIntoMessage)(messageWithNullComponent, baseRegistry)).toThrow();
        });
        it("throws error when componentName not in registry", () => {
            const messageWithUnknownComponent = {
                ...baseMessage,
                component: {
                    componentName: "UnknownComponent",
                    props: {},
                    componentState: {},
                    message: "",
                },
            };
            expect(() => (0, generate_component_1.renderComponentIntoMessage)(messageWithUnknownComponent, baseRegistry)).toThrow("Tambo tried to use Component UnknownComponent, but it was not found");
        });
        it("successfully finds and renders registered component", () => {
            const result = (0, generate_component_1.renderComponentIntoMessage)(baseMessage, baseRegistry);
            expect(result.component?.componentName).toBe("TestComponent");
            expect(result.renderedComponent).toBeDefined();
        });
    });
    describe("props handling", () => {
        it("passes props to component from message", () => {
            const messageWithProps = {
                ...baseMessage,
                component: {
                    componentName: "TestComponent",
                    props: { title: "Test Title", count: 42 },
                    componentState: {},
                    message: "",
                },
            };
            const result = (0, generate_component_1.renderComponentIntoMessage)(messageWithProps, baseRegistry);
            expect(result.component?.props).toEqual({
                title: "Test Title",
                count: 42,
            });
        });
        it("handles empty props object", () => {
            const messageWithEmptyProps = {
                ...baseMessage,
                component: {
                    componentName: "TestComponent",
                    props: {},
                    componentState: {},
                    message: "",
                },
            };
            const result = (0, generate_component_1.renderComponentIntoMessage)(messageWithEmptyProps, baseRegistry);
            expect(result.component?.props).toEqual({});
        });
        it("handles nested object props", () => {
            const messageWithNestedProps = {
                ...baseMessage,
                component: {
                    componentName: "TestComponent",
                    props: {
                        title: "Nested",
                        config: { nested: { deeply: { value: 123 } } },
                    },
                    componentState: {},
                    message: "",
                },
            };
            const result = (0, generate_component_1.renderComponentIntoMessage)(messageWithNestedProps, baseRegistry);
            expect(result.component?.props).toEqual({
                title: "Nested",
                config: { nested: { deeply: { value: 123 } } },
            });
        });
        it("handles array props", () => {
            const messageWithArrayProps = {
                ...baseMessage,
                component: {
                    componentName: "TestComponent",
                    props: { title: "Array Test", items: [1, 2, 3] },
                    componentState: {},
                    message: "",
                },
            };
            const result = (0, generate_component_1.renderComponentIntoMessage)(messageWithArrayProps, baseRegistry);
            expect(result.component?.props).toEqual({
                title: "Array Test",
                items: [1, 2, 3],
            });
        });
    });
    describe("Standard Schema validation", () => {
        it("validates props through Standard Schema when present", () => {
            const mockValidate = jest.fn((data) => ({
                ...data,
                validated: true,
            }));
            const registryWithStandardSchema = {
                TestComponent: {
                    name: "TestComponent",
                    description: "A test component",
                    component: TestComponent,
                    props: createMockStandardSchema(mockValidate),
                    contextTools: [],
                },
            };
            const result = (0, generate_component_1.renderComponentIntoMessage)(baseMessage, registryWithStandardSchema);
            expect(mockValidate).toHaveBeenCalled();
            // Standard Schema validate returns { value: T }, we extract the value
            expect(result.component?.props).toEqual({
                title: "Hello",
                validated: true,
            });
        });
        it("throws error when validation returns issues", () => {
            const registryWithFailingSchema = {
                TestComponent: {
                    name: "TestComponent",
                    description: "A test component",
                    component: TestComponent,
                    props: {
                        "~standard": {
                            version: 1,
                            vendor: "test",
                            validate: () => ({
                                issues: [{ message: "title is required", path: ["title"] }],
                            }),
                        },
                    },
                    contextTools: [],
                },
            };
            expect(() => (0, generate_component_1.renderComponentIntoMessage)(baseMessage, registryWithFailingSchema)).toThrow("Component props validation failed: title is required");
        });
        it("throws error when validation returns async promise", () => {
            const registryWithAsyncSchema = {
                TestComponent: {
                    name: "TestComponent",
                    description: "A test component",
                    component: TestComponent,
                    props: {
                        "~standard": {
                            version: 1,
                            vendor: "test",
                            validate: async () => await Promise.resolve({ value: {} }),
                        },
                    },
                    contextTools: [],
                },
            };
            expect(() => (0, generate_component_1.renderComponentIntoMessage)(baseMessage, registryWithAsyncSchema)).toThrow("Async schema validation is not supported for component props");
        });
        it("uses raw props when props is JSON Schema (not Standard Schema)", () => {
            const jsonSchemaRegistry = {
                TestComponent: {
                    name: "TestComponent",
                    description: "A test component",
                    component: TestComponent,
                    props: {
                        type: "object",
                        properties: {
                            title: { type: "string" },
                        },
                    },
                    contextTools: [],
                },
            };
            const result = (0, generate_component_1.renderComponentIntoMessage)(baseMessage, jsonSchemaRegistry);
            // Should pass through without validation
            expect(result.component?.props).toEqual({ title: "Hello" });
        });
    });
    describe("message structure", () => {
        it("preserves original message properties", () => {
            const result = (0, generate_component_1.renderComponentIntoMessage)(baseMessage, baseRegistry);
            expect(result.id).toBe("msg-123");
            expect(result.threadId).toBe("thread-456");
            expect(result.role).toBe("assistant");
            expect(result.content).toEqual([
                { type: "text", text: "Here is your component" },
            ]);
            expect(result.createdAt).toBe("2024-01-01T00:00:00Z");
        });
        it("includes renderedComponent in result", () => {
            const result = (0, generate_component_1.renderComponentIntoMessage)(baseMessage, baseRegistry);
            expect(result.renderedComponent).toBeDefined();
            expect(react_1.default.isValidElement(result.renderedComponent)).toBe(true);
        });
        it("wraps component with TamboMessageProvider", () => {
            (0, generate_component_1.renderComponentIntoMessage)(baseMessage, baseRegistry);
            expect(wrapWithTamboMessageProviderSpy).toHaveBeenCalled();
            // Check that the message passed to the wrapper has the correct structure
            const callArgs = wrapWithTamboMessageProviderSpy.mock.calls[0];
            expect(callArgs[1].id).toBe("msg-123");
        });
    });
    describe("edge cases", () => {
        it("handles special characters in props", () => {
            const messageWithSpecialChars = {
                ...baseMessage,
                component: {
                    componentName: "TestComponent",
                    props: { title: "Hello <script>alert('xss')</script>" },
                    componentState: {},
                    message: "",
                },
            };
            const result = (0, generate_component_1.renderComponentIntoMessage)(messageWithSpecialChars, baseRegistry);
            expect(result.component?.props.title).toBe("Hello <script>alert('xss')</script>");
        });
        it("handles unicode in props", () => {
            const messageWithUnicode = {
                ...baseMessage,
                component: {
                    componentName: "TestComponent",
                    props: { title: "Hello \u4e16\u754c" }, // "Hello 世界"
                    componentState: {},
                    message: "",
                },
            };
            const result = (0, generate_component_1.renderComponentIntoMessage)(messageWithUnicode, baseRegistry);
            expect(result.component?.props.title).toBe("Hello \u4e16\u754c");
        });
        it("handles null values in props", () => {
            const messageWithNullProp = {
                ...baseMessage,
                component: {
                    componentName: "TestComponent",
                    props: { title: "Test", nullValue: null },
                    componentState: {},
                    message: "",
                },
            };
            const result = (0, generate_component_1.renderComponentIntoMessage)(messageWithNullProp, baseRegistry);
            expect(result.component?.props).toEqual({
                title: "Test",
                nullValue: null,
            });
        });
    });
});
//# sourceMappingURL=generate-component.test.js.map