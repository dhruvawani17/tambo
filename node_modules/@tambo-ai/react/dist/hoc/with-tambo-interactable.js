"use strict";
"use client";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.withTamboInteractable = withTamboInteractable;
const react_1 = __importStar(require("react"));
const use_current_message_1 = require("../hooks/use-current-message");
const tambo_interactable_provider_1 = require("../providers/tambo-interactable-provider");
/**
 * Higher-Order Component that makes any component interactable by tambo.
 * @param WrappedComponent - The component to make interactable
 * @param config - Configuration for the interactable component
 * @returns A new component that is automatically registered as interactable
 * @example
 * ```tsx
 * const MyNote: React.FC<{ title: string; content: string }> = ({ title, content }) => {
 *   const [isPinned, setIsPinned] = useTamboComponentState("isPinned", false);
 *   return (
 *     <div style={{ border: isPinned ? "2px solid gold" : "1px solid gray", order: isPinned ? -1 : 0 }}>
 *       <h2>{title}</h2>
 *       <p>{content}</p>
 *     </div>
 *   );
 * };
 *
 * const MyInteractableNote = withTamboInteractable(MyNote, {
 *   componentName: "MyNote",
 *   description: "A note component",
 *   propsSchema: z.object({
 *     title: z.string(),
 *     content: z.string(),
 *   }),
 *  stateSchema: z.object({
 *    isPinned: z.boolean(),
 *  }),
 * });
 *
 * // Usage
 * <MyInteractableNote title="My Note" content="This is my note" />
 * ```
 */
function withTamboInteractable(WrappedComponent, config) {
    const displayName = WrappedComponent.displayName ?? WrappedComponent.name ?? "Component";
    const TamboInteractableWrapper = (props) => {
        const { addInteractableComponent, updateInteractableComponentProps, getInteractableComponent, } = (0, tambo_interactable_provider_1.useTamboInteractable)();
        const [interactableId, setInteractableId] = (0, react_1.useState)(null);
        const isInitialized = (0, react_1.useRef)(false);
        const lastSerializedProps = (0, react_1.useRef)({});
        // Extract interactable-specific props from component props
        const { interactableId: _providedId, // Reserved for future use
        onInteractableReady, onPropsUpdate, ...componentProps } = props;
        // Get the current interactable component to track prop updates
        const currentInteractable = interactableId
            ? getInteractableComponent(interactableId)
            : null;
        // Use the props from the interactable component if available, otherwise use the passed props
        // We need to be careful not to create a loop, so we only use stored props if they're different from passed props
        const effectiveProps = currentInteractable?.props ?? componentProps;
        // Memoize the registration function
        const registerComponent = (0, react_1.useCallback)(() => {
            if (!isInitialized.current) {
                const id = addInteractableComponent({
                    name: config.componentName,
                    description: config.description,
                    component: WrappedComponent,
                    props: componentProps,
                    propsSchema: config.propsSchema,
                    stateSchema: config.stateSchema,
                });
                setInteractableId(id);
                onInteractableReady?.(id);
                isInitialized.current = true;
            }
        }, [addInteractableComponent, componentProps, onInteractableReady]);
        // Register the component as interactable on mount (only once)
        (0, react_1.useEffect)(() => {
            registerComponent();
        }, [registerComponent]);
        // Update the interactable component when props change from parent
        (0, react_1.useEffect)(() => {
            if (interactableId && isInitialized.current) {
                // Only update if the props are different from what we last sent
                const lastPropsString = JSON.stringify(lastSerializedProps.current);
                const currentPropsString = JSON.stringify(componentProps);
                if (lastPropsString !== currentPropsString) {
                    updateInteractableComponentProps(interactableId, componentProps);
                    onPropsUpdate?.(componentProps);
                    lastSerializedProps.current = componentProps;
                }
            }
        }, [
            interactableId,
            componentProps,
            updateInteractableComponentProps,
            onPropsUpdate,
        ]);
        // If the interactable ID is not yet set, render the component without provider
        if (!interactableId) {
            return react_1.default.createElement(WrappedComponent, { ...effectiveProps });
        }
        // Create a minimal message with interactable metadata
        // This allows useTamboCurrentComponent to work with standalone interactable components
        const minimalMessage = {
            id: interactableId,
            role: "assistant",
            content: [],
            threadId: "",
            createdAt: new Date().toISOString(),
            component: {
                componentName: config.componentName,
                componentState: {},
                message: "",
                props: effectiveProps,
            },
            componentState: {},
        };
        // Wrap with TamboMessageProvider including interactable metadata
        return (react_1.default.createElement(use_current_message_1.TamboMessageProvider, { message: minimalMessage, interactableMetadata: {
                id: interactableId,
                componentName: config.componentName,
                description: config.description,
            } },
            react_1.default.createElement(WrappedComponent, { ...effectiveProps })));
    };
    TamboInteractableWrapper.displayName = `withTamboInteractable(${displayName})`;
    return TamboInteractableWrapper;
}
//# sourceMappingURL=with-tambo-interactable.js.map