"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_sdk_1 = __importDefault(require("@tambo-ai/typescript-sdk"));
const react_query_1 = require("@tanstack/react-query");
const react_1 = require("@testing-library/react");
const react_2 = __importDefault(require("react"));
const zod_1 = require("zod");
const tambo_client_provider_1 = require("../../providers/tambo-client-provider");
const tambo_registry_provider_1 = require("../../providers/tambo-registry-provider");
const tambo_context_helpers_provider_1 = require("../../providers/tambo-context-helpers-provider");
const tambo_v1_stream_context_1 = require("./tambo-v1-stream-context");
const tambo_v1_provider_1 = require("./tambo-v1-provider");
// Mock the client provider to capture the apiKey
jest.mock("../../providers/tambo-client-provider", () => ({
    useTamboClient: jest.fn(),
    useTamboQueryClient: jest.fn(() => new react_query_1.QueryClient()),
    TamboClientProvider: ({ children }) => children,
}));
// Mock useTamboV1SendMessage to avoid complex dependencies
jest.mock("../hooks/use-tambo-v1-send-message", () => ({
    useTamboV1SendMessage: jest.fn(() => ({
        mutateAsync: jest.fn(),
        mutate: jest.fn(),
        isPending: false,
        isError: false,
        error: null,
        isSuccess: false,
        reset: jest.fn(),
    })),
}));
describe("TamboV1Provider", () => {
    const mockFetch = async (..._args) => {
        throw new Error("fetch not implemented");
    };
    const mockClient = new typescript_sdk_1.default({
        apiKey: "test-api-key",
        fetch: mockFetch,
    });
    beforeEach(() => {
        jest.mocked(tambo_client_provider_1.useTamboClient).mockReturnValue(mockClient);
    });
    it("provides access to registry context", () => {
        const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_provider_1.TamboV1Provider, { apiKey: "test-api-key" }, children));
        const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
        expect(result.current.componentList).toBeDefined();
        expect(result.current.toolRegistry).toBeDefined();
        expect(typeof result.current.registerComponent).toBe("function");
        expect(typeof result.current.registerTool).toBe("function");
    });
    it("provides access to stream context", () => {
        const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_provider_1.TamboV1Provider, { apiKey: "test-api-key" }, children));
        const { result } = (0, react_1.renderHook)(() => (0, tambo_v1_stream_context_1.useStreamState)(), { wrapper });
        expect(result.current.threadMap).toBeDefined();
        expect(result.current.currentThreadId).toBeNull();
    });
    it("manages threads via useThreadManagement", () => {
        const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_provider_1.TamboV1Provider, { apiKey: "test-api-key" }, children));
        const { result } = (0, react_1.renderHook)(() => ({
            state: (0, tambo_v1_stream_context_1.useStreamState)(),
            management: (0, tambo_v1_stream_context_1.useThreadManagement)(),
        }), { wrapper });
        // Initially no thread
        expect(result.current.state.currentThreadId).toBeNull();
        // Initialize and switch to a thread
        (0, react_1.act)(() => {
            result.current.management.initThread("thread_123");
            result.current.management.switchThread("thread_123");
        });
        expect(result.current.state.currentThreadId).toBe("thread_123");
        expect(result.current.state.threadMap.thread_123).toBeDefined();
    });
    it("provides access to query client", () => {
        const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_provider_1.TamboV1Provider, { apiKey: "test-api-key" }, children));
        const { result } = (0, react_1.renderHook)(() => (0, react_query_1.useQueryClient)(), { wrapper });
        expect(result.current).toBeInstanceOf(react_query_1.QueryClient);
    });
    it("uses custom query client when provided", () => {
        const customClient = new react_query_1.QueryClient();
        const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_provider_1.TamboV1Provider, { apiKey: "test-api-key", queryClient: customClient }, children));
        const { result } = (0, react_1.renderHook)(() => (0, react_query_1.useQueryClient)(), { wrapper });
        expect(result.current).toBe(customClient);
    });
    it("registers components when provided", () => {
        const TestComponent = () => react_2.default.createElement("div", null, "Test");
        const propsSchema = zod_1.z.object({
            title: zod_1.z.string().describe("The title"),
        });
        const components = [
            {
                name: "TestComponent",
                description: "A test component",
                component: TestComponent,
                propsSchema,
            },
        ];
        const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_provider_1.TamboV1Provider, { apiKey: "test-api-key", components: components }, children));
        const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
        expect(result.current.componentList.TestComponent).toBeDefined();
        expect(result.current.componentList.TestComponent.name).toBe("TestComponent");
    });
    it("registers tools when provided", () => {
        const inputSchema = zod_1.z.object({
            query: zod_1.z.string().describe("Search query"),
        });
        const outputSchema = zod_1.z.string().describe("Result string");
        const tools = [
            {
                name: "testTool",
                description: "A test tool",
                tool: async () => "result",
                inputSchema,
                outputSchema,
            },
        ];
        const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_provider_1.TamboV1Provider, { apiKey: "test-api-key", tools: tools }, children));
        const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
        expect(result.current.toolRegistry.testTool).toBeDefined();
        expect(result.current.toolRegistry.testTool.name).toBe("testTool");
    });
    it("registers MCP servers when provided", () => {
        const mcpServers = [
            { url: "https://mcp.example.com", name: "Example MCP" },
        ];
        const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_provider_1.TamboV1Provider, { apiKey: "test-api-key", mcpServers: mcpServers }, children));
        const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
        expect(result.current.mcpServerInfos).toHaveLength(1);
        expect(result.current.mcpServerInfos[0].url).toBe("https://mcp.example.com");
    });
    it("provides onCallUnregisteredTool to registry", () => {
        const onCallUnregisteredTool = jest
            .fn()
            .mockResolvedValue("fallback result");
        const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_provider_1.TamboV1Provider, { apiKey: "test-api-key", onCallUnregisteredTool: onCallUnregisteredTool }, children));
        const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
        expect(result.current.onCallUnregisteredTool).toBe(onCallUnregisteredTool);
    });
    it("registers static resources when provided", () => {
        const resources = [
            {
                uri: "resource://test/example",
                name: "Test Resource",
                description: "A test resource",
                mimeType: "text/plain",
            },
        ];
        const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_provider_1.TamboV1Provider, { apiKey: "test-api-key", resources: resources }, children));
        const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
        expect(result.current.resources).toHaveLength(1);
        expect(result.current.resources[0].uri).toBe("resource://test/example");
        expect(result.current.resources[0].name).toBe("Test Resource");
    });
    it("registers resource source when listResources and getResource provided", () => {
        const listResources = jest.fn().mockResolvedValue({ resources: [] });
        const getResource = jest.fn().mockResolvedValue({ contents: [] });
        const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_provider_1.TamboV1Provider, { apiKey: "test-api-key", listResources: listResources, getResource: getResource }, children));
        const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
        expect(result.current.resourceSource).toBeDefined();
        expect(result.current.resourceSource?.listResources).toBe(listResources);
        expect(result.current.resourceSource?.getResource).toBe(getResource);
    });
    it("provides userKey via useTamboV1Config", () => {
        const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_provider_1.TamboV1Provider, { apiKey: "test-api-key", userKey: "my-user-key" }, children));
        const { result } = (0, react_1.renderHook)(() => (0, tambo_v1_provider_1.useTamboV1Config)(), { wrapper });
        expect(result.current.userKey).toBe("my-user-key");
    });
    it("returns undefined userKey from useTamboV1Config when no userKey provided", () => {
        const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_provider_1.TamboV1Provider, { apiKey: "test-api-key" }, children));
        const { result } = (0, react_1.renderHook)(() => (0, tambo_v1_provider_1.useTamboV1Config)(), { wrapper });
        expect(result.current.userKey).toBeUndefined();
    });
    it("provides context helpers via useTamboContextHelpers hook", async () => {
        const contextHelpers = {
            getUserName: () => "Test User",
            getCurrentTime: () => new Date().toISOString(),
        };
        const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_provider_1.TamboV1Provider, { apiKey: "test-api-key", contextHelpers: contextHelpers }, children));
        const { result, rerender } = (0, react_1.renderHook)(() => (0, tambo_context_helpers_provider_1.useTamboContextHelpers)(), {
            wrapper,
        });
        // Helpers are registered via useEffect, so we need to trigger a rerender
        await (0, react_1.act)(async () => {
            rerender();
        });
        const helpers = result.current.getContextHelpers();
        expect(helpers.getUserName).toBe(contextHelpers.getUserName);
        expect(helpers.getCurrentTime).toBe(contextHelpers.getCurrentTime);
    });
    it("returns empty contextHelpers when none provided", async () => {
        const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_provider_1.TamboV1Provider, { apiKey: "test-api-key" }, children));
        const { result } = (0, react_1.renderHook)(() => (0, tambo_context_helpers_provider_1.useTamboContextHelpers)(), { wrapper });
        const helpers = result.current.getContextHelpers();
        expect(Object.keys(helpers)).toHaveLength(0);
    });
});
//# sourceMappingURL=tambo-v1-provider.test.js.map