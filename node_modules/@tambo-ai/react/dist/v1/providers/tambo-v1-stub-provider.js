"use strict";
"use client";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.TamboV1StubProvider = TamboV1StubProvider;
const react_query_1 = require("@tanstack/react-query");
const react_1 = __importStar(require("react"));
const tambo_client_provider_1 = require("../../providers/tambo-client-provider");
const tambo_registry_provider_1 = require("../../providers/tambo-registry-provider");
const tambo_v1_provider_1 = require("./tambo-v1-provider");
const tambo_v1_stream_context_1 = require("./tambo-v1-stream-context");
const tambo_v1_thread_input_provider_1 = require("./tambo-v1-thread-input-provider");
/**
 * Creates a default TamboV1Thread from messages or returns the full thread.
 * @returns A normalized thread object
 */
function normalizeThread(threadData, threadId) {
    if (!threadData) {
        return {
            id: threadId,
            messages: [],
            status: "idle",
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
        };
    }
    if ("id" in threadData && "status" in threadData) {
        return threadData;
    }
    return {
        id: threadId,
        messages: threadData.messages,
        status: "idle",
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
    };
}
/**
 * TamboV1StubProvider provides mock implementations of all v1 contexts
 * for testing components that use Tambo hooks.
 *
 * All operations are no-ops by default, returning stub data.
 * Override specific behaviors via props as needed for testing.
 * Stream state is derived once from props and is not updated by thread management.
 * @returns A provider wrapper suitable for tests
 */
function TamboV1StubProvider({ children, thread: threadData, threadId: providedThreadId, components = [], tools = [], userKey, inputValue: initialInputValue = "", isStreaming = false, onSubmit, onSetValue, onStartNewThread, onSwitchThread, onInitThread, }) {
    // Determine thread ID
    const threadId = providedThreadId ??
        (threadData && "id" in threadData ? threadData.id : "stub_thread");
    // Normalize thread data
    const thread = normalizeThread(threadData, threadId);
    // Create stub QueryClient
    const queryClient = (0, react_1.useMemo)(() => new react_query_1.QueryClient({
        defaultOptions: {
            queries: { retry: false },
            mutations: { retry: false },
        },
    }), []);
    // Create stub client
    const stubClient = (0, react_1.useMemo)(() => ({}), []);
    // Build component registry
    const componentList = (0, react_1.useMemo)(() => {
        const list = {};
        for (const component of components) {
            list[component.name] = {
                component: component.component,
                loadingComponent: component.loadingComponent,
                name: component.name,
                description: component.description,
                props: component.propsDefinition ?? {},
                contextTools: [],
            };
        }
        return list;
    }, [components]);
    // Build tool registry
    const toolRegistry = (0, react_1.useMemo)(() => {
        return tools.reduce((acc, tool) => {
            acc[tool.name] = tool;
            return acc;
        }, {});
    }, [tools]);
    // Stream state
    const streamState = (0, react_1.useMemo)(() => {
        const threadState = {
            thread,
            streaming: {
                status: isStreaming ? "streaming" : "idle",
            },
            accumulatingToolArgs: new Map(),
        };
        return {
            threadMap: { [threadId]: threadState },
            currentThreadId: threadId,
        };
    }, [thread, threadId, isStreaming]);
    // Stream dispatch (no-op)
    const streamDispatch = (0, react_1.useMemo)(() => () => { }, []);
    // Thread management
    const threadManagement = (0, react_1.useMemo)(() => ({
        initThread: onInitThread ?? (() => { }),
        switchThread: onSwitchThread ?? (() => { }),
        startNewThread: onStartNewThread ??
            (() => {
                const newId = `stub_${crypto.randomUUID()}`;
                return newId;
            }),
    }), [onInitThread, onSwitchThread, onStartNewThread]);
    // Config context
    const config = (0, react_1.useMemo)(() => ({ userKey }), [userKey]);
    // Input state (managed internally for stub)
    const [inputValue, setInputValueInternal] = react_1.default.useState(initialInputValue);
    // Thread input context
    const threadInputContext = (0, react_1.useMemo)(() => {
        const setValue = onSetValue ?? setInputValueInternal;
        const submit = onSubmit ??
            (async () => {
                return { threadId };
            });
        return {
            value: inputValue,
            setValue,
            submit,
            threadId,
            setThreadId: () => { },
            images: [],
            addImage: async () => { },
            addImages: async () => { },
            removeImage: () => { },
            clearImages: () => { },
            isPending: false,
            isError: false,
            error: null,
            isIdle: true,
            isSuccess: false,
            status: "idle",
            data: undefined,
            variables: undefined,
            failureCount: 0,
            failureReason: null,
            reset: () => { },
            context: undefined,
            submittedAt: 0,
            isPaused: false,
        };
    }, [inputValue, threadId, onSubmit, onSetValue, setInputValueInternal]);
    // Registry context
    const registryContext = (0, react_1.useMemo)(() => ({
        componentList,
        toolRegistry,
        componentToolAssociations: {},
        mcpServerInfos: [],
        resources: [],
        resourceSource: null,
        onCallUnregisteredTool: undefined,
        registerComponent: () => { },
        registerTool: () => { },
        registerTools: () => { },
        addToolAssociation: () => { },
        registerMcpServer: () => { },
        registerMcpServers: () => { },
        registerResource: () => { },
        registerResources: () => { },
        registerResourceSource: () => { },
    }), [componentList, toolRegistry]);
    // Client context
    const clientContext = (0, react_1.useMemo)(() => ({
        client: stubClient,
        queryClient,
        isUpdatingToken: false,
    }), [stubClient, queryClient]);
    return (react_1.default.createElement(react_query_1.QueryClientProvider, { client: queryClient },
        react_1.default.createElement(tambo_client_provider_1.TamboClientContext.Provider, { value: clientContext },
            react_1.default.createElement(tambo_registry_provider_1.TamboRegistryContext.Provider, { value: registryContext },
                react_1.default.createElement(tambo_v1_provider_1.TamboV1ConfigContext.Provider, { value: config },
                    react_1.default.createElement(tambo_v1_stream_context_1.TamboV1StreamProvider, { state: streamState, dispatch: streamDispatch, threadManagement: threadManagement },
                        react_1.default.createElement(tambo_v1_thread_input_provider_1.TamboV1ThreadInputContext.Provider, { value: threadInputContext }, children)))))));
}
//# sourceMappingURL=tambo-v1-stub-provider.js.map