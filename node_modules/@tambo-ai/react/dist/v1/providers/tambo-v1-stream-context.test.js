"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@ag-ui/core");
const react_1 = require("@testing-library/react");
const react_2 = __importDefault(require("react"));
const tambo_v1_stream_context_1 = require("./tambo-v1-stream-context");
describe("TamboV1StreamProvider", () => {
    describe("useStreamState", () => {
        it("throws when used outside provider", () => {
            // Suppress console.error for expected error
            const consoleSpy = jest
                .spyOn(console, "error")
                .mockImplementation(() => { });
            expect(() => {
                (0, react_1.renderHook)(() => (0, tambo_v1_stream_context_1.useStreamState)());
            }).toThrow("useStreamState must be used within TamboV1StreamProvider");
            consoleSpy.mockRestore();
        });
        it("returns initial state with empty threadMap", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_stream_context_1.TamboV1StreamProvider, null, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_v1_stream_context_1.useStreamState)(), { wrapper });
            expect(result.current.threadMap).toEqual({});
            expect(result.current.currentThreadId).toBeNull();
        });
        it("initializes thread via dispatch", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_stream_context_1.TamboV1StreamProvider, null, children));
            const { result } = (0, react_1.renderHook)(() => ({
                state: (0, tambo_v1_stream_context_1.useStreamState)(),
                dispatch: (0, tambo_v1_stream_context_1.useStreamDispatch)(),
            }), { wrapper });
            (0, react_1.act)(() => {
                result.current.dispatch({
                    type: "INIT_THREAD",
                    threadId: "thread_123",
                });
            });
            expect(result.current.state.threadMap.thread_123).toBeDefined();
            expect(result.current.state.threadMap.thread_123.thread.id).toBe("thread_123");
            expect(result.current.state.threadMap.thread_123.thread.status).toBe("idle");
            expect(result.current.state.threadMap.thread_123.thread.messages).toEqual([]);
        });
        it("initializes thread with initial data via dispatch", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_stream_context_1.TamboV1StreamProvider, null, children));
            const { result } = (0, react_1.renderHook)(() => ({
                state: (0, tambo_v1_stream_context_1.useStreamState)(),
                dispatch: (0, tambo_v1_stream_context_1.useStreamDispatch)(),
            }), { wrapper });
            (0, react_1.act)(() => {
                result.current.dispatch({
                    type: "INIT_THREAD",
                    threadId: "thread_123",
                    initialThread: {
                        title: "Test Thread",
                        metadata: { key: "value" },
                    },
                });
            });
            expect(result.current.state.threadMap.thread_123.thread.title).toBe("Test Thread");
            expect(result.current.state.threadMap.thread_123.thread.metadata).toEqual({
                key: "value",
            });
            // Default values should still be set
            expect(result.current.state.threadMap.thread_123.thread.status).toBe("idle");
        });
    });
    describe("useStreamDispatch", () => {
        it("throws when used outside provider", () => {
            const consoleSpy = jest
                .spyOn(console, "error")
                .mockImplementation(() => { });
            expect(() => {
                (0, react_1.renderHook)(() => (0, tambo_v1_stream_context_1.useStreamDispatch)());
            }).toThrow("useStreamDispatch must be used within TamboV1StreamProvider");
            consoleSpy.mockRestore();
        });
        it("dispatches events to update state", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_stream_context_1.TamboV1StreamProvider, null, children));
            const { result } = (0, react_1.renderHook)(() => ({
                state: (0, tambo_v1_stream_context_1.useStreamState)(),
                dispatch: (0, tambo_v1_stream_context_1.useStreamDispatch)(),
            }), { wrapper });
            // Initialize the thread first
            (0, react_1.act)(() => {
                result.current.dispatch({
                    type: "INIT_THREAD",
                    threadId: "thread_123",
                });
            });
            const runStartedEvent = {
                type: core_1.EventType.RUN_STARTED,
                runId: "run_1",
                threadId: "thread_123",
            };
            (0, react_1.act)(() => {
                result.current.dispatch({
                    type: "EVENT",
                    event: runStartedEvent,
                    threadId: "thread_123",
                });
            });
            expect(result.current.state.threadMap.thread_123.thread.status).toBe("streaming");
            expect(result.current.state.threadMap.thread_123.streaming.status).toBe("streaming");
            expect(result.current.state.threadMap.thread_123.streaming.runId).toBe("run_1");
        });
    });
    describe("useThreadManagement", () => {
        it("throws when used outside provider", () => {
            const consoleSpy = jest
                .spyOn(console, "error")
                .mockImplementation(() => { });
            expect(() => {
                (0, react_1.renderHook)(() => (0, tambo_v1_stream_context_1.useThreadManagement)());
            }).toThrow("useThreadManagement must be used within TamboV1StreamProvider");
            consoleSpy.mockRestore();
        });
        it("initThread creates a new thread", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_stream_context_1.TamboV1StreamProvider, null, children));
            const { result } = (0, react_1.renderHook)(() => ({
                state: (0, tambo_v1_stream_context_1.useStreamState)(),
                management: (0, tambo_v1_stream_context_1.useThreadManagement)(),
            }), { wrapper });
            (0, react_1.act)(() => {
                result.current.management.initThread("thread_456");
            });
            expect(result.current.state.threadMap.thread_456).toBeDefined();
            expect(result.current.state.threadMap.thread_456.thread.id).toBe("thread_456");
        });
        it("switchThread changes currentThreadId", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_stream_context_1.TamboV1StreamProvider, null, children));
            const { result } = (0, react_1.renderHook)(() => ({
                state: (0, tambo_v1_stream_context_1.useStreamState)(),
                management: (0, tambo_v1_stream_context_1.useThreadManagement)(),
            }), { wrapper });
            // Initialize and switch to a thread
            (0, react_1.act)(() => {
                result.current.management.initThread("thread_789");
                result.current.management.switchThread("thread_789");
            });
            expect(result.current.state.currentThreadId).toBe("thread_789");
        });
        it("startNewThread creates temp thread and switches to it", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_stream_context_1.TamboV1StreamProvider, null, children));
            const { result } = (0, react_1.renderHook)(() => ({
                state: (0, tambo_v1_stream_context_1.useStreamState)(),
                management: (0, tambo_v1_stream_context_1.useThreadManagement)(),
            }), { wrapper });
            let tempId;
            (0, react_1.act)(() => {
                tempId = result.current.management.startNewThread();
            });
            expect(tempId).toMatch(/^temp_/);
            expect(result.current.state.currentThreadId).toBe(tempId);
            expect(result.current.state.threadMap[tempId]).toBeDefined();
        });
    });
});
//# sourceMappingURL=tambo-v1-stream-context.test.js.map