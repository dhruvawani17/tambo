"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = require("@testing-library/react");
const react_2 = __importDefault(require("react"));
const tambo_v1_stub_provider_1 = require("./tambo-v1-stub-provider");
const use_tambo_v1_1 = require("../hooks/use-tambo-v1");
const use_tambo_v1_thread_input_1 = require("../hooks/use-tambo-v1-thread-input");
const tambo_registry_provider_1 = require("../../providers/tambo-registry-provider");
const tambo_client_provider_1 = require("../../providers/tambo-client-provider");
describe("TamboV1StubProvider", () => {
    const mockThread = {
        id: "thread_123",
        messages: [
            {
                id: "msg_1",
                role: "user",
                content: [{ type: "text", text: "Hello" }],
                createdAt: "2024-01-01T00:00:00Z",
            },
            {
                id: "msg_2",
                role: "assistant",
                content: [{ type: "text", text: "Hi there!" }],
                createdAt: "2024-01-01T00:00:01Z",
            },
        ],
        status: "idle",
        createdAt: "2024-01-01T00:00:00Z",
        updatedAt: "2024-01-01T00:00:01Z",
    };
    describe("useTamboV1", () => {
        it("provides thread data via useTamboV1", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_stub_provider_1.TamboV1StubProvider, { thread: mockThread }, children));
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_1.useTamboV1)("thread_123"), {
                wrapper,
            });
            expect(result.current.messages).toHaveLength(2);
            expect(result.current.messages[0].id).toBe("msg_1");
            expect(result.current.messages[1].id).toBe("msg_2");
            expect(result.current.isIdle).toBe(true);
            expect(result.current.isStreaming).toBe(false);
        });
        it("returns empty messages when no thread provided", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_stub_provider_1.TamboV1StubProvider, null, children));
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_1.useTamboV1)("stub_thread"), {
                wrapper,
            });
            expect(result.current.messages).toHaveLength(0);
            expect(result.current.isIdle).toBe(true);
        });
        it("shows streaming state when isStreaming prop is true", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_stub_provider_1.TamboV1StubProvider, { thread: mockThread, isStreaming: true }, children));
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_1.useTamboV1)("thread_123"), {
                wrapper,
            });
            expect(result.current.isStreaming).toBe(true);
            expect(result.current.isIdle).toBe(false);
        });
    });
    describe("useTamboV1ThreadInput", () => {
        it("provides thread input context", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_stub_provider_1.TamboV1StubProvider, { thread: mockThread }, children));
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_thread_input_1.useTamboV1ThreadInput)(), { wrapper });
            expect(result.current.value).toBe("");
            expect(result.current.threadId).toBe("thread_123");
            expect(typeof result.current.setValue).toBe("function");
            expect(typeof result.current.submit).toBe("function");
        });
        it("uses initial input value when provided", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_stub_provider_1.TamboV1StubProvider, { thread: mockThread, inputValue: "Hello world" }, children));
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_thread_input_1.useTamboV1ThreadInput)(), { wrapper });
            expect(result.current.value).toBe("Hello world");
        });
        it("calls custom onSubmit when provided", async () => {
            const mockOnSubmit = jest
                .fn()
                .mockResolvedValue({ threadId: "new_thread" });
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_stub_provider_1.TamboV1StubProvider, { thread: mockThread, onSubmit: mockOnSubmit }, children));
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_thread_input_1.useTamboV1ThreadInput)(), { wrapper });
            const response = await result.current.submit();
            expect(mockOnSubmit).toHaveBeenCalled();
            expect(response.threadId).toBe("new_thread");
        });
    });
    describe("Registry", () => {
        it("registers provided components", () => {
            const TestComponent = () => react_2.default.createElement("div", null, "Test");
            const components = [
                {
                    name: "TestComponent",
                    description: "A test component",
                    component: TestComponent,
                },
            ];
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_stub_provider_1.TamboV1StubProvider, { thread: mockThread, components: components }, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            expect(result.current.componentList.TestComponent).toBeDefined();
            expect(result.current.componentList.TestComponent.name).toBe("TestComponent");
        });
        it("registers provided tools", () => {
            const tools = [
                {
                    name: "testTool",
                    description: "A test tool",
                    tool: async () => "result",
                },
            ];
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_stub_provider_1.TamboV1StubProvider, { thread: mockThread, tools: tools }, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_registry_provider_1.useTamboRegistry)(), { wrapper });
            expect(result.current.toolRegistry.testTool).toBeDefined();
            expect(result.current.toolRegistry.testTool.name).toBe("testTool");
        });
    });
    describe("Client", () => {
        it("provides stub client", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_stub_provider_1.TamboV1StubProvider, { thread: mockThread }, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_client_provider_1.useTamboClient)(), { wrapper });
            expect(result.current).toBeDefined();
        });
    });
    describe("Thread management", () => {
        it("provides thread management functions", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_stub_provider_1.TamboV1StubProvider, { thread: mockThread }, children));
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_1.useTamboV1)("thread_123"), {
                wrapper,
            });
            expect(typeof result.current.startNewThread).toBe("function");
            expect(typeof result.current.switchThread).toBe("function");
            expect(typeof result.current.initThread).toBe("function");
        });
        it("calls custom onStartNewThread when provided", () => {
            const mockStartNewThread = jest.fn().mockReturnValue("custom_thread_id");
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_stub_provider_1.TamboV1StubProvider, { thread: mockThread, onStartNewThread: mockStartNewThread }, children));
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_1.useTamboV1)("thread_123"), {
                wrapper,
            });
            const newThreadId = result.current.startNewThread();
            expect(mockStartNewThread).toHaveBeenCalled();
            expect(newThreadId).toBe("custom_thread_id");
        });
    });
    describe("Messages-only thread", () => {
        it("accepts just messages array instead of full thread", () => {
            const messages = [
                {
                    id: "msg_1",
                    role: "user",
                    content: [{ type: "text", text: "Hello" }],
                    createdAt: "2024-01-01T00:00:00Z",
                },
            ];
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_stub_provider_1.TamboV1StubProvider, { thread: { messages }, threadId: "custom_id" }, children));
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_1.useTamboV1)("custom_id"), { wrapper });
            expect(result.current.messages).toHaveLength(1);
            expect(result.current.messages[0].id).toBe("msg_1");
        });
    });
});
//# sourceMappingURL=tambo-v1-stub-provider.test.js.map