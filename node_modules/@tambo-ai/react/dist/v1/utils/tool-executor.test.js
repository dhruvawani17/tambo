"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const zod_1 = require("zod");
const tool_executor_1 = require("./tool-executor");
describe("tool-executor", () => {
    describe("executeClientTool", () => {
        it("executes a tool and returns text result", async () => {
            const tool = {
                name: "get_weather",
                description: "Gets weather",
                tool: async ({ city }) => `Weather in ${city} is sunny`,
                inputSchema: zod_1.z.object({ city: zod_1.z.string() }),
                outputSchema: zod_1.z.string(),
            };
            const result = await (0, tool_executor_1.executeClientTool)(tool, "call-1", {
                city: "Seattle",
            });
            expect(result).toEqual({
                type: "tool_result",
                toolUseId: "call-1",
                content: [{ type: "text", text: "Weather in Seattle is sunny" }],
            });
        });
        it("stringifies non-string results", async () => {
            const tool = {
                name: "get_data",
                description: "Gets data",
                tool: async () => ({ value: 42 }),
                inputSchema: zod_1.z.object({}),
                outputSchema: zod_1.z.object({ value: zod_1.z.number() }),
            };
            const result = await (0, tool_executor_1.executeClientTool)(tool, "call-2", {});
            expect(result).toEqual({
                type: "tool_result",
                toolUseId: "call-2",
                content: [{ type: "text", text: '{"value":42}' }],
            });
        });
        it("uses transformToContent when provided", async () => {
            const tool = {
                name: "custom_tool",
                description: "Custom tool",
                tool: async () => "custom result",
                inputSchema: zod_1.z.object({}),
                outputSchema: zod_1.z.string(),
                transformToContent: (result) => [
                    { type: "text", text: `Transformed: ${result}` },
                ],
            };
            const result = await (0, tool_executor_1.executeClientTool)(tool, "call-3", {});
            expect(result).toEqual({
                type: "tool_result",
                toolUseId: "call-3",
                content: [{ type: "text", text: "Transformed: custom result" }],
            });
        });
        it("handles transformToContent with non-text types by stringifying", async () => {
            const tool = {
                name: "image_tool",
                description: "Image tool",
                tool: async () => "image data",
                inputSchema: zod_1.z.object({}),
                outputSchema: zod_1.z.string(),
                transformToContent: () => [
                    {
                        type: "image_url",
                        image_url: { url: "https://example.com/image.png" },
                    },
                ],
            };
            const result = await (0, tool_executor_1.executeClientTool)(tool, "call-4", {});
            expect(result).toEqual({
                type: "tool_result",
                toolUseId: "call-4",
                content: [
                    {
                        type: "text",
                        text: '{"type":"image_url","image_url":{"url":"https://example.com/image.png"}}',
                    },
                ],
            });
        });
        it("handles tool execution errors gracefully", async () => {
            const tool = {
                name: "failing_tool",
                description: "A tool that fails",
                tool: async () => {
                    throw new Error("Tool failed!");
                },
                inputSchema: zod_1.z.object({}),
                outputSchema: zod_1.z.void(),
            };
            const result = await (0, tool_executor_1.executeClientTool)(tool, "call-5", {});
            expect(result).toEqual({
                type: "tool_result",
                toolUseId: "call-5",
                content: [{ type: "text", text: "Tool failed!" }],
            });
        });
        it("handles non-Error throws gracefully", async () => {
            const tool = {
                name: "throwing_tool",
                description: "A tool that throws a string",
                tool: async () => {
                    throw "string error";
                },
                inputSchema: zod_1.z.object({}),
                outputSchema: zod_1.z.void(),
            };
            const result = await (0, tool_executor_1.executeClientTool)(tool, "call-6", {});
            expect(result).toEqual({
                type: "tool_result",
                toolUseId: "call-6",
                content: [{ type: "text", text: "Tool execution failed" }],
            });
        });
    });
    describe("executeAllPendingTools", () => {
        it("executes multiple tools with Map registry", async () => {
            const registry = new Map([
                [
                    "add",
                    {
                        name: "add",
                        description: "Adds numbers",
                        tool: async ({ a, b }) => a + b,
                        inputSchema: zod_1.z.object({ a: zod_1.z.number(), b: zod_1.z.number() }),
                        outputSchema: zod_1.z.number(),
                    },
                ],
                [
                    "multiply",
                    {
                        name: "multiply",
                        description: "Multiplies numbers",
                        tool: async ({ a, b }) => a * b,
                        inputSchema: zod_1.z.object({ a: zod_1.z.number(), b: zod_1.z.number() }),
                        outputSchema: zod_1.z.number(),
                    },
                ],
            ]);
            const toolCalls = new Map([
                ["call-1", { name: "add", input: { a: 2, b: 3 } }],
                ["call-2", { name: "multiply", input: { a: 4, b: 5 } }],
            ]);
            const results = await (0, tool_executor_1.executeAllPendingTools)(toolCalls, registry);
            expect(results).toHaveLength(2);
            expect(results[0]).toEqual({
                type: "tool_result",
                toolUseId: "call-1",
                content: [{ type: "text", text: "5" }],
            });
            expect(results[1]).toEqual({
                type: "tool_result",
                toolUseId: "call-2",
                content: [{ type: "text", text: "20" }],
            });
        });
        it("executes tools with Record registry", async () => {
            const registry = {
                greet: {
                    name: "greet",
                    description: "Greets user",
                    tool: async ({ name }) => `Hello, ${name}!`,
                    inputSchema: zod_1.z.object({ name: zod_1.z.string() }),
                    outputSchema: zod_1.z.string(),
                },
            };
            const toolCalls = new Map([
                ["call-1", { name: "greet", input: { name: "World" } }],
            ]);
            const results = await (0, tool_executor_1.executeAllPendingTools)(toolCalls, registry);
            expect(results).toHaveLength(1);
            expect(results[0]).toEqual({
                type: "tool_result",
                toolUseId: "call-1",
                content: [{ type: "text", text: "Hello, World!" }],
            });
        });
        it("returns error result for unknown tools", async () => {
            const registry = new Map();
            const toolCalls = new Map([
                ["call-1", { name: "unknown_tool", input: {} }],
            ]);
            const results = await (0, tool_executor_1.executeAllPendingTools)(toolCalls, registry);
            expect(results).toHaveLength(1);
            expect(results[0]).toEqual({
                type: "tool_result",
                toolUseId: "call-1",
                content: [
                    { type: "text", text: 'Tool "unknown_tool" not found in registry' },
                ],
            });
        });
        it("handles mixed known and unknown tools", async () => {
            const registry = new Map([
                [
                    "known",
                    {
                        name: "known",
                        description: "Known tool",
                        tool: async () => "success",
                        inputSchema: zod_1.z.object({}),
                        outputSchema: zod_1.z.string(),
                    },
                ],
            ]);
            const toolCalls = new Map([
                ["call-1", { name: "known", input: {} }],
                ["call-2", { name: "unknown", input: {} }],
            ]);
            const results = await (0, tool_executor_1.executeAllPendingTools)(toolCalls, registry);
            expect(results).toHaveLength(2);
            expect(results[0].content[0]).toEqual({ type: "text", text: "success" });
            expect(results[1].content[0]).toEqual({
                type: "text",
                text: 'Tool "unknown" not found in registry',
            });
        });
    });
});
//# sourceMappingURL=tool-executor.test.js.map