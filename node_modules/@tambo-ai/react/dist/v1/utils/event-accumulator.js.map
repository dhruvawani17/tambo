{"version":3,"file":"event-accumulator.js","sourceRoot":"","sources":["../../../src/v1/utils/event-accumulator.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Event Accumulation Logic for v1 Streaming API\n *\n * Implements a reducer that transforms AG-UI event streams into React state.\n * Used with useReducer to accumulate events into thread state.\n */\n\nimport type {\n  AGUIEvent,\n  CustomEvent,\n  RunErrorEvent,\n  RunFinishedEvent,\n  RunStartedEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  TextMessageStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallResultEvent,\n  ToolCallStartEvent,\n} from \"@ag-ui/core\";\nimport { EventType } from \"@ag-ui/core\";\nimport {\n  asTamboCustomEvent,\n  type ComponentEndEvent,\n  type ComponentPropsDeltaEvent,\n  type ComponentStartEvent,\n  type ComponentStateDeltaEvent,\n  type RunAwaitingInputEvent,\n} from \"../types/event\";\nimport type { Content, TamboV1Message } from \"../types/message\";\nimport type { StreamingState, TamboV1Thread } from \"../types/thread\";\nimport { applyJsonPatch } from \"./json-patch\";\n\n/**\n * Error thrown when an unreachable case is reached in a switch statement.\n * This indicates a programming error where not all cases were handled.\n */\nexport class UnreachableCaseError extends Error {\n  constructor(value: never) {\n    super(`Unreachable case: ${JSON.stringify(value)}`);\n    this.name = \"UnreachableCaseError\";\n  }\n}\n\n/**\n * Per-thread state managed by the stream reducer.\n * Tracks thread data, streaming status, and accumulating data.\n */\nexport interface ThreadState {\n  thread: TamboV1Thread;\n  streaming: StreamingState;\n  /**\n   * Accumulating tool call arguments as JSON strings (for streaming).\n   * Maps tool call ID to accumulated JSON string.\n   */\n  accumulatingToolArgs: Map<string, string>;\n}\n\n/**\n * State managed by the stream reducer.\n * Maintains a map of all threads being tracked.\n */\nexport interface StreamState {\n  /**\n   * Map of thread ID to thread state\n   */\n  threadMap: Record<string, ThreadState>;\n\n  /**\n   * Current active thread ID (for UI context)\n   */\n  currentThreadId: string | null;\n}\n\n/**\n * Event action - dispatches an AG-UI event to update thread state.\n */\nexport interface EventAction {\n  type: \"EVENT\";\n  event: AGUIEvent;\n  threadId: string;\n}\n\n/**\n * Initialize thread action - creates a new thread in the threadMap.\n */\nexport interface InitThreadAction {\n  type: \"INIT_THREAD\";\n  threadId: string;\n  initialThread?: Partial<TamboV1Thread>;\n}\n\n/**\n * Set current thread action - changes the active thread.\n */\nexport interface SetCurrentThreadAction {\n  type: \"SET_CURRENT_THREAD\";\n  threadId: string | null;\n}\n\n/**\n * Start new thread action - atomically creates and switches to a new thread.\n * This prevents race conditions when multiple calls happen concurrently.\n */\nexport interface StartNewThreadAction {\n  type: \"START_NEW_THREAD\";\n  threadId: string;\n  initialThread?: Partial<TamboV1Thread>;\n}\n\n/**\n * Action type for the stream reducer.\n */\nexport type StreamAction =\n  | EventAction\n  | InitThreadAction\n  | SetCurrentThreadAction\n  | StartNewThreadAction;\n\n/**\n * Initial streaming state.\n */\nconst initialStreamingState: StreamingState = {\n  status: \"idle\",\n};\n\n/**\n * Create initial thread state for a new thread.\n * @param threadId - Unique thread identifier\n * @returns Initial thread state\n */\nexport function createInitialThreadState(threadId: string): ThreadState {\n  const now = new Date().toISOString();\n  return {\n    thread: {\n      id: threadId,\n      messages: [],\n      status: \"idle\",\n      createdAt: now,\n      updatedAt: now,\n    },\n    streaming: initialStreamingState,\n    accumulatingToolArgs: new Map(),\n  };\n}\n\n/**\n * Create initial stream state with empty threadMap.\n * @returns Initial stream state\n */\nexport function createInitialState(): StreamState {\n  return {\n    threadMap: {},\n    currentThreadId: null,\n  };\n}\n\n// ============================================================================\n// Helper Functions for Immutable State Updates\n// ============================================================================\n\n/**\n * Location of a content block within messages.\n */\ninterface ContentLocation {\n  messageIndex: number;\n  contentIndex: number;\n}\n\n/**\n * Replace a message at a specific index immutably.\n * @param messages - Current messages array\n * @param index - Index of message to replace\n * @param updatedMessage - New message to insert\n * @returns New messages array with the message replaced\n */\nfunction updateMessageAtIndex(\n  messages: TamboV1Message[],\n  index: number,\n  updatedMessage: TamboV1Message,\n): TamboV1Message[] {\n  return [\n    ...messages.slice(0, index),\n    updatedMessage,\n    ...messages.slice(index + 1),\n  ];\n}\n\n/**\n * Replace a content block at a specific index within a message's content immutably.\n * @param content - Current content array\n * @param index - Index of content to replace\n * @param updatedContent - New content to insert\n * @returns New content array with the content replaced\n */\nfunction updateContentAtIndex(\n  content: Content[],\n  index: number,\n  updatedContent: Content,\n): Content[] {\n  return [\n    ...content.slice(0, index),\n    updatedContent,\n    ...content.slice(index + 1),\n  ];\n}\n\n/**\n * Find a content block by ID across all messages, searching from most recent.\n *\n * TODO: This is O(n*m) where n = messages and m = content blocks per message.\n * For high-frequency streaming with many messages, consider maintaining an\n * index map of contentId -> {messageIndex, contentIndex} that gets updated\n * when content blocks are created.\n * @param messages - Messages to search\n * @param contentType - Type of content to find (\"component\" or \"tool_use\")\n * @param contentId - ID of the content block\n * @param eventName - Name of the event (for error messages)\n * @returns Location of the content block\n * @throws {Error} If content not found\n */\nfunction findContentById(\n  messages: TamboV1Message[],\n  contentType: \"component\" | \"tool_use\",\n  contentId: string,\n  eventName: string,\n): ContentLocation {\n  for (let i = messages.length - 1; i >= 0; i--) {\n    const idx = messages[i].content.findIndex(\n      (c) => c.type === contentType && c.id === contentId,\n    );\n    if (idx !== -1) {\n      return { messageIndex: i, contentIndex: idx };\n    }\n  }\n  throw new Error(`${contentType} ${contentId} not found for ${eventName}`);\n}\n\n/**\n * Create updated thread state with new messages.\n * @param threadState - Current thread state\n * @param messages - New messages array\n * @returns Updated thread state\n */\nfunction updateThreadMessages(\n  threadState: ThreadState,\n  messages: TamboV1Message[],\n): ThreadState {\n  return {\n    ...threadState,\n    thread: {\n      ...threadState.thread,\n      messages,\n      updatedAt: new Date().toISOString(),\n    },\n  };\n}\n\n/**\n * Stream reducer that accumulates events into thread state.\n *\n * This reducer handles all AG-UI events and Tambo custom events,\n * transforming them into immutable state updates per thread.\n * @param state - Current stream state\n * @param action - Action to process\n * @returns Updated stream state\n */\nexport function streamReducer(\n  state: StreamState,\n  action: StreamAction,\n): StreamState {\n  // Handle non-event actions first\n  switch (action.type) {\n    case \"INIT_THREAD\": {\n      const { threadId, initialThread } = action;\n      // Don't overwrite existing thread\n      if (state.threadMap[threadId]) {\n        return state;\n      }\n      const baseState = createInitialThreadState(threadId);\n      const threadState = initialThread\n        ? {\n            ...baseState,\n            thread: {\n              ...baseState.thread,\n              ...initialThread,\n              id: threadId,\n            },\n          }\n        : baseState;\n      return {\n        ...state,\n        threadMap: {\n          ...state.threadMap,\n          [threadId]: threadState,\n        },\n      };\n    }\n\n    case \"SET_CURRENT_THREAD\": {\n      return {\n        ...state,\n        currentThreadId: action.threadId,\n      };\n    }\n\n    case \"START_NEW_THREAD\": {\n      // Atomic action: initialize thread AND set as current in one reducer pass\n      // This prevents race conditions when multiple startNewThread() calls happen\n      const { threadId, initialThread } = action;\n      // Don't overwrite existing thread\n      if (state.threadMap[threadId]) {\n        return {\n          ...state,\n          currentThreadId: threadId,\n        };\n      }\n      const baseState = createInitialThreadState(threadId);\n      const threadState = initialThread\n        ? {\n            ...baseState,\n            thread: {\n              ...baseState.thread,\n              ...initialThread,\n              id: threadId,\n            },\n          }\n        : baseState;\n      return {\n        ...state,\n        threadMap: {\n          ...state.threadMap,\n          [threadId]: threadState,\n        },\n        currentThreadId: threadId,\n      };\n    }\n\n    case \"EVENT\":\n      // Fall through to event handling below\n      break;\n  }\n\n  // Handle EVENT action\n  const { event, threadId } = action;\n\n  // Get the current thread state, auto-initializing if needed\n  // Auto-initialization handles the case where events arrive before explicit thread init\n  // (e.g., when creating a new thread and RUN_STARTED is the first event)\n  let threadState = state.threadMap[threadId];\n  let updatedState = state;\n\n  if (!threadState) {\n    // Auto-initialize the thread to avoid dropping events\n    threadState = createInitialThreadState(threadId);\n    updatedState = {\n      ...state,\n      threadMap: {\n        ...state.threadMap,\n        [threadId]: threadState,\n      },\n    };\n  }\n\n  // Process the event for this specific thread\n  let updatedThreadState: ThreadState;\n\n  // Switch on event.type - AGUIEvent is a discriminated union so TypeScript\n  // automatically narrows the type in each case branch\n  switch (event.type) {\n    case EventType.RUN_STARTED:\n      updatedThreadState = handleRunStarted(threadState, event);\n      break;\n\n    case EventType.RUN_FINISHED:\n      updatedThreadState = handleRunFinished(threadState, event);\n      break;\n\n    case EventType.RUN_ERROR:\n      updatedThreadState = handleRunError(threadState, event);\n      break;\n\n    case EventType.TEXT_MESSAGE_START:\n      updatedThreadState = handleTextMessageStart(threadState, event);\n      break;\n\n    case EventType.TEXT_MESSAGE_CONTENT:\n      updatedThreadState = handleTextMessageContent(threadState, event);\n      break;\n\n    case EventType.TEXT_MESSAGE_END:\n      updatedThreadState = handleTextMessageEnd(threadState, event);\n      break;\n\n    case EventType.TOOL_CALL_START:\n      updatedThreadState = handleToolCallStart(threadState, event);\n      break;\n\n    case EventType.TOOL_CALL_ARGS:\n      updatedThreadState = handleToolCallArgs(threadState, event);\n      break;\n\n    case EventType.TOOL_CALL_END:\n      updatedThreadState = handleToolCallEnd(threadState, event);\n      break;\n\n    case EventType.TOOL_CALL_RESULT:\n      updatedThreadState = handleToolCallResult(threadState, event);\n      break;\n\n    case EventType.CUSTOM:\n      updatedThreadState = handleCustomEvent(threadState, event);\n      break;\n\n    // Unsupported AG-UI event types - may be added in future phases\n    case EventType.TEXT_MESSAGE_CHUNK:\n    case EventType.THINKING_TEXT_MESSAGE_START:\n    case EventType.THINKING_TEXT_MESSAGE_CONTENT:\n    case EventType.THINKING_TEXT_MESSAGE_END:\n    case EventType.TOOL_CALL_CHUNK:\n    case EventType.THINKING_START:\n    case EventType.THINKING_END:\n    case EventType.STATE_SNAPSHOT:\n    case EventType.STATE_DELTA:\n    case EventType.MESSAGES_SNAPSHOT:\n    case EventType.ACTIVITY_SNAPSHOT:\n    case EventType.ACTIVITY_DELTA:\n    case EventType.RAW:\n    case EventType.STEP_STARTED:\n    case EventType.STEP_FINISHED:\n      // Log warning - these events are being ignored\n\n      console.warn(\n        `[StreamReducer] Received unsupported event type: ${event.type}. ` +\n          `This event will be ignored.`,\n      );\n      return updatedState;\n\n    default: {\n      // Exhaustiveness check: if a new event type is added to AGUIEvent\n      // and not handled above, TypeScript will error here\n      const _exhaustiveCheck: never = event;\n      throw new UnreachableCaseError(_exhaustiveCheck);\n    }\n  }\n\n  // Return updated state with modified thread\n  return {\n    ...updatedState,\n    threadMap: {\n      ...updatedState.threadMap,\n      [threadId]: updatedThreadState,\n    },\n  };\n}\n\n/**\n * Handle RUN_STARTED event.\n * @param threadState - Current thread state\n * @param event - Run started event\n * @returns Updated thread state\n */\nfunction handleRunStarted(\n  threadState: ThreadState,\n  event: RunStartedEvent,\n): ThreadState {\n  return {\n    ...threadState,\n    thread: {\n      ...threadState.thread,\n      status: \"streaming\",\n      updatedAt: new Date().toISOString(),\n    },\n    streaming: {\n      status: \"streaming\",\n      runId: event.runId,\n      startTime: event.timestamp ?? Date.now(),\n    },\n  };\n}\n\n/**\n * Handle RUN_FINISHED event.\n * @param threadState - Current thread state\n * @param _event - Run finished event (unused)\n * @returns Updated thread state\n */\nfunction handleRunFinished(\n  threadState: ThreadState,\n  _event: RunFinishedEvent,\n): ThreadState {\n  return {\n    ...threadState,\n    thread: {\n      ...threadState.thread,\n      status: \"complete\",\n      updatedAt: new Date().toISOString(),\n    },\n    streaming: {\n      ...threadState.streaming,\n      status: \"complete\",\n    },\n  };\n}\n\n/**\n * Handle RUN_ERROR event.\n * @param threadState - Current thread state\n * @param event - Run error event\n * @returns Updated thread state\n */\nfunction handleRunError(\n  threadState: ThreadState,\n  event: RunErrorEvent,\n): ThreadState {\n  return {\n    ...threadState,\n    thread: {\n      ...threadState.thread,\n      status: \"error\",\n      updatedAt: new Date().toISOString(),\n    },\n    streaming: {\n      ...threadState.streaming,\n      status: \"error\",\n      error: {\n        message: event.message,\n        code: event.code,\n      },\n    },\n  };\n}\n\n/**\n * Handle TEXT_MESSAGE_START event.\n * Creates a new message in the thread.\n * @param threadState - Current thread state\n * @param event - Text message start event\n * @returns Updated thread state\n */\nfunction handleTextMessageStart(\n  threadState: ThreadState,\n  event: TextMessageStartEvent,\n): ThreadState {\n  const newMessage: TamboV1Message = {\n    id: event.messageId,\n    role: event.role === \"user\" ? \"user\" : \"assistant\",\n    content: [],\n    createdAt: new Date().toISOString(),\n  };\n\n  return {\n    ...threadState,\n    thread: {\n      ...threadState.thread,\n      messages: [...threadState.thread.messages, newMessage],\n      updatedAt: new Date().toISOString(),\n    },\n    streaming: {\n      ...threadState.streaming,\n      messageId: event.messageId,\n    },\n  };\n}\n\n/**\n * Handle TEXT_MESSAGE_CONTENT event.\n * Appends text content to the current message.\n * @param threadState - Current thread state\n * @param event - Text message content event\n * @returns Updated thread state\n */\nfunction handleTextMessageContent(\n  threadState: ThreadState,\n  event: TextMessageContentEvent,\n): ThreadState {\n  const messageId = event.messageId;\n  const messages = threadState.thread.messages;\n\n  // Find the message to update\n  const messageIndex = messages.findIndex((m) => m.id === messageId);\n  if (messageIndex === -1) {\n    throw new Error(\n      `Message ${messageId} not found for TEXT_MESSAGE_CONTENT event`,\n    );\n  }\n\n  const message = messages[messageIndex];\n  const content = message.content;\n\n  // Find or create text content block\n  const lastContent = content[content.length - 1];\n  const isTextBlock = lastContent?.type === \"text\";\n\n  const updatedContent: Content[] = isTextBlock\n    ? [\n        ...content.slice(0, -1),\n        {\n          ...lastContent,\n          text: lastContent.text + event.delta,\n        },\n      ]\n    : [\n        ...content,\n        {\n          type: \"text\",\n          text: event.delta,\n        },\n      ];\n\n  const updatedMessage: TamboV1Message = {\n    ...message,\n    content: updatedContent,\n  };\n\n  return updateThreadMessages(\n    threadState,\n    updateMessageAtIndex(messages, messageIndex, updatedMessage),\n  );\n}\n\n/**\n * Handle TEXT_MESSAGE_END event.\n * Marks the message as complete.\n * @param threadState - Current thread state\n * @param event - Text message end event\n * @returns Updated thread state\n */\nfunction handleTextMessageEnd(\n  threadState: ThreadState,\n  event: TextMessageEndEvent,\n): ThreadState {\n  const activeMessageId = threadState.streaming.messageId;\n\n  if (activeMessageId && event.messageId !== activeMessageId) {\n    throw new Error(\n      `TEXT_MESSAGE_END messageId mismatch (thread ${threadState.thread.id}): expected ${activeMessageId}, got ${event.messageId}`,\n    );\n  }\n\n  return {\n    ...threadState,\n    streaming: {\n      ...threadState.streaming,\n      messageId: undefined,\n    },\n  };\n}\n\n/**\n * Handle TOOL_CALL_START event.\n * Adds a tool use content block to the current message.\n * @param threadState - Current thread state\n * @param event - Tool call start event\n * @returns Updated thread state\n */\nfunction handleToolCallStart(\n  threadState: ThreadState,\n  event: ToolCallStartEvent,\n): ThreadState {\n  const messageId = event.parentMessageId;\n  const messages = threadState.thread.messages;\n\n  // If no parent message ID, use the last message\n  const messageIndex = messageId\n    ? messages.findIndex((m) => m.id === messageId)\n    : messages.length - 1;\n\n  if (messageIndex === -1) {\n    throw new Error(\n      messageId\n        ? `Message ${messageId} not found for TOOL_CALL_START event`\n        : `No messages exist for TOOL_CALL_START event`,\n    );\n  }\n\n  const message = messages[messageIndex];\n  const newContent: Content = {\n    type: \"tool_use\",\n    id: event.toolCallId,\n    name: event.toolCallName,\n    input: {},\n  };\n\n  const updatedMessage: TamboV1Message = {\n    ...message,\n    content: [...message.content, newContent],\n  };\n\n  return updateThreadMessages(\n    threadState,\n    updateMessageAtIndex(messages, messageIndex, updatedMessage),\n  );\n}\n\n/**\n * Handle TOOL_CALL_ARGS event.\n * Accumulates JSON string deltas for tool call arguments.\n * The accumulated string will be parsed at TOOL_CALL_END.\n * @param threadState - Current thread state\n * @param event - Tool call args event\n * @returns Updated thread state\n */\nfunction handleToolCallArgs(\n  threadState: ThreadState,\n  event: ToolCallArgsEvent,\n): ThreadState {\n  const toolCallId = event.toolCallId;\n\n  // Accumulate the JSON string delta\n  const accumulatedArgs = threadState.accumulatingToolArgs;\n  const existingArgs = accumulatedArgs.get(toolCallId) ?? \"\";\n  const newAccumulatedArgs = new Map(accumulatedArgs);\n  newAccumulatedArgs.set(toolCallId, existingArgs + event.delta);\n\n  return {\n    ...threadState,\n    accumulatingToolArgs: newAccumulatedArgs,\n  };\n}\n\n/**\n * Handle TOOL_CALL_END event.\n * Parses the accumulated JSON arguments and updates the tool_use content block.\n * @param threadState - Current thread state\n * @param event - Tool call end event\n * @returns Updated thread state\n */\nfunction handleToolCallEnd(\n  threadState: ThreadState,\n  event: ToolCallEndEvent,\n): ThreadState {\n  const toolCallId = event.toolCallId;\n  const messages = threadState.thread.messages;\n\n  // Get accumulated JSON args string\n  const accumulatedJson = threadState.accumulatingToolArgs.get(toolCallId);\n  if (!accumulatedJson) {\n    // No args accumulated - tool call has empty input\n    return threadState;\n  }\n\n  // Parse the accumulated JSON\n  let parsedInput: unknown;\n  try {\n    parsedInput = JSON.parse(accumulatedJson);\n  } catch (error) {\n    throw new Error(\n      `Failed to parse tool call arguments for ${toolCallId}: ${error instanceof Error ? error.message : String(error)}. JSON: ${accumulatedJson}`,\n    );\n  }\n\n  // Find the tool_use content block\n  const { messageIndex, contentIndex } = findContentById(\n    messages,\n    \"tool_use\",\n    toolCallId,\n    \"TOOL_CALL_END event\",\n  );\n\n  const message = messages[messageIndex];\n  const toolUseContent = message.content[contentIndex];\n\n  if (toolUseContent.type !== \"tool_use\") {\n    throw new Error(\n      `Content at index ${contentIndex} is not a tool_use block for TOOL_CALL_END event`,\n    );\n  }\n\n  // Update the tool_use content with parsed input\n  const updatedContent: Content = {\n    ...toolUseContent,\n    input: parsedInput,\n  };\n\n  const updatedMessage: TamboV1Message = {\n    ...message,\n    content: updateContentAtIndex(\n      message.content,\n      contentIndex,\n      updatedContent,\n    ),\n  };\n\n  // Clear accumulated args for this tool call\n  const newAccumulatingToolArgs = new Map(threadState.accumulatingToolArgs);\n  newAccumulatingToolArgs.delete(toolCallId);\n\n  return {\n    ...updateThreadMessages(\n      threadState,\n      updateMessageAtIndex(messages, messageIndex, updatedMessage),\n    ),\n    accumulatingToolArgs: newAccumulatingToolArgs,\n  };\n}\n\n/**\n * Handle TOOL_CALL_RESULT event.\n * Adds tool result to the message.\n * @param threadState - Current thread state\n * @param event - Tool call result event\n * @returns Updated thread state\n */\nfunction handleToolCallResult(\n  threadState: ThreadState,\n  event: ToolCallResultEvent,\n): ThreadState {\n  const messageId = event.messageId;\n  const messages = threadState.thread.messages;\n\n  // Find the message\n  const messageIndex = messages.findIndex((m) => m.id === messageId);\n  if (messageIndex === -1) {\n    throw new Error(\n      `Message ${messageId} not found for TOOL_CALL_RESULT event`,\n    );\n  }\n\n  const message = messages[messageIndex];\n\n  // Add tool result content\n  const newContent: Content = {\n    type: \"tool_result\",\n    toolUseId: event.toolCallId,\n    content: [\n      {\n        type: \"text\",\n        text: event.content,\n      },\n    ],\n  };\n\n  const updatedMessage: TamboV1Message = {\n    ...message,\n    content: [...message.content, newContent],\n  };\n\n  return updateThreadMessages(\n    threadState,\n    updateMessageAtIndex(messages, messageIndex, updatedMessage),\n  );\n}\n\n/**\n * Handle custom events (Tambo-specific).\n * @param threadState - Current thread state\n * @param event - Custom event (already narrowed from AGUIEvent)\n * @returns Updated thread state\n */\nfunction handleCustomEvent(\n  threadState: ThreadState,\n  event: CustomEvent,\n): ThreadState {\n  // Use centralized casting function to get properly typed Tambo event\n  const customEvent = asTamboCustomEvent(event);\n\n  if (!customEvent) {\n    // Unknown custom event - log and return unchanged\n    console.warn(`[StreamReducer] Unknown custom event name: ${event.name}`);\n    return threadState;\n  }\n\n  switch (customEvent.name) {\n    case \"tambo.component.start\":\n      return handleComponentStart(threadState, customEvent);\n\n    case \"tambo.component.props_delta\":\n      return handleComponentDelta(threadState, customEvent, \"props\");\n\n    case \"tambo.component.state_delta\":\n      return handleComponentDelta(threadState, customEvent, \"state\");\n\n    case \"tambo.component.end\":\n      return handleComponentEnd(threadState, customEvent);\n\n    case \"tambo.run.awaiting_input\":\n      return handleRunAwaitingInput(threadState, customEvent);\n\n    default: {\n      // Exhaustiveness check: if a new event type is added to TamboCustomEvent\n      // and not handled here, TypeScript will error\n      const _exhaustiveCheck: never = customEvent;\n      throw new UnreachableCaseError(_exhaustiveCheck);\n    }\n  }\n}\n\n/**\n * Handle tambo.component.start event.\n * Adds a component content block to the message with 'started' streaming state.\n * @param threadState - Current thread state\n * @param event - Component start event\n * @returns Updated thread state\n */\nfunction handleComponentStart(\n  threadState: ThreadState,\n  event: ComponentStartEvent,\n): ThreadState {\n  const messageId = event.value.messageId;\n  const messages = threadState.thread.messages;\n\n  // Find the message\n  const messageIndex = messages.findIndex((m) => m.id === messageId);\n  if (messageIndex === -1) {\n    throw new Error(\n      `Message ${messageId} not found for tambo.component.start event`,\n    );\n  }\n\n  const message = messages[messageIndex];\n\n  // Add component content block with 'started' streaming state\n  const newContent: Content = {\n    type: \"component\",\n    id: event.value.componentId,\n    name: event.value.componentName,\n    props: {},\n    streamingState: \"started\",\n  };\n\n  const updatedMessage: TamboV1Message = {\n    ...message,\n    content: [...message.content, newContent],\n  };\n\n  return updateThreadMessages(\n    threadState,\n    updateMessageAtIndex(messages, messageIndex, updatedMessage),\n  );\n}\n\n/**\n * Handle component delta events (both props_delta and state_delta).\n * Applies JSON Patch to the specified field and sets streamingState to 'streaming'.\n * @param threadState - Current thread state\n * @param event - Component delta event (props or state)\n * @param field - Which field to update ('props' or 'state')\n * @returns Updated thread state\n */\nfunction handleComponentDelta(\n  threadState: ThreadState,\n  event: ComponentPropsDeltaEvent | ComponentStateDeltaEvent,\n  field: \"props\" | \"state\",\n): ThreadState {\n  const componentId = event.value.componentId;\n  const operations = event.value.operations;\n  const messages = threadState.thread.messages;\n  const eventName = `tambo.component.${field}_delta`;\n\n  // Find the component content block\n  const { messageIndex, contentIndex } = findContentById(\n    messages,\n    \"component\",\n    componentId,\n    `${eventName} event`,\n  );\n\n  const message = messages[messageIndex];\n  const componentContent = message.content[contentIndex];\n\n  if (componentContent.type !== \"component\") {\n    throw new Error(\n      `Content at index ${contentIndex} is not a component block for ${eventName} event`,\n    );\n  }\n\n  // Get current value (state defaults to {} if undefined)\n  const currentValue =\n    field === \"props\"\n      ? (componentContent.props as Record<string, unknown>)\n      : ((componentContent.state as Record<string, unknown>) ?? {});\n\n  // Apply JSON Patch\n  const updatedValue = applyJsonPatch(currentValue, operations);\n\n  // Update field and set streaming state to 'streaming'\n  const updatedContent: Content = {\n    ...componentContent,\n    [field]: updatedValue,\n    streamingState: \"streaming\",\n  };\n\n  const updatedMessage: TamboV1Message = {\n    ...message,\n    content: updateContentAtIndex(\n      message.content,\n      contentIndex,\n      updatedContent,\n    ),\n  };\n\n  return updateThreadMessages(\n    threadState,\n    updateMessageAtIndex(messages, messageIndex, updatedMessage),\n  );\n}\n\n/**\n * Handle tambo.component.end event.\n * Sets component streaming state to 'done'.\n * @param threadState - Current thread state\n * @param event - Component end event\n * @returns Updated thread state\n */\nfunction handleComponentEnd(\n  threadState: ThreadState,\n  event: ComponentEndEvent,\n): ThreadState {\n  const componentId = event.value.componentId;\n  const messages = threadState.thread.messages;\n\n  // Find the component content block\n  const { messageIndex, contentIndex } = findContentById(\n    messages,\n    \"component\",\n    componentId,\n    \"tambo.component.end event\",\n  );\n\n  const message = messages[messageIndex];\n  const componentContent = message.content[contentIndex];\n\n  if (componentContent.type !== \"component\") {\n    throw new Error(\n      `Content at index ${contentIndex} is not a component block for tambo.component.end event`,\n    );\n  }\n\n  // Set streaming state to 'done'\n  const updatedContent: Content = {\n    ...componentContent,\n    streamingState: \"done\",\n  };\n\n  const updatedMessage: TamboV1Message = {\n    ...message,\n    content: updateContentAtIndex(\n      message.content,\n      contentIndex,\n      updatedContent,\n    ),\n  };\n\n  return updateThreadMessages(\n    threadState,\n    updateMessageAtIndex(messages, messageIndex, updatedMessage),\n  );\n}\n\n/**\n * Handle tambo.run.awaiting_input event.\n * Sets thread status to waiting for client-side tool execution.\n * @param threadState - Current thread state\n * @param _event - Run awaiting input event (unused)\n * @returns Updated thread state\n */\nfunction handleRunAwaitingInput(\n  threadState: ThreadState,\n  _event: RunAwaitingInputEvent,\n): ThreadState {\n  return {\n    ...threadState,\n    thread: {\n      ...threadState.thread,\n      status: \"waiting\",\n      updatedAt: new Date().toISOString(),\n    },\n    streaming: {\n      ...threadState.streaming,\n      status: \"waiting\",\n    },\n  };\n}\n"]}