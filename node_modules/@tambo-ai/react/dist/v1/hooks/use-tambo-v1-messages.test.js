"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@ag-ui/core");
const react_1 = require("@testing-library/react");
const react_2 = __importDefault(require("react"));
const tambo_v1_stream_context_1 = require("../providers/tambo-v1-stream-context");
const use_tambo_v1_messages_1 = require("./use-tambo-v1-messages");
describe("useTamboV1Messages", () => {
    function TestWrapper({ children }) {
        return react_2.default.createElement(tambo_v1_stream_context_1.TamboV1StreamProvider, null, children);
    }
    it("returns empty messages when thread has no messages", () => {
        const { result } = (0, react_1.renderHook)(() => ({
            messages: (0, use_tambo_v1_messages_1.useTamboV1Messages)("thread_123"),
            dispatch: (0, tambo_v1_stream_context_1.useStreamDispatch)(),
        }), { wrapper: TestWrapper });
        // Initialize thread first
        (0, react_1.act)(() => {
            result.current.dispatch({ type: "INIT_THREAD", threadId: "thread_123" });
        });
        expect(result.current.messages.messages).toEqual([]);
        expect(result.current.messages.hasMessages).toBe(false);
        expect(result.current.messages.messageCount).toBe(0);
        expect(result.current.messages.lastMessage).toBeUndefined();
        expect(result.current.messages.userMessages).toEqual([]);
        expect(result.current.messages.assistantMessages).toEqual([]);
    });
    it("returns messages after events are dispatched", () => {
        const { result } = (0, react_1.renderHook)(() => ({
            messages: (0, use_tambo_v1_messages_1.useTamboV1Messages)("thread_123"),
            dispatch: (0, tambo_v1_stream_context_1.useStreamDispatch)(),
        }), { wrapper: TestWrapper });
        // Initialize thread first
        (0, react_1.act)(() => {
            result.current.dispatch({ type: "INIT_THREAD", threadId: "thread_123" });
        });
        // Simulate a text message being received
        (0, react_1.act)(() => {
            result.current.dispatch({
                type: "EVENT",
                event: {
                    type: core_1.EventType.TEXT_MESSAGE_START,
                    messageId: "msg_1",
                    role: "assistant",
                },
                threadId: "thread_123",
            });
        });
        (0, react_1.act)(() => {
            result.current.dispatch({
                type: "EVENT",
                event: {
                    type: core_1.EventType.TEXT_MESSAGE_CONTENT,
                    messageId: "msg_1",
                    delta: "Hello",
                },
                threadId: "thread_123",
            });
        });
        (0, react_1.act)(() => {
            result.current.dispatch({
                type: "EVENT",
                event: {
                    type: core_1.EventType.TEXT_MESSAGE_END,
                    messageId: "msg_1",
                },
                threadId: "thread_123",
            });
        });
        expect(result.current.messages.messages.length).toBe(1);
        expect(result.current.messages.hasMessages).toBe(true);
        expect(result.current.messages.messageCount).toBe(1);
        expect(result.current.messages.lastMessage?.id).toBe("msg_1");
        expect(result.current.messages.lastMessage?.role).toBe("assistant");
        expect(result.current.messages.assistantMessages.length).toBe(1);
        expect(result.current.messages.userMessages.length).toBe(0);
    });
    it("filters user and assistant messages correctly", () => {
        const { result } = (0, react_1.renderHook)(() => ({
            messages: (0, use_tambo_v1_messages_1.useTamboV1Messages)("thread_123"),
            dispatch: (0, tambo_v1_stream_context_1.useStreamDispatch)(),
        }), { wrapper: TestWrapper });
        // Initialize thread first
        (0, react_1.act)(() => {
            result.current.dispatch({ type: "INIT_THREAD", threadId: "thread_123" });
        });
        // Add user message
        (0, react_1.act)(() => {
            result.current.dispatch({
                type: "EVENT",
                event: {
                    type: core_1.EventType.TEXT_MESSAGE_START,
                    messageId: "msg_user",
                    role: "user",
                },
                threadId: "thread_123",
            });
        });
        (0, react_1.act)(() => {
            result.current.dispatch({
                type: "EVENT",
                event: {
                    type: core_1.EventType.TEXT_MESSAGE_END,
                    messageId: "msg_user",
                },
                threadId: "thread_123",
            });
        });
        // Add assistant message
        (0, react_1.act)(() => {
            result.current.dispatch({
                type: "EVENT",
                event: {
                    type: core_1.EventType.TEXT_MESSAGE_START,
                    messageId: "msg_assistant",
                    role: "assistant",
                },
                threadId: "thread_123",
            });
        });
        (0, react_1.act)(() => {
            result.current.dispatch({
                type: "EVENT",
                event: {
                    type: core_1.EventType.TEXT_MESSAGE_END,
                    messageId: "msg_assistant",
                },
                threadId: "thread_123",
            });
        });
        expect(result.current.messages.messageCount).toBe(2);
        expect(result.current.messages.userMessages.length).toBe(1);
        expect(result.current.messages.userMessages[0].id).toBe("msg_user");
        expect(result.current.messages.assistantMessages.length).toBe(1);
        expect(result.current.messages.assistantMessages[0].id).toBe("msg_assistant");
        expect(result.current.messages.lastMessage?.id).toBe("msg_assistant");
    });
    it("returns empty messages when threadId does not exist in threadMap", () => {
        const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_messages_1.useTamboV1Messages)("nonexistent_thread"), {
            wrapper: TestWrapper,
        });
        expect(result.current.messages).toEqual([]);
        expect(result.current.hasMessages).toBe(false);
        expect(result.current.messageCount).toBe(0);
    });
});
//# sourceMappingURL=use-tambo-v1-messages.test.js.map