"use strict";
"use client";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useTamboV1ComponentState = useTamboV1ComponentState;
/**
 * useTamboV1ComponentState - Component State Hook for v1 API
 *
 * Provides bidirectional state synchronization between React components
 * and the Tambo backend. State changes are debounced before syncing to
 * the server, and server state updates are reflected in the component.
 *
 * Must be used within a component rendered via the component renderer.
 */
const react_1 = require("react");
const use_debounce_1 = require("use-debounce");
const fast_equals_1 = require("fast-equals");
const tambo_client_provider_1 = require("../../providers/tambo-client-provider");
const component_renderer_1 = require("../utils/component-renderer");
const tambo_v1_stream_context_1 = require("../providers/tambo-v1-stream-context");
/**
 * Find a component content block by ID in a specific thread.
 * Only searches the specified thread to prevent cross-thread data access
 * and improve performance (O(m*k) instead of O(n*m*k)).
 * @param streamState - The current stream state
 * @param threadId - The thread ID to search in
 * @param componentId - The component ID to find
 * @returns The component content block, or undefined if not found
 */
function findComponentContent(streamState, threadId, componentId) {
    // Only search the specified thread (not all threads)
    const threadState = streamState.threadMap[threadId];
    if (!threadState) {
        return undefined;
    }
    for (const message of threadState.thread.messages) {
        for (const content of message.content) {
            if (content.type === "component" && content.id === componentId) {
                return content;
            }
        }
    }
    return undefined;
}
function useTamboV1ComponentState(keyName, initialValue, debounceTime = 500) {
    const client = (0, tambo_client_provider_1.useTamboClient)();
    const { componentId, threadId } = (0, component_renderer_1.useV1ComponentContent)();
    const streamState = (0, tambo_v1_stream_context_1.useStreamState)();
    // Find the component content to get server state (only search current thread)
    const componentContent = findComponentContent(streamState, threadId, componentId);
    const serverState = componentContent?.state;
    const serverValue = serverState?.[keyName];
    // Local state - initialized from server state or initial value
    const [localState, setLocalState] = (0, react_1.useState)(() => serverValue ?? initialValue);
    // Track pending state and errors
    const [isPending, setIsPending] = (0, react_1.useState)(false);
    const [error, setError] = (0, react_1.useState)(null);
    // Track the last value we sent to avoid overwriting with stale server state
    const lastSentValueRef = (0, react_1.useRef)(undefined);
    // Track whether there's a pending local change that hasn't synced yet
    const hasPendingLocalChangeRef = (0, react_1.useRef)(false);
    // Track in-flight sync requests to avoid stale completions clearing pending state
    const syncSeqRef = (0, react_1.useRef)(0);
    // Debounced function to sync state to server
    const syncToServer = (0, use_debounce_1.useDebouncedCallback)(async (newState) => {
        const seq = ++syncSeqRef.current;
        setIsPending(true);
        setError(null);
        lastSentValueRef.current = newState;
        try {
            await client.threads.state.updateState(componentId, {
                threadId,
                state: { [keyName]: newState },
            });
            // Clear pending flag after successful sync
            hasPendingLocalChangeRef.current = false;
        }
        catch (err) {
            // Clear pending flag on error to allow server reconciliation
            hasPendingLocalChangeRef.current = false;
            const syncError = err instanceof Error ? err : new Error(String(err));
            setError(syncError);
            console.error(`[useTamboV1ComponentState] Failed to sync state for ${componentId}:`, syncError);
        }
        finally {
            // Only clear isPending if this is the most recent request
            if (seq === syncSeqRef.current) {
                setIsPending(false);
            }
        }
    }, debounceTime);
    // setState function that updates local state and triggers debounced sync
    const setState = (0, react_1.useCallback)((newState) => {
        setLocalState((prev) => {
            const nextState = typeof newState === "function"
                ? newState(prev)
                : newState;
            // Mark that we have a pending local change
            hasPendingLocalChangeRef.current = true;
            // Trigger debounced sync to server
            void syncToServer(nextState);
            return nextState;
        });
    }, [syncToServer]);
    // Sync from server state when it changes (e.g., from streaming events)
    (0, react_1.useEffect)(() => {
        if (serverValue === undefined) {
            return;
        }
        // Don't overwrite local changes that haven't synced yet
        if (hasPendingLocalChangeRef.current) {
            return;
        }
        // Only sync if the server value is different from what we last sent
        // This prevents overwriting local state with stale server values
        if (lastSentValueRef.current !== undefined &&
            (0, fast_equals_1.deepEqual)(serverValue, lastSentValueRef.current)) {
            return;
        }
        // Use functional update to avoid localState in deps
        setLocalState((prev) => (0, fast_equals_1.deepEqual)(serverValue, prev) ? prev : serverValue);
    }, [serverValue]);
    // Flush pending updates on unmount
    (0, react_1.useEffect)(() => {
        return () => {
            void syncToServer.flush();
        };
    }, [syncToServer]);
    // Flush function for immediate sync
    const flush = (0, react_1.useCallback)(() => {
        void syncToServer.flush();
    }, [syncToServer]);
    return [localState, setState, { isPending, error, flush }];
}
//# sourceMappingURL=use-tambo-v1-component-state.js.map