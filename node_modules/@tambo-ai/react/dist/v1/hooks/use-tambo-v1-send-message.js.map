{"version":3,"file":"use-tambo-v1-send-message.js","sourceRoot":"","sources":["../../../src/v1/hooks/use-tambo-v1-send-message.ts"],"names":[],"mappings":"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","sourcesContent":["\"use client\";\n\n/**\n * Send Message Hook for v1 API\n *\n * React Query mutation hook for sending messages and handling streaming responses.\n */\n\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { useContext } from \"react\";\nimport { EventType, type RunErrorEvent } from \"@ag-ui/core\";\nimport { asTamboCustomEvent, type RunAwaitingInputEvent } from \"../types/event\";\nimport type TamboAI from \"@tambo-ai/typescript-sdk\";\nimport type { Stream } from \"@tambo-ai/typescript-sdk/core/streaming\";\nimport { useTamboClient } from \"../../providers/tambo-client-provider\";\nimport {\n  TamboRegistryContext,\n  type TamboRegistryContext as TamboRegistry,\n} from \"../../providers/tambo-registry-provider\";\nimport { useStreamDispatch } from \"../providers/tambo-v1-stream-context\";\nimport { useTamboV1Config } from \"../providers/tambo-v1-provider\";\nimport type { InputMessage } from \"../types/message\";\nimport {\n  toAvailableComponents,\n  toAvailableTools,\n} from \"../utils/registry-conversion\";\nimport { handleEventStream } from \"../utils/stream-handler\";\nimport { executeAllPendingTools } from \"../utils/tool-executor\";\nimport { ToolCallTracker } from \"../utils/tool-call-tracker\";\n\n/**\n * Options for sending a message\n */\nexport interface SendMessageOptions {\n  /**\n   * The message to send\n   */\n  message: InputMessage;\n\n  /**\n   * Enable debug logging for the stream\n   */\n  debug?: boolean;\n}\n\n/**\n * Parameters for creating a run stream\n */\nexport interface CreateRunStreamParams {\n  client: TamboAI;\n  threadId: string | undefined;\n  message: InputMessage;\n  registry: TamboRegistry;\n  userKey: string | undefined;\n}\n\n/**\n * Stream types from the SDK\n */\ntype RunStream = Stream<TamboAI.Threads.Runs.RunRunResponse>;\ntype CreateStream = Stream<TamboAI.Threads.Runs.RunCreateResponse>;\n\n/**\n * Result from creating a run stream\n */\nexport interface CreateRunStreamResult {\n  stream: RunStream | CreateStream;\n  initialThreadId: string | undefined;\n}\n\n/**\n * Parameters for executing tools and continuing the run\n */\ninterface ExecuteToolsParams {\n  event: RunAwaitingInputEvent;\n  toolTracker: ToolCallTracker;\n  registry: TamboRegistry;\n  client: TamboAI;\n  threadId: string;\n  runId: string;\n  userKey: string | undefined;\n}\n\n/**\n * Executes pending tools and returns a continuation stream.\n *\n * This function does NOT process the continuation stream - it just executes\n * the tools and returns the new stream for the caller to process. This enables\n * the flat loop pattern that correctly handles multi-round tool execution.\n * @param params - The parameters for tool execution\n * @returns The continuation stream to process\n */\nasync function executeToolsAndContinue(\n  params: ExecuteToolsParams,\n): Promise<RunStream> {\n  const { event, toolTracker, registry, client, threadId, runId, userKey } =\n    params;\n\n  const { pendingToolCallIds } = event.value;\n  const toolCallsToExecute = toolTracker.getToolCallsById(pendingToolCallIds);\n\n  // Execute tools\n  const toolResults = await executeAllPendingTools(\n    toolCallsToExecute,\n    registry.toolRegistry,\n  );\n\n  // Clear executed tool calls before continuing\n  toolTracker.clearToolCalls(pendingToolCallIds);\n\n  // Return the continuation stream (caller will process it)\n  return await client.threads.runs.run(threadId, {\n    message: {\n      role: \"user\",\n      content: toolResults,\n    },\n    previousRunId: runId,\n    availableComponents: toAvailableComponents(registry.componentList),\n    tools: toAvailableTools(registry.toolRegistry),\n    userKey,\n  });\n}\n\n/**\n * Creates a run stream by calling the appropriate API method.\n *\n * If threadId is provided, runs on existing thread via client.threads.runs.run().\n * If no threadId, creates new thread via client.threads.runs.create().\n * @param params - The parameters for creating the run stream\n * @returns The stream and initial thread ID (undefined if creating new thread)\n */\nexport async function createRunStream(\n  params: CreateRunStreamParams,\n): Promise<CreateRunStreamResult> {\n  const { client, threadId, message, registry, userKey } = params;\n\n  // Convert registry components/tools to v1 API format\n  const availableComponents = toAvailableComponents(registry.componentList);\n  const availableTools = toAvailableTools(registry.toolRegistry);\n\n  if (threadId) {\n    // Run on existing thread\n    const stream = await client.threads.runs.run(threadId, {\n      message,\n      availableComponents,\n      tools: availableTools,\n      userKey,\n    });\n    return { stream, initialThreadId: threadId };\n  } else {\n    // Create new thread\n    const stream = await client.threads.runs.create({\n      message,\n      availableComponents,\n      tools: availableTools,\n      thread: userKey ? { userKey } : undefined,\n    });\n    // threadId will be extracted from first event (RUN_STARTED)\n    return { stream, initialThreadId: undefined };\n  }\n}\n\n/**\n * Hook to send a message and handle streaming responses.\n *\n * This hook handles two scenarios:\n * - If threadId provided: runs on existing thread via client.threads.runs.run()\n * - If no threadId: creates new thread via client.threads.runs.create()\n *\n * The hook:\n * - Sends a user message to the API\n * - Streams AG-UI events in real-time\n * - Dispatches events to the stream reducer\n * - Extracts threadId from events when creating new thread\n * - Handles tool execution (Phase 6)\n * - Invalidates thread queries on completion\n * @param threadId - Optional thread ID to send message to. If not provided, creates new thread\n * @returns React Query mutation object with threadId in mutation result\n * @example\n * ```tsx\n * function ChatInput({ threadId }: { threadId?: string }) {\n *   const sendMessage = useTamboV1SendMessage(threadId);\n *\n *   const handleSubmit = async (text: string) => {\n *     const result = await sendMessage.mutateAsync({\n *       message: {\n *         role: \"user\",\n *         content: [{ type: \"text\", text }],\n *       },\n *     });\n *\n *     // If threadId wasn't provided, a new thread was created\n *     if (!threadId) {\n *       console.log(\"Created thread:\", result.threadId);\n *     }\n *   };\n *\n *   return (\n *     <div>\n *       <input onSubmit={handleSubmit} />\n *       {sendMessage.isPending && <Spinner />}\n *     </div>\n *   );\n * }\n * ```\n */\nexport function useTamboV1SendMessage(threadId?: string) {\n  const client = useTamboClient();\n  const dispatch = useStreamDispatch();\n  const { userKey } = useTamboV1Config();\n  const registry = useContext(TamboRegistryContext);\n  const queryClient = useQueryClient();\n\n  if (!registry) {\n    throw new Error(\n      \"useTamboV1SendMessage must be used within TamboRegistryProvider\",\n    );\n  }\n\n  return useMutation({\n    mutationFn: async (options: SendMessageOptions) => {\n      const { message, debug = false } = options;\n\n      const toolTracker = new ToolCallTracker();\n\n      // Create the run stream\n      const { stream, initialThreadId } = await createRunStream({\n        client,\n        threadId,\n        message,\n        registry,\n        userKey,\n      });\n\n      let actualThreadId = initialThreadId;\n      let runId: string | undefined;\n      let currentStream: CreateRunStreamResult[\"stream\"] = stream;\n\n      try {\n        // Outer loop handles stream replacement for multi-round tool execution.\n        // When we hit awaiting_input, we execute tools, get a new stream, and continue.\n        // This flat loop pattern correctly handles tool→AI→tool→AI chains.\n        while (true) {\n          let pendingAwaitingInput: RunAwaitingInputEvent | undefined;\n\n          // Process current stream until completion or awaiting_input\n          for await (const event of handleEventStream(currentStream, {\n            debug,\n          })) {\n            // Extract threadId and runId from RUN_STARTED event\n            if (event.type === EventType.RUN_STARTED) {\n              runId = event.runId;\n              actualThreadId ??= event.threadId;\n            } else if (!actualThreadId) {\n              throw new Error(\n                `Expected first event to be RUN_STARTED with threadId, got: ${event.type}`,\n              );\n            }\n\n            toolTracker.handleEvent(event);\n            dispatch({ type: \"EVENT\", event, threadId: actualThreadId });\n\n            // Check for awaiting_input - if found, break to execute tools\n            if (event.type === EventType.CUSTOM) {\n              const customEvent = asTamboCustomEvent(event);\n              if (customEvent?.name === \"tambo.run.awaiting_input\") {\n                pendingAwaitingInput = customEvent;\n                break; // Exit stream loop to handle tool execution\n              }\n            }\n          }\n\n          // If stream finished without awaiting_input, we're done\n          if (!pendingAwaitingInput) {\n            break;\n          }\n\n          // Execute tools and get continuation stream\n          // These checks should never fail since awaiting_input comes after RUN_STARTED\n          if (!runId || !actualThreadId) {\n            throw new Error(\n              \"Cannot continue run after awaiting_input: missing runId or threadId\",\n            );\n          }\n\n          currentStream = await executeToolsAndContinue({\n            event: pendingAwaitingInput,\n            toolTracker,\n            registry,\n            client,\n            threadId: actualThreadId,\n            runId,\n            userKey,\n          });\n        }\n\n        return { threadId: actualThreadId };\n      } catch (error) {\n        // Dispatch a synthetic RUN_ERROR event to clean up thread state\n        // This ensures the thread doesn't stay stuck in \"streaming\" status\n        if (actualThreadId) {\n          const errorMessage =\n            error instanceof Error ? error.message : \"Unknown streaming error\";\n          const errorEvent: RunErrorEvent = {\n            type: EventType.RUN_ERROR,\n            message: errorMessage,\n          };\n          dispatch({\n            type: \"EVENT\",\n            event: errorEvent,\n            threadId: actualThreadId,\n          });\n        }\n        throw error;\n      }\n    },\n    onSuccess: async (result) => {\n      // Invalidate thread queries to refetch updated state\n      await queryClient.invalidateQueries({\n        queryKey: [\"v1-threads\", result.threadId],\n      });\n    },\n    onError: (error) => {\n      console.error(\"[useTamboV1SendMessage] Mutation failed:\", error);\n    },\n  });\n}\n"]}