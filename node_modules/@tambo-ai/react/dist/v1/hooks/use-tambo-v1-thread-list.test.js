"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_query_1 = require("@tanstack/react-query");
const react_1 = require("@testing-library/react");
const react_2 = __importDefault(require("react"));
const tambo_client_provider_1 = require("../../providers/tambo-client-provider");
const use_tambo_v1_thread_list_1 = require("./use-tambo-v1-thread-list");
jest.mock("../../providers/tambo-client-provider", () => ({
    useTamboClient: jest.fn(),
}));
describe("useTamboV1ThreadList", () => {
    const mockThreads = {
        threads: [
            { id: "thread_1", runStatus: "idle" },
            { id: "thread_2", runStatus: "complete" },
        ],
        hasMore: false,
        nextCursor: undefined,
    };
    const mockThreadsApi = {
        retrieve: jest.fn(),
        list: jest.fn(),
    };
    const mockTamboAI = {
        apiKey: "",
        threads: mockThreadsApi,
    };
    let queryClient;
    function TestWrapper({ children }) {
        return (react_2.default.createElement(react_query_1.QueryClientProvider, { client: queryClient }, children));
    }
    beforeEach(() => {
        queryClient = new react_query_1.QueryClient({
            defaultOptions: {
                queries: {
                    retry: false,
                },
            },
        });
        jest.mocked(tambo_client_provider_1.useTamboClient).mockReturnValue(mockTamboAI);
        mockThreadsApi.list.mockReset();
    });
    it("fetches thread list", async () => {
        mockThreadsApi.list.mockResolvedValue(mockThreads);
        const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_thread_list_1.useTamboV1ThreadList)(), {
            wrapper: TestWrapper,
        });
        await (0, react_1.waitFor)(() => {
            expect(result.current.data).toEqual(mockThreads);
        });
        expect(mockThreadsApi.list).toHaveBeenCalledWith(undefined);
    });
    it("passes list options to API", async () => {
        mockThreadsApi.list.mockResolvedValue(mockThreads);
        const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_thread_list_1.useTamboV1ThreadList)({
            userKey: "test-context",
            limit: "10",
        }), { wrapper: TestWrapper });
        await (0, react_1.waitFor)(() => {
            expect(result.current.data).toEqual(mockThreads);
        });
        expect(mockThreadsApi.list).toHaveBeenCalledWith({
            userKey: "test-context",
            limit: "10",
        });
    });
    it("handles loading state", async () => {
        let resolvePromise;
        const promise = new Promise((resolve) => {
            resolvePromise = resolve;
        });
        mockThreadsApi.list.mockReturnValue(promise);
        const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_thread_list_1.useTamboV1ThreadList)(), {
            wrapper: TestWrapper,
        });
        expect(result.current.isLoading).toBe(true);
        expect(result.current.data).toBeUndefined();
        resolvePromise(mockThreads);
        await (0, react_1.waitFor)(() => {
            expect(result.current.isLoading).toBe(false);
        });
    });
    it("handles error state", async () => {
        const mockError = new Error("Failed to fetch threads");
        mockThreadsApi.list.mockRejectedValue(mockError);
        const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_thread_list_1.useTamboV1ThreadList)(), {
            wrapper: TestWrapper,
        });
        await (0, react_1.waitFor)(() => {
            expect(result.current.isError).toBe(true);
            expect(result.current.error).toBe(mockError);
        });
    });
});
//# sourceMappingURL=use-tambo-v1-thread-list.test.js.map