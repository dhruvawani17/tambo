"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_query_1 = require("@tanstack/react-query");
const react_1 = require("@testing-library/react");
const react_2 = __importDefault(require("react"));
const tambo_client_provider_1 = require("../../providers/tambo-client-provider");
const use_tambo_v1_thread_1 = require("./use-tambo-v1-thread");
jest.mock("../../providers/tambo-client-provider", () => ({
    useTamboClient: jest.fn(),
}));
describe("useTamboV1Thread", () => {
    const mockThread = {
        id: "thread_123",
        runStatus: "idle",
        messages: [],
        createdAt: "2024-01-01T00:00:00.000Z",
        updatedAt: "2024-01-01T00:00:00.000Z",
    };
    const mockThreadsApi = {
        retrieve: jest.fn(),
        list: jest.fn(),
    };
    const mockTamboAI = {
        apiKey: "",
        threads: mockThreadsApi,
    };
    let queryClient;
    function TestWrapper({ children }) {
        return (react_2.default.createElement(react_query_1.QueryClientProvider, { client: queryClient }, children));
    }
    beforeEach(() => {
        queryClient = new react_query_1.QueryClient({
            defaultOptions: {
                queries: {
                    retry: false,
                },
            },
        });
        jest.mocked(tambo_client_provider_1.useTamboClient).mockReturnValue(mockTamboAI);
        mockThreadsApi.retrieve.mockReset();
    });
    it("fetches thread by ID", async () => {
        mockThreadsApi.retrieve.mockResolvedValue(mockThread);
        const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_thread_1.useTamboV1Thread)("thread_123"), {
            wrapper: TestWrapper,
        });
        await (0, react_1.waitFor)(() => {
            expect(result.current.data).toEqual(mockThread);
        });
        expect(mockThreadsApi.retrieve).toHaveBeenCalledWith("thread_123");
    });
    it("handles loading state", async () => {
        let resolvePromise;
        const promise = new Promise((resolve) => {
            resolvePromise = resolve;
        });
        mockThreadsApi.retrieve.mockReturnValue(promise);
        const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_thread_1.useTamboV1Thread)("thread_123"), {
            wrapper: TestWrapper,
        });
        expect(result.current.isLoading).toBe(true);
        expect(result.current.data).toBeUndefined();
        resolvePromise(mockThread);
        await (0, react_1.waitFor)(() => {
            expect(result.current.isLoading).toBe(false);
        });
    });
    it("handles error state", async () => {
        const mockError = new Error("Thread not found");
        mockThreadsApi.retrieve.mockRejectedValue(mockError);
        const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_thread_1.useTamboV1Thread)("thread_123"), {
            wrapper: TestWrapper,
        });
        await (0, react_1.waitFor)(() => {
            expect(result.current.isError).toBe(true);
            expect(result.current.error).toBe(mockError);
        });
    });
});
//# sourceMappingURL=use-tambo-v1-thread.test.js.map