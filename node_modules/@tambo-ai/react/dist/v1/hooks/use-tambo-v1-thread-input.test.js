"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = require("@testing-library/react");
const react_2 = __importDefault(require("react"));
const react_query_1 = require("@tanstack/react-query");
const tambo_v1_thread_input_provider_1 = require("../providers/tambo-v1-thread-input-provider");
const tambo_v1_stream_context_1 = require("../providers/tambo-v1-stream-context");
const use_tambo_v1_send_message_1 = require("./use-tambo-v1-send-message");
// Mock useTamboV1SendMessage
jest.mock("./use-tambo-v1-send-message", () => ({
    useTamboV1SendMessage: jest.fn(),
}));
// Mock useTamboQueryClient to avoid TamboClientProvider dependency
jest.mock("../../providers/tambo-client-provider", () => ({
    useTamboQueryClient: jest.fn(() => new react_query_1.QueryClient()),
    useTamboClient: jest.fn(),
}));
const createSuccessfulFileReader = () => {
    const reader = {
        readAsDataURL: jest.fn(),
        onload: null,
        onerror: null,
        result: "data:image/png;base64,mock-data",
    };
    reader.readAsDataURL = jest.fn(() => {
        setTimeout(() => {
            reader.onload?.({});
        }, 0);
    });
    return reader;
};
const originalFileReader = global.FileReader;
describe("useTamboV1ThreadInput", () => {
    const mockMutateAsync = jest.fn();
    let queryClient;
    function createWrapper({ streamState } = {}) {
        const noopDispatch = () => { };
        return function Wrapper({ children }) {
            const streamProviderProps = streamState === undefined
                ? {}
                : { state: streamState, dispatch: noopDispatch };
            return (react_2.default.createElement(react_query_1.QueryClientProvider, { client: queryClient },
                react_2.default.createElement(tambo_v1_stream_context_1.TamboV1StreamProvider, { ...streamProviderProps },
                    react_2.default.createElement(tambo_v1_thread_input_provider_1.TamboV1ThreadInputProvider, null, children))));
        };
    }
    beforeEach(() => {
        jest.clearAllMocks();
        global.FileReader = jest.fn(() => createSuccessfulFileReader());
        queryClient = new react_query_1.QueryClient({
            defaultOptions: {
                queries: { retry: false },
                mutations: { retry: false },
            },
        });
        mockMutateAsync.mockResolvedValue({ threadId: "thread_123" });
        jest.mocked(use_tambo_v1_send_message_1.useTamboV1SendMessage).mockReturnValue({
            mutateAsync: mockMutateAsync,
            mutate: jest.fn(),
            isPending: false,
            isError: false,
            error: null,
            isSuccess: false,
            isIdle: true,
            isPaused: false,
            status: "idle",
            data: undefined,
            variables: undefined,
            failureCount: 0,
            failureReason: null,
            reset: jest.fn(),
            context: undefined,
            submittedAt: 0,
        });
    });
    afterEach(() => {
        global.FileReader = originalFileReader;
    });
    describe("State Management", () => {
        it("initializes with empty value", () => {
            const { result } = (0, react_1.renderHook)(() => (0, tambo_v1_thread_input_provider_1.useTamboV1ThreadInput)(), {
                wrapper: createWrapper(),
            });
            expect(result.current.value).toBe("");
        });
        it("updates value via setValue", () => {
            const { result } = (0, react_1.renderHook)(() => (0, tambo_v1_thread_input_provider_1.useTamboV1ThreadInput)(), {
                wrapper: createWrapper(),
            });
            (0, react_1.act)(() => {
                result.current.setValue("Hello world");
            });
            expect(result.current.value).toBe("Hello world");
        });
        it("supports functional updates for setValue", () => {
            const { result } = (0, react_1.renderHook)(() => (0, tambo_v1_thread_input_provider_1.useTamboV1ThreadInput)(), {
                wrapper: createWrapper(),
            });
            (0, react_1.act)(() => {
                result.current.setValue("Hello");
            });
            (0, react_1.act)(() => {
                result.current.setValue((prev) => `${prev} world`);
            });
            expect(result.current.value).toBe("Hello world");
        });
    });
    describe("Submit Behavior", () => {
        it("submits message and clears input on success", async () => {
            const { result } = (0, react_1.renderHook)(() => (0, tambo_v1_thread_input_provider_1.useTamboV1ThreadInput)(), {
                wrapper: createWrapper(),
            });
            (0, react_1.act)(() => {
                result.current.setValue("Test message");
            });
            await (0, react_1.act)(async () => {
                const response = await result.current.submit();
                expect(response.threadId).toBe("thread_123");
            });
            // Input should be cleared
            await (0, react_1.waitFor)(() => {
                expect(result.current.value).toBe("");
            });
            // Should have called mutateAsync with correct message format
            expect(mockMutateAsync).toHaveBeenCalledWith({
                message: {
                    role: "user",
                    content: [{ type: "text", text: "Test message" }],
                },
                debug: undefined,
            });
        });
        it("throws error when submitting empty message", async () => {
            const { result } = (0, react_1.renderHook)(() => (0, tambo_v1_thread_input_provider_1.useTamboV1ThreadInput)(), {
                wrapper: createWrapper(),
            });
            await expect(result.current.submit()).rejects.toThrow("Message cannot be empty");
            expect(mockMutateAsync).not.toHaveBeenCalled();
        });
        it("throws error when submitting whitespace-only message", async () => {
            const { result } = (0, react_1.renderHook)(() => (0, tambo_v1_thread_input_provider_1.useTamboV1ThreadInput)(), {
                wrapper: createWrapper(),
            });
            (0, react_1.act)(() => {
                result.current.setValue("   ");
            });
            await expect(result.current.submit()).rejects.toThrow("Message cannot be empty");
            expect(mockMutateAsync).not.toHaveBeenCalled();
        });
        it("passes debug option to mutation", async () => {
            const { result } = (0, react_1.renderHook)(() => (0, tambo_v1_thread_input_provider_1.useTamboV1ThreadInput)(), {
                wrapper: createWrapper(),
            });
            (0, react_1.act)(() => {
                result.current.setValue("Debug message");
            });
            await (0, react_1.act)(async () => {
                await result.current.submit({ debug: true });
            });
            expect(mockMutateAsync).toHaveBeenCalledWith({
                message: {
                    role: "user",
                    content: [{ type: "text", text: "Debug message" }],
                },
                debug: true,
            });
        });
        it("submits image-only messages as resource content", async () => {
            const { result } = (0, react_1.renderHook)(() => (0, tambo_v1_thread_input_provider_1.useTamboV1ThreadInput)(), {
                wrapper: createWrapper(),
            });
            await (0, react_1.act)(async () => {
                await result.current.addImage(new File(["image"], "photo.png", { type: "image/png" }));
            });
            await (0, react_1.act)(async () => {
                await result.current.submit();
            });
            expect(mockMutateAsync).toHaveBeenCalledWith({
                message: {
                    role: "user",
                    content: [
                        {
                            type: "resource",
                            resource: {
                                blob: "mock-data",
                                mimeType: "image/png",
                                name: "photo.png",
                            },
                        },
                    ],
                },
                debug: undefined,
            });
            await (0, react_1.waitFor)(() => {
                expect(result.current.images).toEqual([]);
            });
        });
        it("includes both text and image resource content when both are present", async () => {
            const { result } = (0, react_1.renderHook)(() => (0, tambo_v1_thread_input_provider_1.useTamboV1ThreadInput)(), {
                wrapper: createWrapper(),
            });
            (0, react_1.act)(() => {
                result.current.setValue("Test message");
            });
            await (0, react_1.act)(async () => {
                await result.current.addImage(new File(["image"], "photo.png", { type: "image/png" }));
            });
            await (0, react_1.act)(async () => {
                await result.current.submit();
            });
            expect(mockMutateAsync).toHaveBeenCalledWith({
                message: {
                    role: "user",
                    content: [
                        { type: "text", text: "Test message" },
                        {
                            type: "resource",
                            resource: {
                                blob: "mock-data",
                                mimeType: "image/png",
                                name: "photo.png",
                            },
                        },
                    ],
                },
                debug: undefined,
            });
        });
    });
    describe("Thread ID Management", () => {
        it("initializes with undefined threadId", () => {
            const { result } = (0, react_1.renderHook)(() => (0, tambo_v1_thread_input_provider_1.useTamboV1ThreadInput)(), {
                wrapper: createWrapper(),
            });
            expect(result.current.threadId).toBeUndefined();
        });
        it("allows setting threadId via setThreadId", () => {
            const { result } = (0, react_1.renderHook)(() => (0, tambo_v1_thread_input_provider_1.useTamboV1ThreadInput)(), {
                wrapper: createWrapper(),
            });
            (0, react_1.act)(() => {
                result.current.setThreadId("custom_thread_id");
            });
            expect(result.current.threadId).toBe("custom_thread_id");
        });
        it("does not take ownership of threadId when inheriting stream selection", async () => {
            const { result } = (0, react_1.renderHook)(() => (0, tambo_v1_thread_input_provider_1.useTamboV1ThreadInput)(), {
                wrapper: createWrapper({
                    streamState: { threadMap: {}, currentThreadId: "thread_stream" },
                }),
            });
            expect(result.current.threadId).toBe("thread_stream");
            expect(jest.mocked(use_tambo_v1_send_message_1.useTamboV1SendMessage).mock.calls.map((call) => call[0])).toContain("thread_stream");
            (0, react_1.act)(() => {
                result.current.setValue("Test message");
            });
            await (0, react_1.act)(async () => {
                await result.current.submit();
            });
            expect(result.current.threadId).toBe("thread_stream");
            expect(jest.mocked(use_tambo_v1_send_message_1.useTamboV1SendMessage).mock.calls.map((call) => call[0])).not.toContain("thread_123");
        });
    });
    describe("Image State", () => {
        it("initializes with empty images array", () => {
            const { result } = (0, react_1.renderHook)(() => (0, tambo_v1_thread_input_provider_1.useTamboV1ThreadInput)(), {
                wrapper: createWrapper(),
            });
            expect(result.current.images).toEqual([]);
        });
        it("exposes image management functions", () => {
            const { result } = (0, react_1.renderHook)(() => (0, tambo_v1_thread_input_provider_1.useTamboV1ThreadInput)(), {
                wrapper: createWrapper(),
            });
            expect(typeof result.current.addImage).toBe("function");
            expect(typeof result.current.addImages).toBe("function");
            expect(typeof result.current.removeImage).toBe("function");
            expect(typeof result.current.clearImages).toBe("function");
        });
    });
    describe("Error handling", () => {
        it("throws error when used outside provider", () => {
            // Suppress console.error for this test
            const consoleSpy = jest
                .spyOn(console, "error")
                .mockImplementation(() => { });
            expect(() => {
                (0, react_1.renderHook)(() => (0, tambo_v1_thread_input_provider_1.useTamboV1ThreadInput)());
            }).toThrow("useTamboV1ThreadInput must be used within TamboV1ThreadInputProvider");
            consoleSpy.mockRestore();
        });
    });
});
//# sourceMappingURL=use-tambo-v1-thread-input.test.js.map