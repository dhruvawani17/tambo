"use strict";
"use client";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRunStream = createRunStream;
exports.useTamboV1SendMessage = useTamboV1SendMessage;
/**
 * Send Message Hook for v1 API
 *
 * React Query mutation hook for sending messages and handling streaming responses.
 */
const react_query_1 = require("@tanstack/react-query");
const react_1 = require("react");
const core_1 = require("@ag-ui/core");
const event_1 = require("../types/event");
const tambo_client_provider_1 = require("../../providers/tambo-client-provider");
const tambo_registry_provider_1 = require("../../providers/tambo-registry-provider");
const tambo_v1_stream_context_1 = require("../providers/tambo-v1-stream-context");
const tambo_v1_provider_1 = require("../providers/tambo-v1-provider");
const registry_conversion_1 = require("../utils/registry-conversion");
const stream_handler_1 = require("../utils/stream-handler");
const tool_executor_1 = require("../utils/tool-executor");
const tool_call_tracker_1 = require("../utils/tool-call-tracker");
/**
 * Executes pending tools and returns a continuation stream.
 *
 * This function does NOT process the continuation stream - it just executes
 * the tools and returns the new stream for the caller to process. This enables
 * the flat loop pattern that correctly handles multi-round tool execution.
 * @param params - The parameters for tool execution
 * @returns The continuation stream to process
 */
async function executeToolsAndContinue(params) {
    const { event, toolTracker, registry, client, threadId, runId, userKey } = params;
    const { pendingToolCallIds } = event.value;
    const toolCallsToExecute = toolTracker.getToolCallsById(pendingToolCallIds);
    // Execute tools
    const toolResults = await (0, tool_executor_1.executeAllPendingTools)(toolCallsToExecute, registry.toolRegistry);
    // Clear executed tool calls before continuing
    toolTracker.clearToolCalls(pendingToolCallIds);
    // Return the continuation stream (caller will process it)
    return await client.threads.runs.run(threadId, {
        message: {
            role: "user",
            content: toolResults,
        },
        previousRunId: runId,
        availableComponents: (0, registry_conversion_1.toAvailableComponents)(registry.componentList),
        tools: (0, registry_conversion_1.toAvailableTools)(registry.toolRegistry),
        userKey,
    });
}
/**
 * Creates a run stream by calling the appropriate API method.
 *
 * If threadId is provided, runs on existing thread via client.threads.runs.run().
 * If no threadId, creates new thread via client.threads.runs.create().
 * @param params - The parameters for creating the run stream
 * @returns The stream and initial thread ID (undefined if creating new thread)
 */
async function createRunStream(params) {
    const { client, threadId, message, registry, userKey } = params;
    // Convert registry components/tools to v1 API format
    const availableComponents = (0, registry_conversion_1.toAvailableComponents)(registry.componentList);
    const availableTools = (0, registry_conversion_1.toAvailableTools)(registry.toolRegistry);
    if (threadId) {
        // Run on existing thread
        const stream = await client.threads.runs.run(threadId, {
            message,
            availableComponents,
            tools: availableTools,
            userKey,
        });
        return { stream, initialThreadId: threadId };
    }
    else {
        // Create new thread
        const stream = await client.threads.runs.create({
            message,
            availableComponents,
            tools: availableTools,
            thread: userKey ? { userKey } : undefined,
        });
        // threadId will be extracted from first event (RUN_STARTED)
        return { stream, initialThreadId: undefined };
    }
}
/**
 * Hook to send a message and handle streaming responses.
 *
 * This hook handles two scenarios:
 * - If threadId provided: runs on existing thread via client.threads.runs.run()
 * - If no threadId: creates new thread via client.threads.runs.create()
 *
 * The hook:
 * - Sends a user message to the API
 * - Streams AG-UI events in real-time
 * - Dispatches events to the stream reducer
 * - Extracts threadId from events when creating new thread
 * - Handles tool execution (Phase 6)
 * - Invalidates thread queries on completion
 * @param threadId - Optional thread ID to send message to. If not provided, creates new thread
 * @returns React Query mutation object with threadId in mutation result
 * @example
 * ```tsx
 * function ChatInput({ threadId }: { threadId?: string }) {
 *   const sendMessage = useTamboV1SendMessage(threadId);
 *
 *   const handleSubmit = async (text: string) => {
 *     const result = await sendMessage.mutateAsync({
 *       message: {
 *         role: "user",
 *         content: [{ type: "text", text }],
 *       },
 *     });
 *
 *     // If threadId wasn't provided, a new thread was created
 *     if (!threadId) {
 *       console.log("Created thread:", result.threadId);
 *     }
 *   };
 *
 *   return (
 *     <div>
 *       <input onSubmit={handleSubmit} />
 *       {sendMessage.isPending && <Spinner />}
 *     </div>
 *   );
 * }
 * ```
 */
function useTamboV1SendMessage(threadId) {
    const client = (0, tambo_client_provider_1.useTamboClient)();
    const dispatch = (0, tambo_v1_stream_context_1.useStreamDispatch)();
    const { userKey } = (0, tambo_v1_provider_1.useTamboV1Config)();
    const registry = (0, react_1.useContext)(tambo_registry_provider_1.TamboRegistryContext);
    const queryClient = (0, react_query_1.useQueryClient)();
    if (!registry) {
        throw new Error("useTamboV1SendMessage must be used within TamboRegistryProvider");
    }
    return (0, react_query_1.useMutation)({
        mutationFn: async (options) => {
            const { message, debug = false } = options;
            const toolTracker = new tool_call_tracker_1.ToolCallTracker();
            // Create the run stream
            const { stream, initialThreadId } = await createRunStream({
                client,
                threadId,
                message,
                registry,
                userKey,
            });
            let actualThreadId = initialThreadId;
            let runId;
            let currentStream = stream;
            try {
                // Outer loop handles stream replacement for multi-round tool execution.
                // When we hit awaiting_input, we execute tools, get a new stream, and continue.
                // This flat loop pattern correctly handles tool→AI→tool→AI chains.
                while (true) {
                    let pendingAwaitingInput;
                    // Process current stream until completion or awaiting_input
                    for await (const event of (0, stream_handler_1.handleEventStream)(currentStream, {
                        debug,
                    })) {
                        // Extract threadId and runId from RUN_STARTED event
                        if (event.type === core_1.EventType.RUN_STARTED) {
                            runId = event.runId;
                            actualThreadId ??= event.threadId;
                        }
                        else if (!actualThreadId) {
                            throw new Error(`Expected first event to be RUN_STARTED with threadId, got: ${event.type}`);
                        }
                        toolTracker.handleEvent(event);
                        dispatch({ type: "EVENT", event, threadId: actualThreadId });
                        // Check for awaiting_input - if found, break to execute tools
                        if (event.type === core_1.EventType.CUSTOM) {
                            const customEvent = (0, event_1.asTamboCustomEvent)(event);
                            if (customEvent?.name === "tambo.run.awaiting_input") {
                                pendingAwaitingInput = customEvent;
                                break; // Exit stream loop to handle tool execution
                            }
                        }
                    }
                    // If stream finished without awaiting_input, we're done
                    if (!pendingAwaitingInput) {
                        break;
                    }
                    // Execute tools and get continuation stream
                    // These checks should never fail since awaiting_input comes after RUN_STARTED
                    if (!runId || !actualThreadId) {
                        throw new Error("Cannot continue run after awaiting_input: missing runId or threadId");
                    }
                    currentStream = await executeToolsAndContinue({
                        event: pendingAwaitingInput,
                        toolTracker,
                        registry,
                        client,
                        threadId: actualThreadId,
                        runId,
                        userKey,
                    });
                }
                return { threadId: actualThreadId };
            }
            catch (error) {
                // Dispatch a synthetic RUN_ERROR event to clean up thread state
                // This ensures the thread doesn't stay stuck in "streaming" status
                if (actualThreadId) {
                    const errorMessage = error instanceof Error ? error.message : "Unknown streaming error";
                    const errorEvent = {
                        type: core_1.EventType.RUN_ERROR,
                        message: errorMessage,
                    };
                    dispatch({
                        type: "EVENT",
                        event: errorEvent,
                        threadId: actualThreadId,
                    });
                }
                throw error;
            }
        },
        onSuccess: async (result) => {
            // Invalidate thread queries to refetch updated state
            await queryClient.invalidateQueries({
                queryKey: ["v1-threads", result.threadId],
            });
        },
        onError: (error) => {
            console.error("[useTamboV1SendMessage] Mutation failed:", error);
        },
    });
}
//# sourceMappingURL=use-tambo-v1-send-message.js.map