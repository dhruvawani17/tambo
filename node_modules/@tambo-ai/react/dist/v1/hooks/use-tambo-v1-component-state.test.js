"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = require("@testing-library/react");
const use_tambo_v1_component_state_1 = require("./use-tambo-v1-component-state");
// Mock the required modules
jest.mock("../../providers/tambo-client-provider", () => ({
    useTamboClient: jest.fn(),
}));
jest.mock("../providers/tambo-v1-stream-context", () => ({
    useStreamState: jest.fn(),
}));
jest.mock("../utils/component-renderer", () => ({
    useV1ComponentContent: jest.fn(),
}));
// Create a mock debounced function with flush method
const createMockDebouncedFunction = (fn) => {
    const debouncedFn = jest.fn((...args) => fn(...args));
    debouncedFn.flush = jest.fn();
    debouncedFn.cancel = jest.fn();
    debouncedFn.isPending = jest.fn(() => false);
    return debouncedFn;
};
// Mock use-debounce
jest.mock("use-debounce", () => ({
    useDebouncedCallback: jest.fn(),
}));
// Import the mocked modules
const tambo_client_provider_1 = require("../../providers/tambo-client-provider");
const tambo_v1_stream_context_1 = require("../providers/tambo-v1-stream-context");
const component_renderer_1 = require("../utils/component-renderer");
const use_debounce_1 = require("use-debounce");
describe("useTamboV1ComponentState", () => {
    const mockUpdateState = jest.fn();
    const mockComponentId = "comp_test123";
    const mockThreadId = "thread_abc";
    const mockMessageId = "msg_xyz";
    // Helper to create mock stream state
    const createMockStreamState = (componentState) => ({
        threadMap: {
            [mockThreadId]: {
                thread: {
                    id: mockThreadId,
                    messages: [
                        {
                            id: mockMessageId,
                            role: "assistant",
                            content: [
                                {
                                    type: "component",
                                    id: mockComponentId,
                                    name: "TestComponent",
                                    props: {},
                                    state: componentState,
                                    streamingState: "done",
                                },
                            ],
                            createdAt: new Date().toISOString(),
                        },
                    ],
                    status: "idle",
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                },
                streaming: { status: "idle" },
                accumulatingToolArgs: new Map(),
            },
        },
        currentThreadId: mockThreadId,
    });
    beforeEach(() => {
        jest.clearAllMocks();
        // Setup default mocks
        jest.mocked(tambo_client_provider_1.useTamboClient).mockReturnValue({
            threads: {
                state: {
                    updateState: mockUpdateState,
                },
            },
        });
        jest.mocked(component_renderer_1.useV1ComponentContent).mockReturnValue({
            componentId: mockComponentId,
            threadId: mockThreadId,
            messageId: mockMessageId,
            componentName: "TestComponent",
        });
        jest.mocked(tambo_v1_stream_context_1.useStreamState).mockReturnValue(createMockStreamState());
        // Setup default mock for useDebouncedCallback
        jest
            .mocked(use_debounce_1.useDebouncedCallback)
            .mockImplementation((fn) => createMockDebouncedFunction(fn));
    });
    afterEach(() => {
        jest.restoreAllMocks();
    });
    describe("Initial State Management", () => {
        it("should initialize with initialValue when no server state exists", () => {
            const initialValue = "test-initial";
            jest.mocked(tambo_v1_stream_context_1.useStreamState).mockReturnValue(createMockStreamState({}));
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_component_state_1.useTamboV1ComponentState)("testKey", initialValue));
            expect(result.current[0]).toBe(initialValue);
        });
        it("should use server state over initialValue", () => {
            const initialValue = "initial";
            const serverValue = "server-value";
            jest
                .mocked(tambo_v1_stream_context_1.useStreamState)
                .mockReturnValue(createMockStreamState({ testKey: serverValue }));
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_component_state_1.useTamboV1ComponentState)("testKey", initialValue));
            expect(result.current[0]).toBe(serverValue);
        });
        it("should handle undefined initialValue gracefully", () => {
            jest.mocked(tambo_v1_stream_context_1.useStreamState).mockReturnValue(createMockStreamState({}));
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_component_state_1.useTamboV1ComponentState)("testKey"));
            expect(result.current[0]).toBeUndefined();
        });
        it("should handle different data types correctly", () => {
            const testCases = [
                { value: "string" },
                { value: 42 },
                { value: true },
                { value: { name: "test" } },
                { value: [1, 2, 3] },
            ];
            testCases.forEach(({ value }) => {
                jest
                    .mocked(tambo_v1_stream_context_1.useStreamState)
                    .mockReturnValue(createMockStreamState({ testKey: value }));
                const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_component_state_1.useTamboV1ComponentState)("testKey", value));
                expect(result.current[0]).toEqual(value);
            });
        });
    });
    describe("State Updates", () => {
        it("should update local state immediately when setState is called", () => {
            const initialValue = "initial";
            jest
                .mocked(tambo_v1_stream_context_1.useStreamState)
                .mockReturnValue(createMockStreamState({ testKey: initialValue }));
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_component_state_1.useTamboV1ComponentState)("testKey", initialValue));
            const newValue = "updated";
            (0, react_1.act)(() => {
                result.current[1](newValue);
            });
            expect(result.current[0]).toBe(newValue);
        });
        it("should support functional updates", () => {
            const initialValue = 5;
            jest
                .mocked(tambo_v1_stream_context_1.useStreamState)
                .mockReturnValue(createMockStreamState({ counter: initialValue }));
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_component_state_1.useTamboV1ComponentState)("counter", initialValue));
            (0, react_1.act)(() => {
                result.current[1]((prev) => (prev ?? 0) + 1);
            });
            expect(result.current[0]).toBe(6);
        });
        it("should trigger debounced API call when setState is called", () => {
            const initialValue = "initial";
            jest
                .mocked(tambo_v1_stream_context_1.useStreamState)
                .mockReturnValue(createMockStreamState({ testKey: initialValue }));
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_component_state_1.useTamboV1ComponentState)("testKey", initialValue));
            const newValue = "updated";
            (0, react_1.act)(() => {
                result.current[1](newValue);
            });
            // The debounced function should be called
            expect(mockUpdateState).toHaveBeenCalledWith(mockComponentId, {
                threadId: mockThreadId,
                state: { testKey: newValue },
            });
        });
        it("should work with complex objects", () => {
            const initialValue = { name: "test", items: [1, 2, 3] };
            jest
                .mocked(tambo_v1_stream_context_1.useStreamState)
                .mockReturnValue(createMockStreamState({ data: initialValue }));
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_component_state_1.useTamboV1ComponentState)("data", initialValue));
            const newValue = { name: "updated", items: [4, 5, 6] };
            (0, react_1.act)(() => {
                result.current[1](newValue);
            });
            expect(result.current[0]).toEqual(newValue);
        });
    });
    describe("Metadata", () => {
        it("should return isPending and error in meta", () => {
            jest.mocked(tambo_v1_stream_context_1.useStreamState).mockReturnValue(createMockStreamState({}));
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_component_state_1.useTamboV1ComponentState)("testKey", "initial"));
            expect(result.current[2]).toEqual({
                isPending: false,
                error: null,
                flush: expect.any(Function),
            });
        });
        it("should provide a flush function", () => {
            const mockFlush = jest.fn();
            const mockDebouncedFn = createMockDebouncedFunction(jest.fn());
            mockDebouncedFn.flush = mockFlush;
            jest.mocked(use_debounce_1.useDebouncedCallback).mockReturnValue(mockDebouncedFn);
            jest.mocked(tambo_v1_stream_context_1.useStreamState).mockReturnValue(createMockStreamState({}));
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_component_state_1.useTamboV1ComponentState)("testKey", "initial"));
            (0, react_1.act)(() => {
                result.current[2].flush();
            });
            expect(mockFlush).toHaveBeenCalled();
        });
    });
    describe("Debouncing Behavior", () => {
        it("should use default debounce time of 500ms", () => {
            jest.mocked(tambo_v1_stream_context_1.useStreamState).mockReturnValue(createMockStreamState({}));
            (0, react_1.renderHook)(() => (0, use_tambo_v1_component_state_1.useTamboV1ComponentState)("testKey", "initial"));
            expect(use_debounce_1.useDebouncedCallback).toHaveBeenCalledWith(expect.any(Function), 500);
        });
        it("should use custom debounce time when provided", () => {
            jest.mocked(tambo_v1_stream_context_1.useStreamState).mockReturnValue(createMockStreamState({}));
            const customDebounceTime = 1000;
            (0, react_1.renderHook)(() => (0, use_tambo_v1_component_state_1.useTamboV1ComponentState)("testKey", "initial", customDebounceTime));
            expect(use_debounce_1.useDebouncedCallback).toHaveBeenCalledWith(expect.any(Function), customDebounceTime);
        });
        it("should flush debounced callback on unmount", () => {
            const mockFlush = jest.fn();
            const mockDebouncedFn = createMockDebouncedFunction(jest.fn());
            mockDebouncedFn.flush = mockFlush;
            jest.mocked(use_debounce_1.useDebouncedCallback).mockReturnValue(mockDebouncedFn);
            jest.mocked(tambo_v1_stream_context_1.useStreamState).mockReturnValue(createMockStreamState({}));
            const { unmount } = (0, react_1.renderHook)(() => (0, use_tambo_v1_component_state_1.useTamboV1ComponentState)("testKey", "initial"));
            unmount();
            expect(mockFlush).toHaveBeenCalled();
        });
    });
    describe("Server State Sync", () => {
        it("should sync with server state changes from streaming", () => {
            const streamState = createMockStreamState({ testKey: "initial" });
            jest.mocked(tambo_v1_stream_context_1.useStreamState).mockReturnValue(streamState);
            const { result, rerender } = (0, react_1.renderHook)(() => (0, use_tambo_v1_component_state_1.useTamboV1ComponentState)("testKey", "initial"));
            expect(result.current[0]).toBe("initial");
            // Simulate server state change from streaming
            const updatedStreamState = createMockStreamState({
                testKey: "updated-from-server",
            });
            jest.mocked(tambo_v1_stream_context_1.useStreamState).mockReturnValue(updatedStreamState);
            rerender();
            expect(result.current[0]).toBe("updated-from-server");
        });
        it("should handle component not found in stream state", () => {
            // Empty stream state (no matching component)
            jest.mocked(tambo_v1_stream_context_1.useStreamState).mockReturnValue({
                threadMap: {},
                currentThreadId: null,
            });
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_component_state_1.useTamboV1ComponentState)("testKey", "default"));
            expect(result.current[0]).toBe("default");
        });
    });
    describe("Error Handling", () => {
        it("should handle API errors gracefully", async () => {
            const mockError = new Error("API Error");
            mockUpdateState.mockRejectedValue(mockError);
            // Create a sync mock that calls the function immediately
            jest.mocked(use_debounce_1.useDebouncedCallback).mockImplementation((fn) => {
                const debouncedFn = Object.assign(async (...args) => fn(...args), {
                    flush: jest.fn(),
                    cancel: jest.fn(),
                    isPending: () => false,
                });
                return debouncedFn;
            });
            jest.mocked(tambo_v1_stream_context_1.useStreamState).mockReturnValue(createMockStreamState({}));
            const consoleSpy = jest.spyOn(console, "error").mockImplementation();
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_v1_component_state_1.useTamboV1ComponentState)("testKey", "initial"));
            await (0, react_1.act)(async () => {
                result.current[1]("new-value");
                // Wait for async operations
                await new Promise((resolve) => setTimeout(resolve, 0));
            });
            expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining("Failed to sync state"), mockError);
            consoleSpy.mockRestore();
        });
    });
    describe("Context Requirements", () => {
        it("should throw when used outside component content context", () => {
            jest.mocked(component_renderer_1.useV1ComponentContent).mockImplementation(() => {
                throw new Error("useV1ComponentContent must be used within a rendered component");
            });
            expect(() => {
                (0, react_1.renderHook)(() => (0, use_tambo_v1_component_state_1.useTamboV1ComponentState)("testKey", "initial"));
            }).toThrow("useV1ComponentContent must be used within a rendered component");
        });
    });
});
//# sourceMappingURL=use-tambo-v1-component-state.test.js.map