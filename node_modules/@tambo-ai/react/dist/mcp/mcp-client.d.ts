import { type OAuthClientProvider } from "@modelcontextprotocol/sdk/client/auth.js";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import type { RequestHandlerExtra } from "@modelcontextprotocol/sdk/shared/protocol.js";
import { ClientNotification, ClientRequest, CreateMessageRequest, CreateMessageResult, ElicitRequest, ElicitResult } from "@modelcontextprotocol/sdk/types.js";
import { JSONSchema7 } from "json-schema";
import { MCPTransport } from "../model/mcp-server-info";
export { MCPTransport };
/**
 * Handler for MCP elicitation requests.
 * Receives the elicit request and a RequestHandlerExtra containing an AbortSignal that fires when the request is cancelled.
 * @param request - The elicitation request from the server
 * @param extra - Additional context including AbortSignal for cancellation
 * @returns Promise resolving to the elicitation result
 * @example
 * ```typescript
 * const handler: MCPElicitationHandler = async (request, extra) => {
 *   // Listen for cancellation
 *   extra.signal.addEventListener('abort', () => {
 *     console.log('Request cancelled');
 *   });
 *
 *   // Return user's response
 *   return {
 *     action: 'accept',
 *     content: { name: 'John' }
 *   };
 * };
 * ```
 */
export type MCPElicitationHandler = (e: ElicitRequest, extra: RequestHandlerExtra<ClientRequest, ClientNotification>) => Promise<ElicitResult>;
/**
 * Handler for MCP sampling requests (create_message).
 * Receives the sampling request and a RequestHandlerExtra containing an AbortSignal that fires when the request is cancelled.
 * @param request - The sampling/create_message request from the server
 * @param extra - Additional context including AbortSignal for cancellation
 * @returns Promise resolving to the sampling result
 */
export type MCPSamplingHandler = (e: CreateMessageRequest, extra: RequestHandlerExtra<ClientRequest, ClientNotification>) => Promise<CreateMessageResult>;
/**
 * Handlers for MCP requests - these are only used if the server supports the corresponding capabilities
 * @param elicitation - Handler for elicitation requests (receives request and RequestHandlerExtra with AbortSignal)
 * @param sampling - Handler for sampling requests (receives request and RequestHandlerExtra with AbortSignal)
 * @example
 * ```typescript
 * const mcp = await MCPClient.create(
 *     'https://api.example.com/mcp',
 *     MCPTransport.HTTP,
 *     {},
 *     undefined,
 *     undefined,
 *     {
 *       elicitation: (e, extra) => Promise.resolve({...}),
 *     },
 * );
 * ```
 */
export interface MCPHandlers {
    elicitation: MCPElicitationHandler;
    sampling: MCPSamplingHandler;
}
/**
 * A client for interacting with MCP (Model Context Protocol) servers.
 * Provides a simple interface for listing and calling tools exposed by the server.
 * @example
 * ```typescript
 * const mcp = await MCPClient.create('https://api.example.com/mcp');
 * const tools = await mcp.listTools();
 * const result = await mcp.callTool('toolName', { arg1: 'value1' });
 * ```
 */
export declare class MCPClient {
    /**
     * The underlying MCP client
     *
     * Be careful not to mutate the client directly, use the methods provided instead.
     */
    client: Client;
    private transport;
    private transportType;
    sessionId?: string;
    private endpoint;
    private headers;
    private authProvider?;
    private handlers;
    /**
     * Private constructor to enforce using the static create method.
     * @param endpoint - The URL of the MCP server to connect to
     * @param transportType - The transport to use for the MCP client
     * @param headers - Optional custom headers to include in requests
     */
    private constructor();
    /**
     * Creates and initializes a new MCPClient instance. This is the recommended
     * way to create an MCPClient as it handles both instantiation and connection
     * setup.
     * @param endpoint - The URL of the MCP server to connect to
     * @param transportType - The transport type to use for the MCP client. Defaults to HTTP.
     * @param headers - Optional custom headers to include in requests
     * @param authProvider - Optional auth provider to use for authentication
     * @param sessionId - Optional session id to use for the MCP client - if not
     *   provided, a new session will be created
     * @returns A connected MCPClient instance ready for use
     * @throws {Error} Will throw an error if connection fails
     */
    static create(endpoint: string, transportType: MCPTransport | undefined, headers: Record<string, string> | undefined, authProvider: OAuthClientProvider | undefined, sessionId: string | undefined, handlers?: Partial<MCPHandlers>): Promise<MCPClient>;
    private initializeTransport;
    /**
     * Initializes the MCP client with the appropriate capabilities and handlers
     * @returns The initialized MCP client
     */
    private initializeClient;
    /**
     * Retrieves a complete list of all available tools from the MCP server.
     * Handles pagination automatically by following cursors until all tools are fetched.
     * @returns A complete list of all available tools and their descriptions
     * @throws {Error} Will throw an error if any server request fails during pagination
     */
    listTools(): Promise<MCPToolSpec[]>;
    getServerCapabilities(): {
        experimental?: {
            [x: string]: object;
        } | undefined;
        logging?: object | undefined;
        completions?: object | undefined;
        prompts?: {
            listChanged?: boolean | undefined;
        } | undefined;
        resources?: {
            subscribe?: boolean | undefined;
            listChanged?: boolean | undefined;
        } | undefined;
        tools?: {
            listChanged?: boolean | undefined;
        } | undefined;
        tasks?: {
            [x: string]: unknown;
            list?: object | undefined;
            cancel?: object | undefined;
            requests?: {
                [x: string]: unknown;
                tools?: {
                    [x: string]: unknown;
                    call?: object | undefined;
                } | undefined;
            } | undefined;
        } | undefined;
    } | undefined;
    getServerVersion(): {
        version: string;
        name: string;
        websiteUrl?: string | undefined;
        description?: string | undefined;
        icons?: {
            src: string;
            mimeType?: string | undefined;
            sizes?: string[] | undefined;
            theme?: "light" | "dark" | undefined;
        }[] | undefined;
        title?: string | undefined;
    } | undefined;
    getInstructions(): string | undefined;
    /**
     * Calls a specific tool on the MCP server with the provided arguments.
     * @param name - The name of the tool to call
     * @param args - Arguments to pass to the tool, must match the tool's expected schema
     * @returns The result from the tool execution
     * @throws {Error} Will throw an error if the tool call fails or if arguments are invalid
     */
    callTool(name: string, args: Record<string, unknown>, _meta?: Record<string, unknown>): Promise<MCPToolCallResult>;
    updateElicitationHandler(handler: MCPElicitationHandler | undefined): void;
    updateSamplingHandler(handler: MCPSamplingHandler | undefined): void;
    close(): Promise<void>;
}
/**
 * The result of a tool call.
 * This is the same as the result of a tool call in the OpenAI SDK, but is reified here
 */
export type MCPToolCallResult = Awaited<ReturnType<typeof Client.prototype.callTool>>;
export interface MCPToolSpec {
    name: string;
    description?: string;
    inputSchema?: JSONSchema7;
    maxCalls?: number;
}
//# sourceMappingURL=mcp-client.d.ts.map