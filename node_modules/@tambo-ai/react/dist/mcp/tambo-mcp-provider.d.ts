import React, { FC } from "react";
import { ServerType } from "./mcp-constants";
import { type NormalizedMcpServerInfo } from "../model/mcp-server-info";
import { type ElicitationContextState } from "./elicitation";
import { MCPClient, MCPElicitationHandler, MCPHandlers, MCPSamplingHandler } from "./mcp-client";
/**
 * Extracts error message from MCP tool result content.
 * Handles both array and string content formats.
 * Always returns a string, even for invalid/null inputs.
 * @returns The extracted error message as a string
 */
export declare function extractErrorMessage(content: unknown): string;
/**
 * Normalized MCP server information as consumed by the provider.
 *
 * Extends `NormalizedMcpServerInfo` from the core model by:
 * - narrowing `handlers` to `Partial<MCPHandlers>`
 * - adding a stable `key` derived from URL/transport/headers
 * - adding `serverType` to distinguish internal vs browser-side servers
 *
 * The registry is responsible for producing `NormalizedMcpServerInfo`
 * instances; this type adds the MCP-specific wiring needed to connect and
 * track clients.
 */
interface McpServerConfig extends NormalizedMcpServerInfo {
    /**
     * Optional handlers for elicitation and sampling requests from the server.
     * Interpreted as a partial set of MCP handlers.
     */
    handlers?: Partial<MCPHandlers>;
    /**
     * Stable identity for this server derived from its URL/transport/headers.
     * Present for all server states (connected or failed).
     */
    key: string;
    /**
     * Type of server - determines how resources are resolved.
     * Internal servers are resolved server-side, browser-side servers are resolved client-side.
     */
    serverType: ServerType;
}
/**
 * Connected MCP server with an active client.
 */
export interface ConnectedMcpServer extends McpServerConfig {
    client: MCPClient;
}
/**
 * Failed MCP server with a connection error.
 */
export interface FailedMcpServer extends McpServerConfig {
    client?: never;
    connectionError: Error;
}
/**
 * An active or failed MCP server, with access to the MCP client.
 */
export type McpServer = ConnectedMcpServer | FailedMcpServer;
/**
 * Provider-level MCP handlers that receive the McpServerInfo as context in addition to the request.
 * These handlers are applied to all MCP servers unless overridden by per-server handlers.
 *
 * Handlers receive three parameters:
 * 1. request - The MCP request
 * 2. extra - RequestHandlerExtra containing AbortSignal and other metadata
 * 3. serverInfo - Configuration of the MCP server that triggered this request
 */
export interface ProviderMCPHandlers {
    elicitation?: (request: Parameters<MCPElicitationHandler>[0], extra: Parameters<MCPElicitationHandler>[1], serverInfo: McpServerConfig) => ReturnType<MCPElicitationHandler>;
    sampling?: (request: Parameters<MCPSamplingHandler>[0], extra: Parameters<MCPSamplingHandler>[1], serverInfo: McpServerConfig) => ReturnType<MCPSamplingHandler>;
}
/**
 * This provider is used to register tools from MCP servers.
 * It automatically includes an internal Tambo MCP server when an MCP access token is available.
 *
 * **BREAKING CHANGE**: This provider no longer accepts `mcpServers` as a prop.
 * Instead, pass `mcpServers` to `TamboProvider` or `TamboRegistryProvider`.
 * This provider must be wrapped inside `TamboProvider` to access the MCP server registry.
 * @param props - The provider props
 * @param props.handlers - Optional handlers applied to all MCP servers unless overridden per-server
 * @param props.contextKey - Optional context key for fetching threadless MCP tokens when not in a thread
 * @param props.children - The children to wrap
 * @returns The TamboMcpProvider component
 */
export declare const TamboMcpProvider: FC<{
    handlers?: ProviderMCPHandlers;
    contextKey?: string;
    children: React.ReactNode;
}>;
/**
 * Hook to access the actual MCP servers, as they are connected (or fail to
 * connect).
 *
 * You can call methods on the MCP client that is included in the MCP server
 * object.
 *
 * If the server fails to connect, the `client` property will be `undefined` and
 * the `connectionError` property will be set.
 *
 * For example, to forcibly disconnect and reconnect all MCP servers:
 *
 * ```tsx
 * const mcpServers = useTamboMcpServers();
 * mcpServers.forEach((mcpServer) => {
 *   mcpServer.client?.reconnect();
 * });
 * ```
 *
 * Note that the MCP servers are not guaranteed to be in the same order as the
 * input array, because they are added as they are connected.
 * @returns The MCP servers
 */
export declare const useTamboMcpServers: () => McpServer[];
/**
 * Hook to access MCP elicitation state from TamboMcpProvider.
 * This provides access to the current elicitation request and methods to respond to it.
 *
 * The elicitation state is automatically managed by TamboMcpProvider when MCP servers
 * request user input through the elicitation protocol.
 * @returns The elicitation state with current request and response handler
 * @example
 * ```tsx
 * function ElicitationUI() {
 *   const { elicitation, resolveElicitation } = useTamboMcpElicitation();
 *
 *   if (!elicitation) return null;
 *
 *   return (
 *     <div>
 *       <p>{elicitation.message}</p>
 *       <button onClick={() => resolveElicitation?.({ action: "accept", content: {} })}>
 *         Accept
 *       </button>
 *     </div>
 *   );
 * }
 * ```
 */
export declare const useTamboMcpElicitation: () => ElicitationContextState;
/**
 * @deprecated Use `useTamboMcpElicitation` instead.
 * This hook will be removed in a future version.
 */
export declare const useTamboElicitationContext: () => ElicitationContextState;
export {};
//# sourceMappingURL=tambo-mcp-provider.d.ts.map