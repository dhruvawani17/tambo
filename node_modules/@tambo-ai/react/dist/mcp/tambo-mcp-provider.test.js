"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = require("@testing-library/react");
const react_2 = __importStar(require("react"));
const tambo_client_provider_1 = require("../providers/tambo-client-provider");
const tambo_mcp_token_provider_1 = require("../providers/tambo-mcp-token-provider");
const tambo_registry_provider_1 = require("../providers/tambo-registry-provider");
const mcp_client_1 = require("./mcp-client");
const tambo_mcp_provider_1 = require("./tambo-mcp-provider");
// Import the private function for testing by re-exporting it for tests only
// We'll need to export it temporarily or test it through public API
// Helper to create mock RequestHandlerExtra for testing
function createMockExtra() {
    return {
        signal: new AbortController().signal,
        requestId: "test-request-id",
        sendNotification: (async () => { }),
        sendRequest: (async () => ({ _meta: {} })),
    };
}
// Mock the MCP client to avoid ES module issues
jest.mock("./mcp-client", () => ({
    MCPClient: jest.fn(),
    MCPTransport: {
        SSE: "sse",
        HTTP: "http",
    },
}));
// Mock the registry provider to avoid dependency issues
jest.mock("../providers/tambo-registry-provider", () => {
    const actual = jest.requireActual("../providers/tambo-registry-provider");
    return {
        ...actual,
        useTamboRegistry: jest.fn(),
    };
});
// Mock the client provider to avoid dependency issues
jest.mock("../providers/tambo-client-provider", () => {
    return {
        useTamboClient: jest.fn(),
        TamboClientContext: react_2.default.createContext(undefined),
    };
});
// Helper to wrap tests with all required providers (used across multiple describe blocks)
const TestWrapper = ({ mcpServers, handlers, children }) => {
    const client = (0, tambo_client_provider_1.useTamboClient)();
    return (react_2.default.createElement(tambo_client_provider_1.TamboClientContext.Provider, { value: {
            client,
            queryClient: {},
            isUpdatingToken: false,
        } },
        react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, { mcpServers: mcpServers },
            react_2.default.createElement(tambo_mcp_token_provider_1.TamboMcpTokenProvider, null,
                react_2.default.createElement(tambo_mcp_provider_1.TamboMcpProvider, { handlers: handlers }, children)))));
};
describe("extractErrorMessage", () => {
    describe("Array content handling", () => {
        it("should extract text from array content with multiple text items", () => {
            const content = [
                { type: "text", text: "Error:" },
                { type: "text", text: "Tool execution failed" },
                { type: "image", url: "http://example.com/error.png" }, // Should be filtered out
            ];
            const result = (0, tambo_mcp_provider_1.extractErrorMessage)(content);
            expect(result).toBe("Error: Tool execution failed");
        });
        it("should extract text from array content with single text item", () => {
            const content = [{ type: "text", text: "Simple error message" }];
            const result = (0, tambo_mcp_provider_1.extractErrorMessage)(content);
            expect(result).toBe("Simple error message");
        });
        it("should return fallback message for array content with no text items", () => {
            const content = [
                { type: "image", url: "http://example.com/error.png" },
                { type: "resource", uri: "file://error.log" },
            ];
            const result = (0, tambo_mcp_provider_1.extractErrorMessage)(content);
            expect(result).toBe("Error occurred but no details provided");
        });
        it("should return fallback message for empty array content", () => {
            const content = [];
            const result = (0, tambo_mcp_provider_1.extractErrorMessage)(content);
            expect(result).toBe("Error occurred but no details provided");
        });
        it("should handle array content with mixed types correctly", () => {
            const content = [
                { type: "resource", uri: "file://log.txt" },
                { type: "text", text: "First error" },
                { type: "image", url: "http://example.com/img.png" },
                { type: "text", text: "Second error" },
                { type: "unknown", data: "something" },
            ];
            const result = (0, tambo_mcp_provider_1.extractErrorMessage)(content);
            expect(result).toBe("First error Second error");
        });
        it("should handle array content with malformed items", () => {
            const content = [
                null,
                { type: "text", text: "Valid error" },
                { type: "text" }, // Missing text property
                { type: "text", text: null }, // Invalid text type
                { type: "text", text: "Another valid error" },
            ];
            const result = (0, tambo_mcp_provider_1.extractErrorMessage)(content);
            expect(result).toBe("Valid error Another valid error");
        });
    });
    describe("Non-array content handling", () => {
        it("should return string content as-is", () => {
            const content = "Direct error message";
            const result = (0, tambo_mcp_provider_1.extractErrorMessage)(content);
            expect(result).toBe("Direct error message");
        });
        it("should handle null content", () => {
            const content = null;
            const result = (0, tambo_mcp_provider_1.extractErrorMessage)(content);
            expect(result).toBe("Unknown error occurred");
        });
        it("should handle undefined content", () => {
            const content = undefined;
            const result = (0, tambo_mcp_provider_1.extractErrorMessage)(content);
            expect(result).toBe("Unknown error occurred");
        });
        it("should handle number content", () => {
            const content = 42;
            const result = (0, tambo_mcp_provider_1.extractErrorMessage)(content);
            expect(result).toBe("42");
        });
        it("should handle boolean content", () => {
            const content = false;
            const result = (0, tambo_mcp_provider_1.extractErrorMessage)(content);
            expect(result).toBe("false");
        });
        it("should handle object content", () => {
            const content = { error: "Something went wrong" };
            const result = (0, tambo_mcp_provider_1.extractErrorMessage)(content);
            expect(result).toBe('{"error":"Something went wrong"}');
        });
        it("should handle complex object content", () => {
            const content = {
                error: "Something went wrong",
                code: 500,
                details: { message: "Internal server error" },
            };
            const result = (0, tambo_mcp_provider_1.extractErrorMessage)(content);
            expect(result).toBe('{"error":"Something went wrong","code":500,"details":{"message":"Internal server error"}}');
        });
        it("should handle empty object content", () => {
            const content = {};
            const result = (0, tambo_mcp_provider_1.extractErrorMessage)(content);
            expect(result).toBe("{}");
        });
    });
});
describe("TamboMcpProvider server list changes", () => {
    beforeEach(() => {
        // Mock registry so tool registration is a no-op
        tambo_registry_provider_1.useTamboRegistry.mockReturnValue({
            registerTool: jest.fn(),
        });
        // Mock client with baseURL
        tambo_client_provider_1.useTamboClient.mockReturnValue({
            baseURL: "https://api.tambo.co",
        });
        // Ensure MCPClient.create exists and returns a fake client with listTools and close
        mcp_client_1.MCPClient.create = jest.fn().mockResolvedValue({
            listTools: jest.fn().mockResolvedValue([]),
            close: jest.fn(),
        });
    });
    const Capture = ({ onUpdate, }) => {
        const servers = (0, tambo_mcp_provider_1.useTamboMcpServers)();
        (0, react_2.useEffect)(() => {
            onUpdate(servers);
        }, [servers, onUpdate]);
        return react_2.default.createElement("div", { "data-testid": "urls" }, servers.map((s) => s.url).join(","));
    };
    it("adds a new server when the list grows", async () => {
        let latest = [];
        const { rerender, getByTestId } = (0, react_1.render)(react_2.default.createElement(tambo_client_provider_1.TamboClientContext.Provider, { value: {
                client: (0, tambo_client_provider_1.useTamboClient)(),
                queryClient: {},
                isUpdatingToken: false,
            } },
            react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, { mcpServers: ["https://a.example"] },
                react_2.default.createElement(tambo_mcp_token_provider_1.TamboMcpTokenProvider, null,
                    react_2.default.createElement(tambo_mcp_provider_1.TamboMcpProvider, null,
                        react_2.default.createElement(Capture, { onUpdate: (s) => (latest = s) }))))));
        // Wait for initial connection
        await (0, react_1.waitFor)(() => {
            expect(latest.length).toBe(1);
        });
        // Add new server
        rerender(react_2.default.createElement(tambo_client_provider_1.TamboClientContext.Provider, { value: {
                client: (0, tambo_client_provider_1.useTamboClient)(),
                queryClient: {},
                isUpdatingToken: false,
            } },
            react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, { mcpServers: ["https://a.example", "https://b.example"] },
                react_2.default.createElement(tambo_mcp_token_provider_1.TamboMcpTokenProvider, null,
                    react_2.default.createElement(tambo_mcp_provider_1.TamboMcpProvider, null,
                        react_2.default.createElement(Capture, { onUpdate: (s) => (latest = s) }))))));
        await (0, react_1.waitFor)(() => {
            expect(latest.length).toBe(2);
            const urls = getByTestId("urls").textContent || "";
            expect(urls).toContain("https://a.example");
            expect(urls).toContain("https://b.example");
        });
    });
    it("removes a server when the list shrinks", async () => {
        let latest = [];
        const { rerender, getByTestId } = (0, react_1.render)(react_2.default.createElement(tambo_client_provider_1.TamboClientContext.Provider, { value: {
                client: (0, tambo_client_provider_1.useTamboClient)(),
                queryClient: {},
                isUpdatingToken: false,
            } },
            react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, { mcpServers: ["https://a.example", "https://b.example"] },
                react_2.default.createElement(tambo_mcp_token_provider_1.TamboMcpTokenProvider, null,
                    react_2.default.createElement(tambo_mcp_provider_1.TamboMcpProvider, null,
                        react_2.default.createElement(Capture, { onUpdate: (s) => (latest = s) }))))));
        await (0, react_1.waitFor)(() => {
            expect(latest.length).toBe(2);
        });
        // Remove one server
        rerender(react_2.default.createElement(tambo_client_provider_1.TamboClientContext.Provider, { value: {
                client: (0, tambo_client_provider_1.useTamboClient)(),
                queryClient: {},
                isUpdatingToken: false,
            } },
            react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, { mcpServers: ["https://a.example"] },
                react_2.default.createElement(tambo_mcp_token_provider_1.TamboMcpTokenProvider, null,
                    react_2.default.createElement(tambo_mcp_provider_1.TamboMcpProvider, null,
                        react_2.default.createElement(Capture, { onUpdate: (s) => (latest = s) }))))));
        await (0, react_1.waitFor)(() => {
            expect(latest.length).toBe(1);
            const urls = getByTestId("urls").textContent || "";
            expect(urls).toContain("https://a.example");
            expect(urls).not.toContain("https://b.example");
        });
    });
    it("does not duplicate when a new copy of the same list is passed", async () => {
        let latest = [];
        const initial = [
            { url: "https://a.example", transport: mcp_client_1.MCPTransport.SSE },
            { url: "https://b.example", transport: mcp_client_1.MCPTransport.SSE },
        ];
        const { rerender } = (0, react_1.render)(react_2.default.createElement(TestWrapper, { mcpServers: initial },
            react_2.default.createElement(Capture, { onUpdate: (s) => (latest = s) })));
        await (0, react_1.waitFor)(() => {
            expect(latest.length).toBe(2);
        });
        // Pass a new array instance with the same logical servers
        const same = [
            { url: "https://a.example", transport: mcp_client_1.MCPTransport.SSE },
            { url: "https://b.example", transport: mcp_client_1.MCPTransport.SSE },
        ];
        rerender(react_2.default.createElement(TestWrapper, { mcpServers: same },
            react_2.default.createElement(Capture, { onUpdate: (s) => (latest = s) })));
        await (0, react_1.waitFor)(() => {
            expect(latest.length).toBe(2);
            const urls = latest.map((s) => s.url).sort();
            expect(urls).toEqual(["https://a.example", "https://b.example"].sort());
        });
    });
    it("forwards maxCalls from MCP listTools to registry.registerTool", async () => {
        const registerToolMock = jest.fn();
        // Mock registry to capture registerTool calls
        tambo_registry_provider_1.useTamboRegistry.mockReturnValue({
            registerTool: registerToolMock,
        });
        // Mock client
        tambo_client_provider_1.useTamboClient.mockReturnValue({
            baseURL: "https://api.tambo.co",
        });
        // Prepare MCP client to return a tool with maxCalls in its metadata
        mcp_client_1.MCPClient.create = jest.fn().mockResolvedValue({
            listTools: jest.fn().mockResolvedValue([
                {
                    name: "mcp-tool",
                    description: "Tool from MCP",
                    inputSchema: {},
                    outputSchema: {},
                    // MCP may include maxCalls in the tool metadata
                    maxCalls: 7,
                },
            ]),
            close: jest.fn(),
        });
        // Render provider to trigger MCP sync
        (0, react_1.render)(react_2.default.createElement(TestWrapper, { mcpServers: ["https://mcp.example"] },
            react_2.default.createElement("div", null)));
        // Wait for registerTool to be called
        await (0, react_1.waitFor)(() => {
            expect(registerToolMock).toHaveBeenCalled();
        });
        // Inspect the first registered tool
        const registered = registerToolMock.mock.calls[0][0];
        expect(registered).toBeDefined();
        expect(registered.name).toBe("mcp-tool");
        expect(registered.maxCalls).toBe(7);
    });
    it("reuses client when same server is passed with new array instance", async () => {
        const createSpy = jest.fn().mockResolvedValue({
            listTools: jest.fn().mockResolvedValue([]),
            close: jest.fn(),
        });
        mcp_client_1.MCPClient.create = createSpy;
        let latest = [];
        const initial = [{ url: "https://a.example", transport: mcp_client_1.MCPTransport.SSE }];
        const { rerender } = (0, react_1.render)(react_2.default.createElement(TestWrapper, { mcpServers: initial },
            react_2.default.createElement(Capture, { onUpdate: (s) => (latest = s) })));
        await (0, react_1.waitFor)(() => {
            expect(latest.length).toBe(1);
        });
        // Verify client was created once
        expect(createSpy).toHaveBeenCalledTimes(1);
        const firstClient = latest[0].client;
        // Pass a new array with same server
        const same = [{ url: "https://a.example", transport: mcp_client_1.MCPTransport.SSE }];
        rerender(react_2.default.createElement(TestWrapper, { mcpServers: same },
            react_2.default.createElement(Capture, { onUpdate: (s) => (latest = s) })));
        await (0, react_1.waitFor)(() => {
            expect(latest.length).toBe(1);
        });
        // Client should NOT have been created again
        expect(createSpy).toHaveBeenCalledTimes(1);
        // Should be the exact same client instance
        expect(latest[0].client).toBe(firstClient);
    });
    it("calls close() on removed server clients", async () => {
        const closeSpy = jest.fn();
        const createSpy = jest.fn().mockResolvedValue({
            listTools: jest.fn().mockResolvedValue([]),
            close: closeSpy,
        });
        mcp_client_1.MCPClient.create = createSpy;
        let latest = [];
        const { rerender } = (0, react_1.render)(react_2.default.createElement(tambo_client_provider_1.TamboClientContext.Provider, { value: {
                client: (0, tambo_client_provider_1.useTamboClient)(),
                queryClient: {},
                isUpdatingToken: false,
            } },
            react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, { mcpServers: ["https://a.example", "https://b.example"] },
                react_2.default.createElement(tambo_mcp_token_provider_1.TamboMcpTokenProvider, null,
                    react_2.default.createElement(tambo_mcp_provider_1.TamboMcpProvider, null,
                        react_2.default.createElement(Capture, { onUpdate: (s) => (latest = s) }))))));
        await (0, react_1.waitFor)(() => {
            expect(latest.length).toBe(2);
        });
        expect(closeSpy).not.toHaveBeenCalled();
        // Remove one server
        rerender(react_2.default.createElement(tambo_client_provider_1.TamboClientContext.Provider, { value: {
                client: (0, tambo_client_provider_1.useTamboClient)(),
                queryClient: {},
                isUpdatingToken: false,
            } },
            react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, { mcpServers: ["https://a.example"] },
                react_2.default.createElement(tambo_mcp_token_provider_1.TamboMcpTokenProvider, null,
                    react_2.default.createElement(tambo_mcp_provider_1.TamboMcpProvider, null,
                        react_2.default.createElement(Capture, { onUpdate: (s) => (latest = s) }))))));
        await (0, react_1.waitFor)(() => {
            expect(latest.length).toBe(1);
        });
        // close() should have been called once for the removed server
        expect(closeSpy).toHaveBeenCalledTimes(1);
    });
    it("calls close() on all clients when provider unmounts", async () => {
        const closeSpy = jest.fn();
        const createSpy = jest.fn().mockResolvedValue({
            listTools: jest.fn().mockResolvedValue([]),
            close: closeSpy,
        });
        mcp_client_1.MCPClient.create = createSpy;
        let latest = [];
        const { unmount } = (0, react_1.render)(react_2.default.createElement(tambo_client_provider_1.TamboClientContext.Provider, { value: {
                client: (0, tambo_client_provider_1.useTamboClient)(),
                queryClient: {},
                isUpdatingToken: false,
            } },
            react_2.default.createElement(tambo_registry_provider_1.TamboRegistryProvider, { mcpServers: ["https://a.example", "https://b.example"] },
                react_2.default.createElement(tambo_mcp_token_provider_1.TamboMcpTokenProvider, null,
                    react_2.default.createElement(tambo_mcp_provider_1.TamboMcpProvider, null,
                        react_2.default.createElement(Capture, { onUpdate: (s) => (latest = s) }))))));
        await (0, react_1.waitFor)(() => {
            expect(latest.length).toBe(2);
        });
        expect(closeSpy).not.toHaveBeenCalled();
        // Unmount the provider
        unmount();
        // close() should have been called for both clients
        expect(closeSpy).toHaveBeenCalledTimes(2);
    });
    it("creates new client when customHeaders change", async () => {
        const closeSpy = jest.fn();
        let clientIdCounter = 0;
        const createSpy = jest.fn().mockImplementation(async () => {
            const id = ++clientIdCounter;
            return {
                id, // Add an ID so we can track which client is which
                listTools: jest.fn().mockResolvedValue([]),
                close: closeSpy,
            };
        });
        mcp_client_1.MCPClient.create = createSpy;
        let latest = [];
        const { rerender } = (0, react_1.render)(react_2.default.createElement(TestWrapper, { mcpServers: [
                {
                    url: "https://a.example",
                    transport: mcp_client_1.MCPTransport.SSE,
                    customHeaders: { Authorization: "Bearer token1" },
                },
            ] },
            react_2.default.createElement(Capture, { onUpdate: (s) => (latest = s) })));
        await (0, react_1.waitFor)(() => {
            expect(latest.length).toBe(1);
            expect(createSpy).toHaveBeenCalledTimes(1);
        });
        const firstClientId = latest[0].client?.id;
        expect(firstClientId).toBe(1);
        // Change the customHeaders
        rerender(react_2.default.createElement(TestWrapper, { mcpServers: [
                {
                    url: "https://a.example",
                    transport: mcp_client_1.MCPTransport.SSE,
                    customHeaders: { Authorization: "Bearer token2" },
                },
            ] },
            react_2.default.createElement(Capture, { onUpdate: (s) => (latest = s) })));
        // Wait for old client to be closed and new client to be created
        await (0, react_1.waitFor)(() => {
            expect(closeSpy).toHaveBeenCalledTimes(1);
            expect(createSpy).toHaveBeenCalledTimes(2);
            expect(latest.length).toBe(1);
            const newClientId = latest[0].client?.id;
            expect(newClientId).toBe(2); // Should be the new client
        }, { timeout: 3000 });
    });
    // Note: Token changes for the internal Tambo server are covered by the
    // "creates new client when customHeaders change" test above, since token
    // changes result in different Authorization headers, which trigger client recreation.
});
describe("TamboMcpProvider handler support", () => {
    let mockClient;
    let createSpy;
    beforeEach(() => {
        // Mock registry so tool registration is a no-op
        tambo_registry_provider_1.useTamboRegistry.mockReturnValue({
            registerTool: jest.fn(),
        });
        // Mock client with baseURL
        tambo_client_provider_1.useTamboClient.mockReturnValue({
            baseURL: "https://api.tambo.co",
        });
        // Create a mock client with update methods
        mockClient = {
            listTools: jest.fn().mockResolvedValue([]),
            updateElicitationHandler: jest.fn(),
            updateSamplingHandler: jest.fn(),
            close: jest.fn(),
        };
        // Mock MCPClient.create to return our mock client
        createSpy = jest.fn().mockResolvedValue(mockClient);
        mcp_client_1.MCPClient.create = createSpy;
    });
    const Capture = ({ onUpdate, }) => {
        const servers = (0, tambo_mcp_provider_1.useTamboMcpServers)();
        (0, react_2.useEffect)(() => {
            onUpdate(servers);
        }, [servers, onUpdate]);
        return null;
    };
    it("should pass provider-level elicitation handler to MCPClient.create", async () => {
        const mockElicitationHandler = jest.fn().mockResolvedValue({
            content: [{ type: "text", text: "test" }],
        });
        const handlers = {
            elicitation: mockElicitationHandler,
        };
        let latest = [];
        (0, react_1.render)(react_2.default.createElement(TestWrapper, { mcpServers: ["https://test.example"], handlers: handlers },
            react_2.default.createElement(Capture, { onUpdate: (s) => (latest = s) })));
        await (0, react_1.waitFor)(() => {
            expect(latest.length).toBe(1);
        });
        // Verify MCPClient.create was called with an HTTP transport and wrapped handler
        expect(createSpy).toHaveBeenCalledWith("https://test.example", mcp_client_1.MCPTransport.HTTP, undefined, undefined, undefined, expect.objectContaining({
            elicitation: expect.any(Function),
        }));
        // Get the actual handler that was passed
        const passedHandlers = createSpy.mock.calls[0][5];
        expect(passedHandlers.elicitation).toBeDefined();
        // Call the wrapped handler and verify it receives serverInfo
        const mockRequest = {
            method: "sampling/createMessage",
            params: {},
        };
        const mockExtra = createMockExtra();
        await passedHandlers.elicitation(mockRequest, mockExtra);
        expect(mockElicitationHandler).toHaveBeenCalledWith(mockRequest, mockExtra, expect.objectContaining({
            url: "https://test.example",
            serverKey: "test",
        }));
    });
    it("should pass provider-level sampling handler to MCPClient.create", async () => {
        const mockSamplingHandler = jest.fn().mockResolvedValue({
            model: "test-model",
            stopReason: "endTurn",
            role: "assistant",
            content: { type: "text", text: "response" },
        });
        const handlers = {
            sampling: mockSamplingHandler,
        };
        let latest = [];
        (0, react_1.render)(react_2.default.createElement(TestWrapper, { mcpServers: ["https://test.example"], handlers: handlers },
            react_2.default.createElement(Capture, { onUpdate: (s) => (latest = s) })));
        await (0, react_1.waitFor)(() => {
            expect(latest.length).toBe(1);
        });
        // Verify MCPClient.create was called with HTTP transport and sampling handler
        expect(createSpy).toHaveBeenCalledWith("https://test.example", mcp_client_1.MCPTransport.HTTP, undefined, undefined, undefined, expect.objectContaining({
            sampling: expect.any(Function),
        }));
        // Get the actual handler and verify it receives serverInfo
        const passedHandlers = createSpy.mock.calls[0][5];
        const mockRequest = {
            method: "sampling/createMessage",
            params: {
                messages: [],
                modelPreferences: {},
            },
        };
        const mockExtra = createMockExtra();
        await passedHandlers.sampling(mockRequest, mockExtra);
        expect(mockSamplingHandler).toHaveBeenCalledWith(mockRequest, mockExtra, expect.objectContaining({
            url: "https://test.example",
            serverKey: "test",
        }));
    });
    it("should allow per-server handlers to override provider-level handlers", async () => {
        const providerElicitationHandler = jest.fn().mockResolvedValue({
            content: [{ type: "text", text: "provider" }],
        });
        const serverElicitationHandler = jest.fn().mockResolvedValue({
            content: [{ type: "text", text: "server" }],
        });
        const handlers = {
            elicitation: providerElicitationHandler,
        };
        let latest = [];
        (0, react_1.render)(react_2.default.createElement(TestWrapper, { mcpServers: [
                {
                    url: "https://test.example",
                    handlers: {
                        elicitation: serverElicitationHandler,
                    },
                },
            ], handlers: handlers },
            react_2.default.createElement(Capture, { onUpdate: (s) => (latest = s) })));
        await (0, react_1.waitFor)(() => {
            expect(latest.length).toBe(1);
        });
        // Verify the per-server handler was used, not the provider handler
        const passedHandlers = createSpy.mock.calls[0][5];
        expect(passedHandlers.elicitation).toBe(serverElicitationHandler);
    });
    it("should pass different serverInfo to handlers for different servers", async () => {
        const mockElicitationHandler = jest.fn().mockResolvedValue({
            content: [{ type: "text", text: "test" }],
        });
        const handlers = {
            elicitation: mockElicitationHandler,
        };
        let latest = [];
        (0, react_1.render)(react_2.default.createElement(TestWrapper, { mcpServers: [
                { url: "https://server-a.example", name: "Server A" },
                { url: "https://server-b.example", name: "Server B" },
            ], handlers: handlers },
            react_2.default.createElement(Capture, { onUpdate: (s) => (latest = s) })));
        await (0, react_1.waitFor)(() => {
            expect(latest.length).toBe(2);
        });
        // Verify both servers got handlers
        expect(createSpy).toHaveBeenCalledTimes(2);
        // Get handlers for both servers
        const serverAHandlers = createSpy.mock.calls[0][5];
        const serverBHandlers = createSpy.mock.calls[1][5];
        const mockRequest = {
            method: "sampling/createMessage",
            params: {},
        };
        const mockExtra = createMockExtra();
        // Call handler for server A
        await serverAHandlers.elicitation(mockRequest, mockExtra);
        expect(mockElicitationHandler).toHaveBeenCalledWith(mockRequest, mockExtra, expect.objectContaining({
            url: "https://server-a.example",
            name: "Server A",
        }));
        mockElicitationHandler.mockClear();
        // Call handler for server B
        await serverBHandlers.elicitation(mockRequest, mockExtra);
        expect(mockElicitationHandler).toHaveBeenCalledWith(mockRequest, mockExtra, expect.objectContaining({
            url: "https://server-b.example",
            name: "Server B",
        }));
    });
    it("should update handlers when provider handlers change", async () => {
        const initialHandler = jest.fn().mockResolvedValue({
            content: [{ type: "text", text: "initial" }],
        });
        const updatedHandler = jest.fn().mockResolvedValue({
            content: [{ type: "text", text: "updated" }],
        });
        let latest = [];
        const { rerender } = (0, react_1.render)(react_2.default.createElement(TestWrapper, { mcpServers: ["https://test.example"], handlers: { elicitation: initialHandler } },
            react_2.default.createElement(Capture, { onUpdate: (s) => (latest = s) })));
        await (0, react_1.waitFor)(() => {
            expect(latest.length).toBe(1);
        });
        // Update the handlers
        rerender(react_2.default.createElement(TestWrapper, { mcpServers: ["https://test.example"], handlers: { elicitation: updatedHandler } },
            react_2.default.createElement(Capture, { onUpdate: (s) => (latest = s) })));
        await (0, react_1.waitFor)(() => {
            expect(mockClient.updateElicitationHandler).toHaveBeenCalled();
        });
        // Verify the handler was updated
        expect(mockClient.updateElicitationHandler).toHaveBeenCalledWith(expect.any(Function));
    });
});
describe("TamboMcpProvider serverKey derivation and tool prefixing", () => {
    let mockRegisterTool;
    beforeEach(() => {
        mockRegisterTool = jest.fn();
        tambo_registry_provider_1.useTamboRegistry.mockReturnValue({
            registerTool: mockRegisterTool,
        });
        tambo_client_provider_1.useTamboClient.mockReturnValue({
            baseURL: "https://api.tambo.co",
        });
    });
    const Capture = ({ onUpdate, }) => {
        const servers = (0, tambo_mcp_provider_1.useTamboMcpServers)();
        (0, react_2.useEffect)(() => {
            onUpdate(servers);
        }, [servers, onUpdate]);
        return null;
    };
    describe("serverKey derivation", () => {
        it("should derive serverKey from URL when not provided", async () => {
            mcp_client_1.MCPClient.create = jest.fn().mockResolvedValue({
                listTools: jest.fn().mockResolvedValue([]),
                close: jest.fn(),
            });
            let latest = [];
            (0, react_1.render)(react_2.default.createElement(TestWrapper, { mcpServers: ["https://mcp.linear.app/mcp"] },
                react_2.default.createElement(Capture, { onUpdate: (s) => (latest = s) })));
            await (0, react_1.waitFor)(() => {
                expect(latest.length).toBe(1);
                expect(latest[0].serverKey).toBe("linear");
            });
        });
        it("should use provided serverKey when specified", async () => {
            mcp_client_1.MCPClient.create = jest.fn().mockResolvedValue({
                listTools: jest.fn().mockResolvedValue([]),
                close: jest.fn(),
            });
            let latest = [];
            (0, react_1.render)(react_2.default.createElement(TestWrapper, { mcpServers: [
                    {
                        url: "https://mcp.linear.app/mcp",
                        serverKey: "custom-key",
                    },
                ] },
                react_2.default.createElement(Capture, { onUpdate: (s) => (latest = s) })));
            await (0, react_1.waitFor)(() => {
                expect(latest.length).toBe(1);
                expect(latest[0].serverKey).toBe("custom-key");
            });
        });
        it("should derive serverKey correctly for various URL patterns", async () => {
            mcp_client_1.MCPClient.create = jest.fn().mockResolvedValue({
                listTools: jest.fn().mockResolvedValue([]),
                close: jest.fn(),
            });
            const testCases = [
                { url: "https://api.github.com", expected: "github" },
                { url: "https://google.com", expected: "google" },
                { url: "https://google.co.uk", expected: "google" },
                { url: "https://mcp.company.co.uk", expected: "company" },
                { url: "https://www.example.com", expected: "example" },
            ];
            for (const { url, expected } of testCases) {
                let latest = [];
                const { unmount } = (0, react_1.render)(react_2.default.createElement(TestWrapper, { mcpServers: [url] },
                    react_2.default.createElement(Capture, { onUpdate: (s) => (latest = s) })));
                await (0, react_1.waitFor)(() => {
                    expect(latest.length).toBe(1);
                    expect(latest[0].serverKey).toBe(expected);
                });
                unmount();
            }
        });
    });
    describe("tool name prefixing", () => {
        it("should NOT prefix tool names when only one server is present", async () => {
            mcp_client_1.MCPClient.create = jest.fn().mockResolvedValue({
                listTools: jest
                    .fn()
                    .mockResolvedValue([
                    { name: "test-tool", description: "A test tool" },
                ]),
                close: jest.fn(),
            });
            let latest = [];
            (0, react_1.render)(react_2.default.createElement(TestWrapper, { mcpServers: ["https://mcp.linear.app/mcp"] },
                react_2.default.createElement(Capture, { onUpdate: (s) => (latest = s) })));
            await (0, react_1.waitFor)(() => {
                expect(latest.length).toBe(1);
                expect(mockRegisterTool).toHaveBeenCalledWith(expect.objectContaining({
                    name: "test-tool", // NOT prefixed
                }));
            });
        });
        it("should prefix tool names when multiple servers are present", async () => {
            mcp_client_1.MCPClient.create = jest.fn().mockResolvedValue({
                listTools: jest
                    .fn()
                    .mockResolvedValue([
                    { name: "test-tool", description: "A test tool" },
                ]),
                close: jest.fn(),
            });
            let latest = [];
            (0, react_1.render)(react_2.default.createElement(TestWrapper, { mcpServers: ["https://mcp.linear.app/mcp", "https://api.github.com"] },
                react_2.default.createElement(Capture, { onUpdate: (s) => (latest = s) })));
            await (0, react_1.waitFor)(() => {
                expect(latest.length).toBe(2);
                // Check that tools are registered with prefixed names
                const calls = mockRegisterTool.mock.calls;
                const toolNames = calls.map((call) => call[0].name);
                // Debug: log the actual tool names registered
                if (toolNames.length < 2) {
                    throw new Error(`Only ${toolNames.length} tools registered: ${toolNames.join(", ")}`);
                }
                expect(calls.some((call) => call[0].name === "linear__test-tool")).toBe(true);
                expect(calls.some((call) => call[0].name === "github__test-tool")).toBe(true);
            }, { timeout: 5000 });
        });
        it("should use custom serverKey in prefix when provided", async () => {
            mcp_client_1.MCPClient.create = jest.fn().mockResolvedValue({
                listTools: jest
                    .fn()
                    .mockResolvedValue([
                    { name: "test-tool", description: "A test tool" },
                ]),
                close: jest.fn(),
            });
            let latest = [];
            (0, react_1.render)(react_2.default.createElement(TestWrapper, { mcpServers: [
                    {
                        url: "https://mcp.linear.app/mcp",
                        serverKey: "my-server",
                    },
                    "https://api.github.com",
                ] },
                react_2.default.createElement(Capture, { onUpdate: (s) => (latest = s) })));
            await (0, react_1.waitFor)(() => {
                expect(latest.length).toBe(2);
                const calls = mockRegisterTool.mock.calls;
                expect(calls.some((call) => call[0].name === "my-server__test-tool")).toBe(true);
            });
        });
    });
});
//# sourceMappingURL=tambo-mcp-provider.test.js.map