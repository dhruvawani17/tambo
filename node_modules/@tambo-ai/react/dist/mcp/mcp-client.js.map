{"version":3,"file":"mcp-client.js","sourceRoot":"","sources":["../../src/mcp/mcp-client.ts"],"names":[],"mappings":";;;AACA,wEAAmE;AACnE,oEAA6E;AAC7E,0FAAmG;AAEnG,iEAS4C;AAE5C,8DAAwD;AAG/C,6FAHA,8BAAY,OAGA;AAgErB;;;;;;;;;GASG;AACH,MAAa,SAAS;IACpB;;;;OAIG;IACH,MAAM,CAAS;IACP,SAAS,CAAqD;IAC9D,aAAa,CAAe;IAC7B,SAAS,CAAU;IAClB,QAAQ,CAAS;IACjB,OAAO,CAAyB;IAChC,YAAY,CAAuB;IACnC,QAAQ,CAAuB;IAEvC;;;;;OAKG;IACH,YACE,QAAgB,EAChB,aAA2B,EAC3B,OAAgC,EAChC,YAAkC,EAClC,SAAkB,EAClB,WAAiC,EAAE;QAEnC,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,OAAO,GAAG,OAAO,IAAI,EAAE,CAAC;QAC7B,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;QACjC,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;QACnC,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,mBAAmB,CAAC,SAAS,CAAC,CAAC;QACrD,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,gBAAgB,EAAE,CAAC;IACxC,CAAC;IAED;;;;;;;;;;;;OAYG;IACH,MAAM,CAAC,KAAK,CAAC,MAAM,CACjB,QAAgB,EAChB,gBAA8B,8BAAY,CAAC,IAAI,EAC/C,OAA2C,EAC3C,YAA6C,EAC7C,SAA6B,EAC7B,WAAiC,EAAE;QAEnC,MAAM,SAAS,GAAG,IAAI,SAAS,CAC7B,QAAQ,EACR,aAAa,EACb,OAAO,EACP,YAAY,EACZ,SAAS,EACT,QAAQ,CACT,CAAC;QACF,MAAM,SAAS,CAAC,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;QACpD,IAAI,WAAW,IAAI,SAAS,CAAC,SAAS,EAAE,CAAC;YACvC,SAAS,CAAC,SAAS,GAAG,SAAS,CAAC,SAAS,CAAC,SAAS,CAAC;QACtD,CAAC;QACD,OAAO,SAAS,CAAC;IACnB,CAAC;IAEO,mBAAmB,CAAC,SAA6B;QACvD,IAAI,IAAI,CAAC,aAAa,KAAK,8BAAY,CAAC,GAAG,EAAE,CAAC;YAC5C,OAAO,IAAI,2BAAkB,CAAC,IAAI,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;gBACpD,YAAY,EAAE,IAAI,CAAC,YAAY;gBAC/B,WAAW,EAAE,EAAE,OAAO,EAAE,IAAI,CAAC,OAAO,EAAE;aACvC,CAAC,CAAC;QACL,CAAC;aAAM,CAAC;YACN,OAAO,IAAI,iDAA6B,CAAC,IAAI,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;gBAC/D,YAAY,EAAE,IAAI,CAAC,YAAY;gBAC/B,WAAW,EAAE,EAAE,OAAO,EAAE,IAAI,CAAC,OAAO,EAAE;gBACtC,SAAS;aACV,CAAC,CAAC;QACL,CAAC;IACH,CAAC;IAED;;;OAGG;IACK,gBAAgB;QACtB,MAAM,qBAAqB,GAAG,IAAI,CAAC,QAAQ,CAAC,WAAW;YACrD,CAAC,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE;YACrB,CAAC,CAAC,EAAE,CAAC;QACP,MAAM,kBAAkB,GAAG,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,QAAQ,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;QAC1E,MAAM,MAAM,GAAG,IAAI,iBAAM,CACvB;YACE,IAAI,EAAE,kBAAkB;YACxB,OAAO,EAAE,OAAO;SACjB,EACD;YACE,YAAY,EAAE;gBACZ,GAAG,qBAAqB;gBACxB,GAAG,kBAAkB;aACtB;SACF,CACF,CAAC;QAEF,IAAI,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,CAAC;YAC9B,MAAM,CAAC,iBAAiB,CAAC,8BAAmB,EAAE,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;QAC3E,CAAC;QACD,IAAI,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC;YAC3B,MAAM,CAAC,iBAAiB,CACtB,qCAA0B,EAC1B,IAAI,CAAC,QAAQ,CAAC,QAAQ,CACvB,CAAC;QACJ,CAAC;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,SAAS;QACb,MAAM,QAAQ,GAAkB,EAAE,CAAC;QACnC,IAAI,OAAO,GAAG,IAAI,CAAC;QACnB,IAAI,MAAM,GAAuB,SAAS,CAAC;QAE3C,OAAO,OAAO,EAAE,CAAC;YACf,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,EAAE,MAAM,EAAE,EAAE,EAAE,CAAC,CAAC;YAC7D,QAAQ,CAAC,IAAI,CACX,GAAG,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,EAAe,EAAE;gBAC1C,mCAAmC;gBACnC,MAAM,eAAe,GAAW,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC;gBACtD,IAAI,eAAe,KAAK,QAAQ,EAAE,CAAC;oBACjC,MAAM,IAAI,KAAK,CACb,yBAAyB,IAAI,CAAC,IAAI,mBAAmB,CACtD,CAAC;gBACJ,CAAC;gBAED,OAAO;oBACL,IAAI,EAAE,IAAI,CAAC,IAAI;oBACf,WAAW,EAAE,IAAI,CAAC,WAAW;oBAC7B,WAAW,EAAE,IAAI,CAAC,WAA0B;iBAC7C,CAAC;YACJ,CAAC,CAAC,CACH,CAAC;YAEF,IAAI,QAAQ,CAAC,UAAU,EAAE,CAAC;gBACxB,MAAM,GAAG,QAAQ,CAAC,UAAU,CAAC;YAC/B,CAAC;iBAAM,CAAC;gBACN,OAAO,GAAG,KAAK,CAAC;YAClB,CAAC;QACH,CAAC;QAED,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED,qBAAqB;QACnB,OAAO,IAAI,CAAC,MAAM,CAAC,qBAAqB,EAAE,CAAC;IAC7C,CAAC;IAED,gBAAgB;QACd,OAAO,IAAI,CAAC,MAAM,CAAC,gBAAgB,EAAE,CAAC;IACxC,CAAC;IAED,eAAe;QACb,OAAO,IAAI,CAAC,MAAM,CAAC,eAAe,EAAE,CAAC;IACvC,CAAC;IAED;;;;;;OAMG;IACH,KAAK,CAAC,QAAQ,CACZ,IAAY,EACZ,IAA6B,EAC7B,KAA+B;QAE/B,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC;YACxC,IAAI;YACJ,SAAS,EAAE,IAAI;YACf,KAAK;SACN,CAAC,CAAC;QACH,OAAO,MAAM,CAAC;IAChB,CAAC;IAED,wBAAwB,CAAC,OAA0C;QACjE,iCAAiC;QACjC,IAAI,OAAO,KAAK,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,CAAC;YAC1C,OAAO;QACT,CAAC;QAED,4FAA4F;QAC5F,4DAA4D;QAC5D,IAAI,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,CAAC;YAC1C,MAAM,IAAI,KAAK,CAAC,2CAA2C,CAAC,CAAC;QAC/D,CAAC;QACD,IAAI,CAAC,QAAQ,GAAG;YACd,GAAG,IAAI,CAAC,QAAQ;YAChB,WAAW,EAAE,OAAO;SACrB,CAAC;QACF,IAAI,CAAC,OAAO,EAAE,CAAC;YACb,MAAM,MAAM,GAAG,8BAAmB,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC;YACtD,IAAI,CAAC,MAAM,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC;YACzC,OAAO;QACT,CAAC;QACD,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,8BAAmB,EAAE,OAAO,CAAC,CAAC;IAC9D,CAAC;IAED,qBAAqB,CAAC,OAAuC;QAC3D,iCAAiC;QACjC,IAAI,OAAO,KAAK,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC;YACvC,OAAO;QACT,CAAC;QAED,yFAAyF;QACzF,4DAA4D;QAC5D,IAAI,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC;YACvC,MAAM,IAAI,KAAK,CAAC,wCAAwC,CAAC,CAAC;QAC5D,CAAC;QACD,IAAI,CAAC,QAAQ,GAAG;YACd,GAAG,IAAI,CAAC,QAAQ;YAChB,QAAQ,EAAE,OAAO;SAClB,CAAC;QACF,IAAI,CAAC,OAAO,EAAE,CAAC;YACb,MAAM,MAAM,GAAG,qCAA0B,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC;YAC7D,IAAI,CAAC,MAAM,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC;YACzC,OAAO;QACT,CAAC;QACD,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,qCAA0B,EAAE,OAAO,CAAC,CAAC;IACrE,CAAC;IAED,KAAK,CAAC,KAAK;QACT,yEAAyE;QACzE,yEAAyE;QACzE,UAAU;QACV,MAAM,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC;QAC7B,MAAM,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;IAC5B,CAAC;CACF;AAzPD,8BAyPC","sourcesContent":["import { type OAuthClientProvider } from \"@modelcontextprotocol/sdk/client/auth.js\";\nimport { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport { SSEClientTransport } from \"@modelcontextprotocol/sdk/client/sse.js\";\nimport { StreamableHTTPClientTransport } from \"@modelcontextprotocol/sdk/client/streamableHttp.js\";\nimport type { RequestHandlerExtra } from \"@modelcontextprotocol/sdk/shared/protocol.js\";\nimport {\n  ClientNotification,\n  ClientRequest,\n  CreateMessageRequest,\n  CreateMessageRequestSchema,\n  CreateMessageResult,\n  ElicitRequest,\n  ElicitRequestSchema,\n  ElicitResult,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport { JSONSchema7 } from \"json-schema\";\nimport { MCPTransport } from \"../model/mcp-server-info\";\n\n// Re-export for backwards compatibility\nexport { MCPTransport };\n\n/**\n * Handler for MCP elicitation requests.\n * Receives the elicit request and a RequestHandlerExtra containing an AbortSignal that fires when the request is cancelled.\n * @param request - The elicitation request from the server\n * @param extra - Additional context including AbortSignal for cancellation\n * @returns Promise resolving to the elicitation result\n * @example\n * ```typescript\n * const handler: MCPElicitationHandler = async (request, extra) => {\n *   // Listen for cancellation\n *   extra.signal.addEventListener('abort', () => {\n *     console.log('Request cancelled');\n *   });\n *\n *   // Return user's response\n *   return {\n *     action: 'accept',\n *     content: { name: 'John' }\n *   };\n * };\n * ```\n */\nexport type MCPElicitationHandler = (\n  e: ElicitRequest,\n  extra: RequestHandlerExtra<ClientRequest, ClientNotification>,\n) => Promise<ElicitResult>;\n\n/**\n * Handler for MCP sampling requests (create_message).\n * Receives the sampling request and a RequestHandlerExtra containing an AbortSignal that fires when the request is cancelled.\n * @param request - The sampling/create_message request from the server\n * @param extra - Additional context including AbortSignal for cancellation\n * @returns Promise resolving to the sampling result\n */\nexport type MCPSamplingHandler = (\n  e: CreateMessageRequest,\n  extra: RequestHandlerExtra<ClientRequest, ClientNotification>,\n) => Promise<CreateMessageResult>;\n\n/**\n * Handlers for MCP requests - these are only used if the server supports the corresponding capabilities\n * @param elicitation - Handler for elicitation requests (receives request and RequestHandlerExtra with AbortSignal)\n * @param sampling - Handler for sampling requests (receives request and RequestHandlerExtra with AbortSignal)\n * @example\n * ```typescript\n * const mcp = await MCPClient.create(\n *     'https://api.example.com/mcp',\n *     MCPTransport.HTTP,\n *     {},\n *     undefined,\n *     undefined,\n *     {\n *       elicitation: (e, extra) => Promise.resolve({...}),\n *     },\n * );\n * ```\n */\nexport interface MCPHandlers {\n  elicitation: MCPElicitationHandler;\n  sampling: MCPSamplingHandler;\n}\n\n/**\n * A client for interacting with MCP (Model Context Protocol) servers.\n * Provides a simple interface for listing and calling tools exposed by the server.\n * @example\n * ```typescript\n * const mcp = await MCPClient.create('https://api.example.com/mcp');\n * const tools = await mcp.listTools();\n * const result = await mcp.callTool('toolName', { arg1: 'value1' });\n * ```\n */\nexport class MCPClient {\n  /**\n   * The underlying MCP client\n   *\n   * Be careful not to mutate the client directly, use the methods provided instead.\n   */\n  client: Client;\n  private transport: SSEClientTransport | StreamableHTTPClientTransport;\n  private transportType: MCPTransport;\n  public sessionId?: string;\n  private endpoint: string;\n  private headers: Record<string, string>;\n  private authProvider?: OAuthClientProvider;\n  private handlers: Partial<MCPHandlers>;\n\n  /**\n   * Private constructor to enforce using the static create method.\n   * @param endpoint - The URL of the MCP server to connect to\n   * @param transportType - The transport to use for the MCP client\n   * @param headers - Optional custom headers to include in requests\n   */\n  private constructor(\n    endpoint: string,\n    transportType: MCPTransport,\n    headers?: Record<string, string>,\n    authProvider?: OAuthClientProvider,\n    sessionId?: string,\n    handlers: Partial<MCPHandlers> = {},\n  ) {\n    this.endpoint = endpoint;\n    this.headers = headers ?? {};\n    this.authProvider = authProvider;\n    this.transportType = transportType;\n    this.handlers = handlers;\n    this.transport = this.initializeTransport(sessionId);\n    this.client = this.initializeClient();\n  }\n\n  /**\n   * Creates and initializes a new MCPClient instance. This is the recommended\n   * way to create an MCPClient as it handles both instantiation and connection\n   * setup.\n   * @param endpoint - The URL of the MCP server to connect to\n   * @param transportType - The transport type to use for the MCP client. Defaults to HTTP.\n   * @param headers - Optional custom headers to include in requests\n   * @param authProvider - Optional auth provider to use for authentication\n   * @param sessionId - Optional session id to use for the MCP client - if not\n   *   provided, a new session will be created\n   * @returns A connected MCPClient instance ready for use\n   * @throws {Error} Will throw an error if connection fails\n   */\n  static async create(\n    endpoint: string,\n    transportType: MCPTransport = MCPTransport.HTTP,\n    headers: Record<string, string> | undefined,\n    authProvider: OAuthClientProvider | undefined,\n    sessionId: string | undefined,\n    handlers: Partial<MCPHandlers> = {},\n  ): Promise<MCPClient> {\n    const mcpClient = new MCPClient(\n      endpoint,\n      transportType,\n      headers,\n      authProvider,\n      sessionId,\n      handlers,\n    );\n    await mcpClient.client.connect(mcpClient.transport);\n    if (\"sessionId\" in mcpClient.transport) {\n      mcpClient.sessionId = mcpClient.transport.sessionId;\n    }\n    return mcpClient;\n  }\n\n  private initializeTransport(sessionId: string | undefined) {\n    if (this.transportType === MCPTransport.SSE) {\n      return new SSEClientTransport(new URL(this.endpoint), {\n        authProvider: this.authProvider,\n        requestInit: { headers: this.headers },\n      });\n    } else {\n      return new StreamableHTTPClientTransport(new URL(this.endpoint), {\n        authProvider: this.authProvider,\n        requestInit: { headers: this.headers },\n        sessionId,\n      });\n    }\n  }\n\n  /**\n   * Initializes the MCP client with the appropriate capabilities and handlers\n   * @returns The initialized MCP client\n   */\n  private initializeClient() {\n    const elicitationCapability = this.handlers.elicitation\n      ? { elicitation: {} }\n      : {};\n    const samplingCapability = this.handlers.sampling ? { sampling: {} } : {};\n    const client = new Client(\n      {\n        name: \"tambo-mcp-client\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          ...elicitationCapability,\n          ...samplingCapability,\n        },\n      },\n    );\n\n    if (this.handlers.elicitation) {\n      client.setRequestHandler(ElicitRequestSchema, this.handlers.elicitation);\n    }\n    if (this.handlers.sampling) {\n      client.setRequestHandler(\n        CreateMessageRequestSchema,\n        this.handlers.sampling,\n      );\n    }\n    return client;\n  }\n\n  /**\n   * Retrieves a complete list of all available tools from the MCP server.\n   * Handles pagination automatically by following cursors until all tools are fetched.\n   * @returns A complete list of all available tools and their descriptions\n   * @throws {Error} Will throw an error if any server request fails during pagination\n   */\n  async listTools(): Promise<MCPToolSpec[]> {\n    const allTools: MCPToolSpec[] = [];\n    let hasMore = true;\n    let cursor: string | undefined = undefined;\n\n    while (hasMore) {\n      const response = await this.client.listTools({ cursor }, {});\n      allTools.push(\n        ...response.tools.map((tool): MCPToolSpec => {\n          // make sure the right type is used\n          const inputSchemaType: string = tool.inputSchema.type;\n          if (inputSchemaType !== \"object\") {\n            throw new Error(\n              `Input schema for tool ${tool.name} is not an object`,\n            );\n          }\n\n          return {\n            name: tool.name,\n            description: tool.description,\n            inputSchema: tool.inputSchema as JSONSchema7,\n          };\n        }),\n      );\n\n      if (response.nextCursor) {\n        cursor = response.nextCursor;\n      } else {\n        hasMore = false;\n      }\n    }\n\n    return allTools;\n  }\n\n  getServerCapabilities() {\n    return this.client.getServerCapabilities();\n  }\n\n  getServerVersion() {\n    return this.client.getServerVersion();\n  }\n\n  getInstructions() {\n    return this.client.getInstructions();\n  }\n\n  /**\n   * Calls a specific tool on the MCP server with the provided arguments.\n   * @param name - The name of the tool to call\n   * @param args - Arguments to pass to the tool, must match the tool's expected schema\n   * @returns The result from the tool execution\n   * @throws {Error} Will throw an error if the tool call fails or if arguments are invalid\n   */\n  async callTool(\n    name: string,\n    args: Record<string, unknown>,\n    _meta?: Record<string, unknown>,\n  ): Promise<MCPToolCallResult> {\n    const result = await this.client.callTool({\n      name,\n      arguments: args,\n      _meta,\n    });\n    return result;\n  }\n\n  updateElicitationHandler(handler: MCPElicitationHandler | undefined) {\n    // Skip if handler hasn't changed\n    if (handler === this.handlers.elicitation) {\n      return;\n    }\n\n    // Because we advertise the elicitation capability on initial connection, we can only update\n    // an existing handler, not add it if we haven't set it yet.\n    if (handler && !this.handlers.elicitation) {\n      throw new Error(\"Elicitation handler must be set on create\");\n    }\n    this.handlers = {\n      ...this.handlers,\n      elicitation: handler,\n    };\n    if (!handler) {\n      const method = ElicitRequestSchema.shape.method.value;\n      this.client.removeRequestHandler(method);\n      return;\n    }\n    this.client.setRequestHandler(ElicitRequestSchema, handler);\n  }\n\n  updateSamplingHandler(handler: MCPSamplingHandler | undefined) {\n    // Skip if handler hasn't changed\n    if (handler === this.handlers.sampling) {\n      return;\n    }\n\n    // Because we advertise the sampling capability on initial connection, we can only update\n    // an existing handler, not add it if we haven't set it yet.\n    if (handler && !this.handlers.sampling) {\n      throw new Error(\"Sampling handler must be set on create\");\n    }\n    this.handlers = {\n      ...this.handlers,\n      sampling: handler,\n    };\n    if (!handler) {\n      const method = CreateMessageRequestSchema.shape.method.value;\n      this.client.removeRequestHandler(method);\n      return;\n    }\n    this.client.setRequestHandler(CreateMessageRequestSchema, handler);\n  }\n\n  async close() {\n    // Not really sure which one of these to close first, but we'll close the\n    // transport first so that no requests can come in and hit closing/closed\n    // clients\n    await this.transport.close();\n    await this.client.close();\n  }\n}\n\n/**\n * The result of a tool call.\n * This is the same as the result of a tool call in the OpenAI SDK, but is reified here\n */\nexport type MCPToolCallResult = Awaited<\n  ReturnType<typeof Client.prototype.callTool>\n>;\n\n// Example usage:\n/*\nconst mcp = await MCPClient.create('https://api.example.com/mcp', MCPTransport.HTTP);\nconst tools = await mcp.listTools();\nconst result = await mcp.callTool('toolName', { arg1: 'value1' });\n*/\n\nexport interface MCPToolSpec {\n  name: string;\n  description?: string;\n  inputSchema?: JSONSchema7;\n  maxCalls?: number;\n}\n"]}