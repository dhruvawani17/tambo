"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MCPClient = exports.MCPTransport = void 0;
const index_js_1 = require("@modelcontextprotocol/sdk/client/index.js");
const sse_js_1 = require("@modelcontextprotocol/sdk/client/sse.js");
const streamableHttp_js_1 = require("@modelcontextprotocol/sdk/client/streamableHttp.js");
const types_js_1 = require("@modelcontextprotocol/sdk/types.js");
const mcp_server_info_1 = require("../model/mcp-server-info");
Object.defineProperty(exports, "MCPTransport", { enumerable: true, get: function () { return mcp_server_info_1.MCPTransport; } });
/**
 * A client for interacting with MCP (Model Context Protocol) servers.
 * Provides a simple interface for listing and calling tools exposed by the server.
 * @example
 * ```typescript
 * const mcp = await MCPClient.create('https://api.example.com/mcp');
 * const tools = await mcp.listTools();
 * const result = await mcp.callTool('toolName', { arg1: 'value1' });
 * ```
 */
class MCPClient {
    /**
     * The underlying MCP client
     *
     * Be careful not to mutate the client directly, use the methods provided instead.
     */
    client;
    transport;
    transportType;
    sessionId;
    endpoint;
    headers;
    authProvider;
    handlers;
    /**
     * Private constructor to enforce using the static create method.
     * @param endpoint - The URL of the MCP server to connect to
     * @param transportType - The transport to use for the MCP client
     * @param headers - Optional custom headers to include in requests
     */
    constructor(endpoint, transportType, headers, authProvider, sessionId, handlers = {}) {
        this.endpoint = endpoint;
        this.headers = headers ?? {};
        this.authProvider = authProvider;
        this.transportType = transportType;
        this.handlers = handlers;
        this.transport = this.initializeTransport(sessionId);
        this.client = this.initializeClient();
    }
    /**
     * Creates and initializes a new MCPClient instance. This is the recommended
     * way to create an MCPClient as it handles both instantiation and connection
     * setup.
     * @param endpoint - The URL of the MCP server to connect to
     * @param transportType - The transport type to use for the MCP client. Defaults to HTTP.
     * @param headers - Optional custom headers to include in requests
     * @param authProvider - Optional auth provider to use for authentication
     * @param sessionId - Optional session id to use for the MCP client - if not
     *   provided, a new session will be created
     * @returns A connected MCPClient instance ready for use
     * @throws {Error} Will throw an error if connection fails
     */
    static async create(endpoint, transportType = mcp_server_info_1.MCPTransport.HTTP, headers, authProvider, sessionId, handlers = {}) {
        const mcpClient = new MCPClient(endpoint, transportType, headers, authProvider, sessionId, handlers);
        await mcpClient.client.connect(mcpClient.transport);
        if ("sessionId" in mcpClient.transport) {
            mcpClient.sessionId = mcpClient.transport.sessionId;
        }
        return mcpClient;
    }
    initializeTransport(sessionId) {
        if (this.transportType === mcp_server_info_1.MCPTransport.SSE) {
            return new sse_js_1.SSEClientTransport(new URL(this.endpoint), {
                authProvider: this.authProvider,
                requestInit: { headers: this.headers },
            });
        }
        else {
            return new streamableHttp_js_1.StreamableHTTPClientTransport(new URL(this.endpoint), {
                authProvider: this.authProvider,
                requestInit: { headers: this.headers },
                sessionId,
            });
        }
    }
    /**
     * Initializes the MCP client with the appropriate capabilities and handlers
     * @returns The initialized MCP client
     */
    initializeClient() {
        const elicitationCapability = this.handlers.elicitation
            ? { elicitation: {} }
            : {};
        const samplingCapability = this.handlers.sampling ? { sampling: {} } : {};
        const client = new index_js_1.Client({
            name: "tambo-mcp-client",
            version: "1.0.0",
        }, {
            capabilities: {
                ...elicitationCapability,
                ...samplingCapability,
            },
        });
        if (this.handlers.elicitation) {
            client.setRequestHandler(types_js_1.ElicitRequestSchema, this.handlers.elicitation);
        }
        if (this.handlers.sampling) {
            client.setRequestHandler(types_js_1.CreateMessageRequestSchema, this.handlers.sampling);
        }
        return client;
    }
    /**
     * Retrieves a complete list of all available tools from the MCP server.
     * Handles pagination automatically by following cursors until all tools are fetched.
     * @returns A complete list of all available tools and their descriptions
     * @throws {Error} Will throw an error if any server request fails during pagination
     */
    async listTools() {
        const allTools = [];
        let hasMore = true;
        let cursor = undefined;
        while (hasMore) {
            const response = await this.client.listTools({ cursor }, {});
            allTools.push(...response.tools.map((tool) => {
                // make sure the right type is used
                const inputSchemaType = tool.inputSchema.type;
                if (inputSchemaType !== "object") {
                    throw new Error(`Input schema for tool ${tool.name} is not an object`);
                }
                return {
                    name: tool.name,
                    description: tool.description,
                    inputSchema: tool.inputSchema,
                };
            }));
            if (response.nextCursor) {
                cursor = response.nextCursor;
            }
            else {
                hasMore = false;
            }
        }
        return allTools;
    }
    getServerCapabilities() {
        return this.client.getServerCapabilities();
    }
    getServerVersion() {
        return this.client.getServerVersion();
    }
    getInstructions() {
        return this.client.getInstructions();
    }
    /**
     * Calls a specific tool on the MCP server with the provided arguments.
     * @param name - The name of the tool to call
     * @param args - Arguments to pass to the tool, must match the tool's expected schema
     * @returns The result from the tool execution
     * @throws {Error} Will throw an error if the tool call fails or if arguments are invalid
     */
    async callTool(name, args, _meta) {
        const result = await this.client.callTool({
            name,
            arguments: args,
            _meta,
        });
        return result;
    }
    updateElicitationHandler(handler) {
        // Skip if handler hasn't changed
        if (handler === this.handlers.elicitation) {
            return;
        }
        // Because we advertise the elicitation capability on initial connection, we can only update
        // an existing handler, not add it if we haven't set it yet.
        if (handler && !this.handlers.elicitation) {
            throw new Error("Elicitation handler must be set on create");
        }
        this.handlers = {
            ...this.handlers,
            elicitation: handler,
        };
        if (!handler) {
            const method = types_js_1.ElicitRequestSchema.shape.method.value;
            this.client.removeRequestHandler(method);
            return;
        }
        this.client.setRequestHandler(types_js_1.ElicitRequestSchema, handler);
    }
    updateSamplingHandler(handler) {
        // Skip if handler hasn't changed
        if (handler === this.handlers.sampling) {
            return;
        }
        // Because we advertise the sampling capability on initial connection, we can only update
        // an existing handler, not add it if we haven't set it yet.
        if (handler && !this.handlers.sampling) {
            throw new Error("Sampling handler must be set on create");
        }
        this.handlers = {
            ...this.handlers,
            sampling: handler,
        };
        if (!handler) {
            const method = types_js_1.CreateMessageRequestSchema.shape.method.value;
            this.client.removeRequestHandler(method);
            return;
        }
        this.client.setRequestHandler(types_js_1.CreateMessageRequestSchema, handler);
    }
    async close() {
        // Not really sure which one of these to close first, but we'll close the
        // transport first so that no requests can come in and hit closing/closed
        // clients
        await this.transport.close();
        await this.client.close();
    }
}
exports.MCPClient = MCPClient;
//# sourceMappingURL=mcp-client.js.map