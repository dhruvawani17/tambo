"use strict";
"use client";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useTamboSuggestions = useTamboSuggestions;
const react_1 = require("react");
const generate_component_response_1 = require("../model/generate-component-response");
const validate_input_1 = require("../model/validate-input");
const tambo_client_provider_1 = require("../providers/tambo-client-provider");
const tambo_provider_1 = require("../providers/tambo-provider");
const tambo_registry_provider_1 = require("../providers/tambo-registry-provider");
const tambo_thread_input_provider_1 = require("../providers/tambo-thread-input-provider");
const tambo_thread_provider_1 = require("../providers/tambo-thread-provider");
const query_utils_1 = require("../util/query-utils");
const registry_1 = require("../util/registry");
const react_query_hooks_1 = require("./react-query-hooks");
/**
 * Hook for managing Tambo AI suggestions in a thread
 * @param options - Configuration options for suggestion generation
 * @returns Object containing suggestions state and control functions
 */
function useTamboSuggestions(options = {}) {
    const { maxSuggestions = 3 } = options;
    const { thread, generationStage } = (0, tambo_thread_provider_1.useTamboThread)();
    const { sendThreadMessage } = (0, tambo_provider_1.useTambo)();
    const tamboClient = (0, tambo_client_provider_1.useTamboClient)();
    const { componentList, toolRegistry, componentToolAssociations } = (0, tambo_registry_provider_1.useTamboRegistry)();
    const [selectedSuggestionId, setSelectedSuggestionId] = (0, react_1.useState)(null);
    const { setValue: setInputValue } = (0, tambo_thread_input_provider_1.useTamboThreadInput)();
    const latestMessage = thread.messages[thread.messages.length - 1];
    const isLatestFromTambo = latestMessage?.role === "assistant";
    const latestMessageId = latestMessage?.id;
    // Reset selected suggestion when the message changes
    (0, react_1.useEffect)(() => {
        setSelectedSuggestionId(null);
    }, [latestMessageId]);
    const shouldGenerateSuggestions = latestMessageId && isLatestFromTambo && (0, generate_component_response_1.isIdleStage)(generationStage);
    // Use React Query to fetch suggestions when a new hydra message is received
    const suggestionsResult = (0, react_query_hooks_1.useTamboQuery)({
        // Make sure the query key changes when the message changes, so that we are
        // always generating suggestions when there is a new message
        queryKey: [
            "suggestions",
            shouldGenerateSuggestions ? latestMessageId : null,
        ],
        queryFn: async () => {
            if (!shouldGenerateSuggestions) {
                return [];
            }
            // Get registered components from the registry
            const components = (0, registry_1.getAvailableComponents)(componentList, toolRegistry, componentToolAssociations);
            return await tamboClient.beta.threads.suggestions.generate(latestMessageId, {
                id: thread.id,
                maxSuggestions,
                availableComponents: components,
            });
        },
        // Only run the query if we have a valid message from hydra
        enabled: Boolean(latestMessageId && isLatestFromTambo),
        // Don't refetch on window focus or reconnect
        refetchOnWindowFocus: false,
        refetchOnReconnect: false,
        // Don't retry on failure
        retry: false,
    });
    // Accept suggestion mutation
    const acceptMutationState = (0, react_query_hooks_1.useTamboMutation)({
        mutationFn: async ({ suggestion, shouldSubmit = false }) => {
            const validation = (0, validate_input_1.validateInput)(suggestion.detailedSuggestion);
            if (!validation.isValid) {
                if (validation.error) {
                    throw validation.error;
                }
                throw new Error(tambo_thread_input_provider_1.INPUT_ERROR_MESSAGES.VALIDATION);
            }
            if (shouldSubmit) {
                await sendThreadMessage(validation.sanitizedInput, {
                    threadId: thread.id,
                });
            }
            else {
                setInputValue(validation.sanitizedInput);
            }
            setSelectedSuggestionId(suggestion.id);
        },
    });
    // Generate suggestions mutation
    const generateMutationState = (0, react_query_hooks_1.useTamboMutation)({
        mutationFn: async (abortController) => {
            if (!shouldGenerateSuggestions) {
                return undefined;
            }
            // Get registered components from the registry
            const components = (0, registry_1.getAvailableComponents)(componentList, toolRegistry, componentToolAssociations);
            return await tamboClient.beta.threads.suggestions.generate(latestMessageId, {
                id: thread.id,
                maxSuggestions,
                availableComponents: components,
            }, { signal: abortController.signal });
        },
        // Don't retry on failure
        retry: false,
    });
    // Use the query data if available, otherwise use the mutation data
    // Only return suggestions if the latest message is from hydra
    const suggestions = isLatestFromTambo
        ? (suggestionsResult.data ?? generateMutationState.data ?? [])
        : [];
    return {
        suggestions,
        accept: acceptMutationState.mutateAsync,
        selectedSuggestionId,
        acceptResult: acceptMutationState,
        generateResult: generateMutationState,
        suggestionsResult,
        ...(0, query_utils_1.combineMutationResults)(acceptMutationState, generateMutationState),
    };
}
//# sourceMappingURL=use-suggestions.js.map