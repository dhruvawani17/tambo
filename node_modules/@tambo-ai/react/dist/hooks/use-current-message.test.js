"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = require("@testing-library/react");
const react_2 = __importDefault(require("react"));
const use_current_message_1 = require("./use-current-message");
describe("TamboMessageProvider", () => {
    const createMockMessage = (overrides = {}) => ({
        id: "test-message-id",
        threadId: "test-thread-id",
        componentState: {},
        content: [{ type: "text", text: "Test message" }],
        createdAt: new Date().toISOString(),
        role: "assistant",
        ...overrides,
    });
    it("should provide message context to children", () => {
        const message = createMockMessage();
        const TestComponent = () => {
            const currentMessage = (0, use_current_message_1.useTamboCurrentMessage)();
            return react_2.default.createElement("div", null, currentMessage.id);
        };
        (0, react_1.render)(react_2.default.createElement(use_current_message_1.TamboMessageProvider, { message: message },
            react_2.default.createElement(TestComponent, null)));
        expect(react_1.screen.getByText("test-message-id")).toBeInTheDocument();
    });
    it("should merge interactable metadata into message", () => {
        const message = createMockMessage();
        const interactableMetadata = {
            id: "interactable-123",
            componentName: "TestComponent",
            description: "Test description",
        };
        const TestComponent = () => {
            const currentMessage = (0, use_current_message_1.useTamboCurrentMessage)();
            return (react_2.default.createElement("div", null,
                react_2.default.createElement("span", { "data-testid": "message-id" }, currentMessage.id),
                react_2.default.createElement("span", { "data-testid": "interactable-id" }, currentMessage.interactableMetadata?.id)));
        };
        (0, react_1.render)(react_2.default.createElement(use_current_message_1.TamboMessageProvider, { message: message, interactableMetadata: interactableMetadata },
            react_2.default.createElement(TestComponent, null)));
        expect(react_1.screen.getByTestId("message-id")).toHaveTextContent("test-message-id");
        expect(react_1.screen.getByTestId("interactable-id")).toHaveTextContent("interactable-123");
    });
    it("should work without interactable metadata", () => {
        const message = createMockMessage();
        const TestComponent = () => {
            const currentMessage = (0, use_current_message_1.useTamboCurrentMessage)();
            return (react_2.default.createElement("div", null,
                react_2.default.createElement("span", { "data-testid": "has-metadata" }, currentMessage.interactableMetadata ? "yes" : "no")));
        };
        (0, react_1.render)(react_2.default.createElement(use_current_message_1.TamboMessageProvider, { message: message },
            react_2.default.createElement(TestComponent, null)));
        expect(react_1.screen.getByTestId("has-metadata")).toHaveTextContent("no");
    });
    it("should use message.id as key for re-renders", () => {
        const message1 = createMockMessage({ id: "message-1" });
        const message2 = createMockMessage({ id: "message-2" });
        let renderCount = 0;
        const TestComponent = () => {
            renderCount++;
            const currentMessage = (0, use_current_message_1.useTamboCurrentMessage)();
            return react_2.default.createElement("div", null, currentMessage.id);
        };
        const { rerender } = (0, react_1.render)(react_2.default.createElement(use_current_message_1.TamboMessageProvider, { message: message1 },
            react_2.default.createElement(TestComponent, null)));
        expect(renderCount).toBe(1);
        expect(react_1.screen.getByText("message-1")).toBeInTheDocument();
        // Change to new message - should force re-render due to key change
        rerender(react_2.default.createElement(use_current_message_1.TamboMessageProvider, { message: message2 },
            react_2.default.createElement(TestComponent, null)));
        expect(renderCount).toBe(2);
        expect(react_1.screen.getByText("message-2")).toBeInTheDocument();
    });
});
describe("useTamboCurrentMessage", () => {
    const createMockMessage = (overrides = {}) => ({
        id: "test-message-id",
        threadId: "test-thread-id",
        componentState: {},
        content: [{ type: "text", text: "Test message" }],
        createdAt: new Date().toISOString(),
        role: "assistant",
        ...overrides,
    });
    it("should throw error when used outside TamboMessageProvider", () => {
        // Suppress console.error for this test
        const consoleSpy = jest.spyOn(console, "error").mockImplementation();
        expect(() => {
            (0, react_1.renderHook)(() => (0, use_current_message_1.useTamboCurrentMessage)());
        }).toThrow("useTamboCurrentMessage must be used within a TamboMessageProvider");
        consoleSpy.mockRestore();
    });
    it("should return the current message", () => {
        const message = createMockMessage();
        const wrapper = ({ children }) => (react_2.default.createElement(use_current_message_1.TamboMessageProvider, { message: message }, children));
        const { result } = (0, react_1.renderHook)(() => (0, use_current_message_1.useTamboCurrentMessage)(), { wrapper });
        expect(result.current).toEqual(expect.objectContaining({
            id: "test-message-id",
            threadId: "test-thread-id",
        }));
    });
    it("should return message with interactable metadata when provided", () => {
        const message = createMockMessage();
        const interactableMetadata = {
            id: "interactable-123",
            componentName: "TestComponent",
            description: "Test description",
        };
        const wrapper = ({ children }) => (react_2.default.createElement(use_current_message_1.TamboMessageProvider, { message: message, interactableMetadata: interactableMetadata }, children));
        const { result } = (0, react_1.renderHook)(() => (0, use_current_message_1.useTamboCurrentMessage)(), { wrapper });
        expect(result.current.interactableMetadata).toEqual(interactableMetadata);
    });
});
describe("useTamboCurrentComponent", () => {
    const createMockMessage = (overrides = {}) => ({
        id: "test-message-id",
        threadId: "test-thread-id",
        componentState: {},
        content: [{ type: "text", text: "Test message" }],
        createdAt: new Date().toISOString(),
        role: "assistant",
        ...overrides,
    });
    it("should return null when used outside TamboMessageProvider", () => {
        const { result } = (0, react_1.renderHook)(() => (0, use_current_message_1.useTamboCurrentComponent)());
        expect(result.current).toBeNull();
    });
    it("should return component info from message.component", () => {
        const message = createMockMessage({
            component: {
                componentName: "WeatherCard",
                componentState: {},
                message: "",
                props: {
                    city: "San Francisco",
                    temperature: 72,
                },
            },
        });
        const wrapper = ({ children }) => (react_2.default.createElement(use_current_message_1.TamboMessageProvider, { message: message }, children));
        const { result } = (0, react_1.renderHook)(() => (0, use_current_message_1.useTamboCurrentComponent)(), {
            wrapper,
        });
        expect(result.current).toEqual({
            componentName: "WeatherCard",
            props: {
                city: "San Francisco",
                temperature: 72,
            },
            interactableId: undefined,
            description: undefined,
            threadId: "test-thread-id",
        });
    });
    it("should return interactable metadata when provided", () => {
        const message = createMockMessage({
            component: {
                componentName: "WeatherCard",
                componentState: {},
                message: "",
                props: {
                    city: "San Francisco",
                    temperature: 72,
                },
            },
        });
        const interactableMetadata = {
            id: "interactable-456",
            componentName: "WeatherCard",
            description: "Shows current weather",
        };
        const wrapper = ({ children }) => (react_2.default.createElement(use_current_message_1.TamboMessageProvider, { message: message, interactableMetadata: interactableMetadata }, children));
        const { result } = (0, react_1.renderHook)(() => (0, use_current_message_1.useTamboCurrentComponent)(), {
            wrapper,
        });
        expect(result.current).toEqual({
            componentName: "WeatherCard",
            props: {
                city: "San Francisco",
                temperature: 72,
            },
            interactableId: "interactable-456",
            description: "Shows current weather",
            threadId: "test-thread-id",
        });
    });
    it("should prioritize interactableMetadata.componentName over message.component.componentName", () => {
        const message = createMockMessage({
            component: {
                componentName: "OldComponentName",
                componentState: {},
                message: "",
                props: {},
            },
        });
        const interactableMetadata = {
            id: "interactable-789",
            componentName: "NewComponentName",
            description: "New description",
        };
        const wrapper = ({ children }) => (react_2.default.createElement(use_current_message_1.TamboMessageProvider, { message: message, interactableMetadata: interactableMetadata }, children));
        const { result } = (0, react_1.renderHook)(() => (0, use_current_message_1.useTamboCurrentComponent)(), {
            wrapper,
        });
        expect(result.current?.componentName).toBe("NewComponentName");
    });
    it("should handle message with only interactable metadata (no component)", () => {
        const message = createMockMessage(); // No component field
        const interactableMetadata = {
            id: "interactable-only",
            componentName: "InteractableComponent",
            description: "Interactable only",
        };
        const wrapper = ({ children }) => (react_2.default.createElement(use_current_message_1.TamboMessageProvider, { message: message, interactableMetadata: interactableMetadata }, children));
        const { result } = (0, react_1.renderHook)(() => (0, use_current_message_1.useTamboCurrentComponent)(), {
            wrapper,
        });
        expect(result.current).toEqual({
            componentName: "InteractableComponent",
            props: undefined,
            interactableId: "interactable-only",
            description: "Interactable only",
            threadId: "test-thread-id",
        });
    });
    it("should handle message with component but no interactable metadata", () => {
        const message = createMockMessage({
            component: {
                componentName: "SimpleComponent",
                componentState: {},
                message: "",
                props: {
                    title: "Hello",
                },
            },
        });
        const wrapper = ({ children }) => (react_2.default.createElement(use_current_message_1.TamboMessageProvider, { message: message }, children));
        const { result } = (0, react_1.renderHook)(() => (0, use_current_message_1.useTamboCurrentComponent)(), {
            wrapper,
        });
        expect(result.current).toEqual({
            componentName: "SimpleComponent",
            props: {
                title: "Hello",
            },
            interactableId: undefined,
            description: undefined,
            threadId: "test-thread-id",
        });
    });
    it("should return undefined for all fields when message has neither component nor interactable metadata", () => {
        const message = createMockMessage(); // Minimal message with no component or interactable data
        const wrapper = ({ children }) => (react_2.default.createElement(use_current_message_1.TamboMessageProvider, { message: message }, children));
        const { result } = (0, react_1.renderHook)(() => (0, use_current_message_1.useTamboCurrentComponent)(), {
            wrapper,
        });
        expect(result.current).toEqual({
            componentName: undefined,
            props: undefined,
            interactableId: undefined,
            description: undefined,
            threadId: "test-thread-id",
        });
    });
});
//# sourceMappingURL=use-current-message.test.js.map