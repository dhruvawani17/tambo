"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const react_query_1 = require("@tanstack/react-query");
const react_1 = require("@testing-library/react");
const generate_component_response_1 = require("../model/generate-component-response");
const tambo_client_provider_1 = require("../providers/tambo-client-provider");
const tambo_provider_1 = require("../providers/tambo-provider");
const tambo_thread_input_provider_1 = require("../providers/tambo-thread-input-provider");
const tambo_thread_provider_1 = require("../providers/tambo-thread-provider");
const react_query_hooks_1 = require("./react-query-hooks");
const use_suggestions_1 = require("./use-suggestions");
// Mock the required providers
jest.mock("../providers/tambo-client-provider", () => ({
    useTamboClient: jest.fn(),
    useTamboQueryClient: jest.fn(),
}));
jest.mock("../providers/tambo-provider", () => ({ useTambo: jest.fn() }));
jest.mock("../providers/tambo-thread-provider", () => ({
    useTamboThread: jest.fn(),
}));
jest.mock("../providers/tambo-thread-input-provider", () => ({
    useTamboThreadInput: jest.fn(),
}));
// Mock the react-query-hooks
jest.mock("./react-query-hooks", () => ({
    useTamboQuery: jest.fn(),
    useTamboMutation: jest.fn(),
}));
describe("useTamboSuggestions", () => {
    const mockSuggestions = [
        {
            id: "suggestion-1",
            messageId: "test-message-id",
            title: "Test Suggestion 1",
            detailedSuggestion: "Test suggestion 1",
        },
        {
            id: "suggestion-2",
            messageId: "test-message-id",
            title: "Test Suggestion 2",
            detailedSuggestion: "Test suggestion 2",
        },
    ];
    // Helper function to create mock TamboThreadMessage
    const createMockMessage = (overrides = {}) => ({
        id: "test-message-id",
        componentState: {},
        content: [{ type: "text", text: "Test message" }],
        createdAt: new Date().toISOString(),
        role: "assistant",
        threadId: "test-thread-id",
        ...overrides,
    });
    // Helper function to create mock TamboThread
    const createMockThread = (overrides = {}) => ({
        id: "test-thread-id",
        projectId: "test-project-id",
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        messages: [],
        ...overrides,
    });
    // Helper function to create mock CombinedTamboThreadContextProps
    const createMockThreadContext = (overrides = {}) => {
        const mockThread = createMockThread();
        return {
            thread: mockThread,
            currentThreadId: mockThread.id,
            currentThread: mockThread,
            threadMap: { [mockThread.id]: mockThread },
            setThreadMap: jest.fn(),
            switchCurrentThread: jest.fn(),
            startNewThread: jest.fn(),
            updateThreadName: jest.fn(),
            generateThreadName: jest.fn(),
            addThreadMessage: jest.fn(),
            updateThreadMessage: jest.fn(),
            cancel: jest.fn(),
            streaming: false,
            sendThreadMessage: jest.fn(),
            generationStage: generate_component_response_1.GenerationStage.IDLE,
            generationStatusMessage: "",
            isIdle: true,
            ...overrides,
        };
    };
    beforeEach(() => {
        jest.mocked(tambo_client_provider_1.useTamboQueryClient).mockReturnValue(new react_query_1.QueryClient());
        jest.mocked(react_query_hooks_1.useTamboMutation).mockImplementation(({ mutationFn }) => ({
            mutateAsync: mutationFn,
            isLoading: false,
            isError: false,
            error: null,
        }));
        // Setup default mock implementations
        jest.mocked(tambo_client_provider_1.useTamboClient).mockReturnValue({
            beta: { threads: { suggestions: { generate: jest.fn() } } },
        });
        jest.mocked(tambo_provider_1.useTambo).mockReturnValue({
            sendThreadMessage: jest.fn(),
        });
        jest.mocked(tambo_thread_provider_1.useTamboThread).mockReturnValue(createMockThreadContext({
            thread: createMockThread({
                messages: [
                    createMockMessage({
                        role: "assistant",
                    }),
                ],
            }),
        }));
        jest.mocked(tambo_thread_input_provider_1.useTamboThreadInput).mockReturnValue({
            setValue: jest.fn(),
            value: "",
            submit: jest.fn(),
        });
        // Default query mock returns empty array
        jest.mocked(react_query_hooks_1.useTamboQuery).mockReturnValue({
            data: [],
            isLoading: false,
            isError: false,
            error: null,
        });
    });
    it("should initialize with empty suggestions and no selected suggestion", () => {
        const { result } = (0, react_1.renderHook)(() => (0, use_suggestions_1.useTamboSuggestions)());
        expect(result.current.suggestions).toEqual([]);
        expect(result.current.selectedSuggestionId).toBeNull();
    });
    it("should generate suggestions when latest message is from Tambo", async () => {
        const mockGenerate = jest.fn().mockResolvedValue(mockSuggestions);
        jest.mocked(tambo_client_provider_1.useTamboClient).mockReturnValue({
            beta: {
                threads: {
                    suggestions: {
                        generate: mockGenerate,
                        list: jest.fn(),
                    },
                },
            },
        });
        jest.mocked(tambo_thread_provider_1.useTamboThread).mockReturnValue(createMockThreadContext({
            thread: createMockThread({
                messages: [
                    createMockMessage({
                        role: "assistant",
                    }),
                ],
            }),
        }));
        // Mock the query result to return the mock suggestions
        jest.mocked(react_query_hooks_1.useTamboQuery).mockReturnValue({
            data: mockSuggestions,
            isLoading: false,
            isError: false,
            error: null,
        });
        const { result } = (0, react_1.renderHook)(() => (0, use_suggestions_1.useTamboSuggestions)());
        // Wait for the effect to run
        await (0, react_1.act)(async () => {
            await new Promise((resolve) => setTimeout(resolve, 0));
        });
        // Since we're mocking useTamboQuery to return the suggestions directly,
        // the generate function won't be called, so we don't need to check that
        expect(result.current.suggestions).toEqual(mockSuggestions);
    });
    it("should not generate suggestions when latest message is not from Tambo", async () => {
        const mockGenerate = jest.fn();
        jest.mocked(tambo_client_provider_1.useTamboClient).mockReturnValue({
            beta: {
                threads: {
                    suggestions: {
                        generate: mockGenerate,
                        list: jest.fn(),
                    },
                },
            },
        });
        // Mock the thread to have a non-Tambo message
        jest.mocked(tambo_thread_provider_1.useTamboThread).mockReturnValue(createMockThreadContext({
            thread: createMockThread({
                messages: [
                    createMockMessage({
                        role: "user",
                    }),
                ],
            }),
        }));
        const { result } = (0, react_1.renderHook)(() => (0, use_suggestions_1.useTamboSuggestions)());
        // Wait for the effect to run
        await (0, react_1.act)(async () => {
            await new Promise((resolve) => setTimeout(resolve, 0));
        });
        expect(mockGenerate).not.toHaveBeenCalled();
        expect(result.current.suggestions).toEqual([]);
    });
    it("should accept a suggestion and update input value", async () => {
        const mockSetValue = jest.fn();
        jest.mocked(tambo_thread_input_provider_1.useTamboThreadInput).mockReturnValue({
            setValue: mockSetValue,
            value: "",
            submit: jest.fn(),
        });
        const { result } = (0, react_1.renderHook)(() => (0, use_suggestions_1.useTamboSuggestions)());
        await (0, react_1.act)(async () => {
            await result.current.accept({
                suggestion: mockSuggestions[0],
                shouldSubmit: false,
            });
        });
        expect(mockSetValue).toHaveBeenCalledWith("Test suggestion 1");
        expect(result.current.selectedSuggestionId).toBe("suggestion-1");
    });
    it("should accept a suggestion and submit it", async () => {
        const mockSendThreadMessage = jest.fn();
        jest.mocked(tambo_provider_1.useTambo).mockReturnValue({
            sendThreadMessage: mockSendThreadMessage,
        });
        const { result } = (0, react_1.renderHook)(() => (0, use_suggestions_1.useTamboSuggestions)());
        await (0, react_1.act)(async () => {
            await result.current.accept({
                suggestion: mockSuggestions[0],
                shouldSubmit: true,
            });
        });
        expect(mockSendThreadMessage).toHaveBeenCalledWith("Test suggestion 1", {
            threadId: "test-thread-id",
        });
        expect(result.current.selectedSuggestionId).toBe("suggestion-1");
    });
    it("should throw error when accepting invalid suggestion", async () => {
        const invalidSuggestion = {
            id: "invalid-suggestion",
            messageId: "test-message-id",
            title: "Invalid Suggestion",
            detailedSuggestion: "", // Empty suggestion should fail validation
        };
        const { result } = (0, react_1.renderHook)(() => (0, use_suggestions_1.useTamboSuggestions)());
        await (0, react_1.act)(async () => {
            await expect(result.current.accept({
                suggestion: invalidSuggestion,
                shouldSubmit: false,
            })).rejects.toThrow("Message cannot be empty");
        });
        expect(result.current.selectedSuggestionId).toBeNull();
    });
});
//# sourceMappingURL=use-suggestions.test.js.map