"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = require("@testing-library/react");
const react_2 = __importDefault(require("react"));
const react_query_1 = require("@tanstack/react-query");
const react_media_recorder_1 = require("react-media-recorder");
const use_tambo_voice_1 = require("./use-tambo-voice");
const tambo_client_provider_1 = require("../providers/tambo-client-provider");
// Override the global mock from setupTests.ts with a controllable version
jest.mock("react-media-recorder", () => ({
    useReactMediaRecorder: jest.fn(),
}));
// Mock the client provider
jest.mock("../providers/tambo-client-provider", () => ({
    ...jest.requireActual("../providers/tambo-client-provider"),
    useTamboClient: jest.fn(),
}));
const tambo_client_provider_2 = require("../providers/tambo-client-provider");
// Mock fetch globally
const mockFetch = jest.fn();
describe("useTamboVoice", () => {
    let previousFetch;
    let mockStartRecording;
    let mockStopRecording;
    let mockTranscribe;
    let queryClient;
    const createWrapper = () => {
        const mockClient = {
            beta: {
                audio: {
                    transcribe: mockTranscribe,
                },
            },
        };
        const Wrapper = ({ children }) => (react_2.default.createElement(tambo_client_provider_1.TamboClientContext.Provider, { value: {
                client: mockClient,
                queryClient,
                isUpdatingToken: false,
            } },
            react_2.default.createElement(react_query_1.QueryClientProvider, { client: queryClient }, children)));
        Wrapper.displayName = "TestWrapper";
        return Wrapper;
    };
    const setupMediaRecorderMock = (overrides = {}) => {
        const value = {
            status: "idle",
            startRecording: mockStartRecording,
            stopRecording: mockStopRecording,
            mediaBlobUrl: undefined,
            error: "",
            ...overrides,
        };
        jest
            .mocked(react_media_recorder_1.useReactMediaRecorder)
            .mockReturnValue(value);
        return value;
    };
    beforeEach(() => {
        jest.clearAllMocks();
        mockFetch.mockReset();
        previousFetch = global.fetch;
        global.fetch = mockFetch;
        mockStartRecording = jest.fn();
        mockStopRecording = jest.fn();
        mockTranscribe = jest.fn();
        queryClient = new react_query_1.QueryClient({
            defaultOptions: {
                queries: { retry: false },
                mutations: { retry: false },
            },
        });
        // Setup default client mock
        const mockClient = {
            beta: {
                audio: {
                    transcribe: mockTranscribe,
                },
            },
        };
        jest
            .mocked(tambo_client_provider_2.useTamboClient)
            .mockReturnValue(mockClient);
        // Setup default media recorder mock
        setupMediaRecorderMock();
        // Setup default fetch mock
        mockFetch.mockResolvedValue({
            blob: async () => await Promise.resolve(new Blob(["audio data"], { type: "audio/webm" })),
        });
    });
    afterEach(() => {
        global.fetch = previousFetch;
    });
    describe("Initial State", () => {
        it("should initialize with idle state and no transcript", () => {
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_voice_1.useTamboVoice)(), {
                wrapper: createWrapper(),
            });
            expect(result.current.isRecording).toBe(false);
            expect(result.current.isTranscribing).toBe(false);
            expect(result.current.transcript).toBeNull();
            expect(result.current.transcriptionError).toBeNull();
            expect(result.current.mediaAccessError).toBeNull();
        });
    });
    describe("Recording Flow", () => {
        it("should expose isRecording=true during active recording", () => {
            setupMediaRecorderMock({ status: "recording" });
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_voice_1.useTamboVoice)(), {
                wrapper: createWrapper(),
            });
            expect(result.current.isRecording).toBe(true);
        });
        it("should call startRecording on the media recorder", () => {
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_voice_1.useTamboVoice)(), {
                wrapper: createWrapper(),
            });
            (0, react_1.act)(() => {
                result.current.startRecording();
            });
            expect(mockStartRecording).toHaveBeenCalled();
        });
        it("should call stopRecording on the media recorder when recording", () => {
            setupMediaRecorderMock({ status: "recording" });
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_voice_1.useTamboVoice)(), {
                wrapper: createWrapper(),
            });
            (0, react_1.act)(() => {
                result.current.stopRecording();
            });
            expect(mockStopRecording).toHaveBeenCalled();
        });
        it("should reset transcript when starting a new recording", async () => {
            mockTranscribe.mockResolvedValue("first transcript");
            // Start with completed transcription
            setupMediaRecorderMock({
                status: "stopped",
                mediaBlobUrl: "blob:http://localhost/audio1",
            });
            const { result, rerender } = (0, react_1.renderHook)(() => (0, use_tambo_voice_1.useTamboVoice)(), {
                wrapper: createWrapper(),
            });
            // Wait for transcription to complete
            await (0, react_1.waitFor)(() => {
                expect(result.current.transcript).toBe("first transcript");
            });
            // Now simulate starting a new recording
            setupMediaRecorderMock({ status: "idle" });
            rerender();
            (0, react_1.act)(() => {
                result.current.startRecording();
            });
            expect(result.current.transcript).toBeNull();
        });
    });
    describe("Transcription", () => {
        it("should trigger transcription after recording stops with blob URL", async () => {
            mockTranscribe.mockResolvedValue("Hello world");
            setupMediaRecorderMock({
                status: "stopped",
                mediaBlobUrl: "blob:http://localhost/audio",
            });
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_voice_1.useTamboVoice)(), {
                wrapper: createWrapper(),
            });
            await (0, react_1.waitFor)(() => {
                expect(result.current.transcript).toBe("Hello world");
            });
            expect(mockFetch).toHaveBeenCalledWith("blob:http://localhost/audio");
            expect(mockTranscribe).toHaveBeenCalled();
        });
        it("should expose isTranscribing=true during API call", async () => {
            let resolveTranscription;
            mockTranscribe.mockImplementation(async () => await new Promise((resolve) => {
                resolveTranscription = resolve;
            }));
            setupMediaRecorderMock({
                status: "stopped",
                mediaBlobUrl: "blob:http://localhost/audio",
            });
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_voice_1.useTamboVoice)(), {
                wrapper: createWrapper(),
            });
            await (0, react_1.waitFor)(() => {
                expect(result.current.isTranscribing).toBe(true);
            });
            // Complete the transcription
            (0, react_1.act)(() => {
                resolveTranscription("transcribed text");
            });
            await (0, react_1.waitFor)(() => {
                expect(result.current.isTranscribing).toBe(false);
            });
        });
    });
    describe("Error Handling", () => {
        it("should expose mediaAccessError when microphone access fails", () => {
            setupMediaRecorderMock({
                error: "Permission denied",
            });
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_voice_1.useTamboVoice)(), {
                wrapper: createWrapper(),
            });
            expect(result.current.mediaAccessError).toBe("Permission denied");
        });
        it("should expose transcriptionError when API call fails", async () => {
            mockTranscribe.mockRejectedValue(new Error("Transcription service unavailable"));
            setupMediaRecorderMock({
                status: "stopped",
                mediaBlobUrl: "blob:http://localhost/audio",
            });
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_voice_1.useTamboVoice)(), {
                wrapper: createWrapper(),
            });
            await (0, react_1.waitFor)(() => {
                expect(result.current.transcriptionError).toBe("Transcription service unavailable");
            });
            expect(result.current.isTranscribing).toBe(false);
        });
        it("should handle blob fetch failure gracefully", async () => {
            mockFetch.mockRejectedValue(new Error("Network error"));
            setupMediaRecorderMock({
                status: "stopped",
                mediaBlobUrl: "blob:http://localhost/audio",
            });
            const { result } = (0, react_1.renderHook)(() => (0, use_tambo_voice_1.useTamboVoice)(), {
                wrapper: createWrapper(),
            });
            await (0, react_1.waitFor)(() => {
                expect(result.current.transcriptionError).toBe("Network error");
            });
            expect(result.current.isTranscribing).toBe(false);
            expect(result.current.transcript).toBeNull();
        });
    });
});
//# sourceMappingURL=use-tambo-voice.test.js.map