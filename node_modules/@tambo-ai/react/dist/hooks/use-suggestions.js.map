{"version":3,"file":"use-suggestions.js","sourceRoot":"","sources":["../../src/hooks/use-suggestions.ts"],"names":[],"mappings":"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","sourcesContent":["\"use client\";\nimport TamboAI from \"@tambo-ai/typescript-sdk\";\nimport { useEffect, useState } from \"react\";\nimport { isIdleStage } from \"../model/generate-component-response\";\nimport { validateInput } from \"../model/validate-input\";\nimport { useTamboClient } from \"../providers/tambo-client-provider\";\nimport { useTambo } from \"../providers/tambo-provider\";\nimport { useTamboRegistry } from \"../providers/tambo-registry-provider\";\nimport {\n  INPUT_ERROR_MESSAGES,\n  useTamboThreadInput,\n} from \"../providers/tambo-thread-input-provider\";\nimport { useTamboThread } from \"../providers/tambo-thread-provider\";\nimport {\n  CombinedMutationResult,\n  combineMutationResults,\n} from \"../util/query-utils\";\nimport { getAvailableComponents } from \"../util/registry\";\nimport {\n  UseTamboMutationResult,\n  UseTamboQueryResult,\n  useTamboMutation,\n  useTamboQuery,\n} from \"./react-query-hooks\";\n\n/**\n * Configuration options for the useTamboSuggestions hook\n */\nexport interface useTamboSuggestionsOptions {\n  /** Maximum number of suggestions to generate (1-10, default 3) */\n  maxSuggestions?: number;\n}\n\n/**\n * Return value interface for useTamboSuggestions hook\n */\nexport interface useTamboSuggestionsResultInternal {\n  /** List of available suggestions (also available in generateResult.data) */\n  suggestions: TamboAI.Beta.Threads.Suggestion[];\n  /** ID of the currently selected suggestion */\n  selectedSuggestionId: string | null;\n  /**\n   * Accept and apply a suggestion (also available in acceptResult.mutateAsync)\n   * @param suggestion - The suggestion to accept\n   * @param shouldSubmit - Whether to automatically submit after accepting (default: false)\n   */\n  accept: (acceptOptions: {\n    suggestion: TamboAI.Beta.Threads.Suggestion;\n    shouldSubmit?: boolean;\n  }) => Promise<void>;\n\n  /** Result and network state for accepting a suggestion */\n  acceptResult: UseTamboMutationResult<\n    void,\n    Error,\n    { suggestion: TamboAI.Beta.Threads.Suggestion; shouldSubmit?: boolean }\n  >;\n\n  /** Result and network state for generating suggestions */\n  generateResult: UseTamboMutationResult<\n    TamboAI.Beta.Threads.Suggestions.SuggestionGenerateResponse | undefined,\n    Error,\n    AbortController\n  >;\n\n  /** The full suggestions query object from React Query */\n  suggestionsResult: UseTamboQueryResult<\n    TamboAI.Beta.Threads.Suggestions.SuggestionGenerateResponse | undefined\n  >;\n}\n\ntype useTamboSuggestionsResult = CombinedMutationResult<any, Error> &\n  useTamboSuggestionsResultInternal;\n\n/**\n * Hook for managing Tambo AI suggestions in a thread\n * @param options - Configuration options for suggestion generation\n * @returns Object containing suggestions state and control functions\n */\nexport function useTamboSuggestions(\n  options: useTamboSuggestionsOptions = {},\n): useTamboSuggestionsResult {\n  const { maxSuggestions = 3 } = options;\n  const { thread, generationStage } = useTamboThread();\n  const { sendThreadMessage } = useTambo();\n  const tamboClient = useTamboClient();\n  const { componentList, toolRegistry, componentToolAssociations } =\n    useTamboRegistry();\n\n  const [selectedSuggestionId, setSelectedSuggestionId] = useState<\n    string | null\n  >(null);\n  const { setValue: setInputValue } = useTamboThreadInput();\n\n  const latestMessage = thread.messages[thread.messages.length - 1];\n  const isLatestFromTambo = latestMessage?.role === \"assistant\";\n  const latestMessageId = latestMessage?.id;\n\n  // Reset selected suggestion when the message changes\n  useEffect(() => {\n    setSelectedSuggestionId(null);\n  }, [latestMessageId]);\n\n  const shouldGenerateSuggestions =\n    latestMessageId && isLatestFromTambo && isIdleStage(generationStage);\n  // Use React Query to fetch suggestions when a new hydra message is received\n  const suggestionsResult = useTamboQuery({\n    // Make sure the query key changes when the message changes, so that we are\n    // always generating suggestions when there is a new message\n    queryKey: [\n      \"suggestions\",\n      shouldGenerateSuggestions ? latestMessageId : null,\n    ],\n    queryFn: async () => {\n      if (!shouldGenerateSuggestions) {\n        return [];\n      }\n\n      // Get registered components from the registry\n      const components = getAvailableComponents(\n        componentList,\n        toolRegistry,\n        componentToolAssociations,\n      );\n\n      return await tamboClient.beta.threads.suggestions.generate(\n        latestMessageId,\n        {\n          id: thread.id,\n          maxSuggestions,\n          availableComponents: components,\n        },\n      );\n    },\n    // Only run the query if we have a valid message from hydra\n    enabled: Boolean(latestMessageId && isLatestFromTambo),\n    // Don't refetch on window focus or reconnect\n    refetchOnWindowFocus: false,\n    refetchOnReconnect: false,\n    // Don't retry on failure\n    retry: false,\n  });\n\n  // Accept suggestion mutation\n  const acceptMutationState = useTamboMutation<\n    void,\n    Error,\n    { suggestion: TamboAI.Beta.Threads.Suggestion; shouldSubmit?: boolean }\n  >({\n    mutationFn: async ({ suggestion, shouldSubmit = false }) => {\n      const validation = validateInput(suggestion.detailedSuggestion);\n      if (!validation.isValid) {\n        if (validation.error) {\n          throw validation.error;\n        }\n        throw new Error(INPUT_ERROR_MESSAGES.VALIDATION);\n      }\n\n      if (shouldSubmit) {\n        await sendThreadMessage(validation.sanitizedInput, {\n          threadId: thread.id,\n        });\n      } else {\n        setInputValue(validation.sanitizedInput);\n      }\n      setSelectedSuggestionId(suggestion.id);\n    },\n  });\n\n  // Generate suggestions mutation\n  const generateMutationState = useTamboMutation<\n    TamboAI.Beta.Threads.Suggestions.SuggestionGenerateResponse | undefined,\n    Error,\n    AbortController\n  >({\n    mutationFn: async (abortController: AbortController) => {\n      if (!shouldGenerateSuggestions) {\n        return undefined;\n      }\n\n      // Get registered components from the registry\n      const components = getAvailableComponents(\n        componentList,\n        toolRegistry,\n        componentToolAssociations,\n      );\n      return await tamboClient.beta.threads.suggestions.generate(\n        latestMessageId,\n        {\n          id: thread.id,\n          maxSuggestions,\n          availableComponents: components,\n        },\n        { signal: abortController.signal },\n      );\n    },\n    // Don't retry on failure\n    retry: false,\n  });\n\n  // Use the query data if available, otherwise use the mutation data\n  // Only return suggestions if the latest message is from hydra\n  const suggestions = isLatestFromTambo\n    ? (suggestionsResult.data ?? generateMutationState.data ?? [])\n    : [];\n\n  return {\n    suggestions,\n    accept: acceptMutationState.mutateAsync,\n    selectedSuggestionId,\n    acceptResult: acceptMutationState,\n    generateResult: generateMutationState,\n    suggestionsResult,\n    ...combineMutationResults(acceptMutationState, generateMutationState),\n  };\n}\n"]}