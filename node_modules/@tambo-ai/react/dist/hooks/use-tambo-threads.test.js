"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const react_query_1 = require("@tanstack/react-query");
const react_1 = require("@testing-library/react");
const providers_1 = require("../providers");
const tambo_client_provider_1 = require("../providers/tambo-client-provider");
const use_tambo_threads_1 = require("./use-tambo-threads");
jest.mock("../providers/tambo-client-provider", () => ({
    useTamboClient: jest.fn(),
    useTamboQueryClient: jest.fn(),
}));
jest.mock("../providers", () => ({
    useTamboThread: jest.fn(),
}));
describe("useTamboThreadList", () => {
    const mockThreads = [
        { id: "thread-1", title: "Thread 1" },
        { id: "thread-2", title: "Thread 2" },
    ];
    const mockProjects = {
        getCurrent: jest.fn(),
        retrieve: jest.fn(),
        delete: jest.fn(),
    };
    const mockThreadsApi = {
        list: jest.fn(),
        messages: {
            list: jest.fn(),
            create: jest.fn(),
            delete: jest.fn(),
            updateComponentState: jest.fn(),
        },
        suggestions: {
            list: jest.fn(),
            generate: jest.fn(),
        },
        create: jest.fn(),
        retrieve: jest.fn(),
        update: jest.fn(),
        delete: jest.fn(),
        advance: jest.fn(),
        advanceByID: jest.fn(),
    };
    const mockBeta = {
        projects: mockProjects,
        threads: mockThreadsApi,
        registry: {
            retrieve: jest.fn(),
        },
    };
    const mockTamboAI = {
        apiKey: "",
        beta: mockBeta,
    };
    beforeEach(() => {
        jest.mocked(tambo_client_provider_1.useTamboQueryClient).mockReturnValue(new react_query_1.QueryClient());
        jest
            .mocked(providers_1.useTamboThread)
            .mockReturnValue({ contextKey: undefined });
    });
    it("should fetch threads for current project when no projectId is provided", async () => {
        const mockClient = jest.mocked(tambo_client_provider_1.useTamboClient);
        mockClient.mockReturnValue({
            ...mockTamboAI,
            beta: {
                ...mockBeta,
                projects: {
                    ...mockProjects,
                    getCurrent: jest.fn().mockResolvedValue({ id: "current-project" }),
                },
                threads: {
                    ...mockThreadsApi,
                    list: jest.fn().mockResolvedValue(mockThreads),
                },
            },
        });
        const { result } = (0, react_1.renderHook)(() => (0, use_tambo_threads_1.useTamboThreadList)());
        await (0, react_1.waitFor)(() => {
            expect(result.current.data).toEqual(mockThreads);
        });
    });
    it("should fetch threads for specified projectId", async () => {
        const mockList = jest.fn().mockResolvedValue(mockThreads);
        const mockClient = jest.mocked(tambo_client_provider_1.useTamboClient);
        mockClient.mockReturnValue({
            ...mockTamboAI,
            beta: {
                ...mockBeta,
                threads: {
                    ...mockThreadsApi,
                    list: mockList,
                },
            },
        });
        const { result } = (0, react_1.renderHook)(() => (0, use_tambo_threads_1.useTamboThreadList)({ projectId: "custom-project" }));
        await (0, react_1.waitFor)(() => {
            expect(result.current.data).toEqual(mockThreads);
        });
        expect(mockList).toHaveBeenCalledWith("custom-project", {});
    });
    it("should fetch threads with contextKey when provided via TamboThreadProvider", async () => {
        jest
            .mocked(providers_1.useTamboThread)
            .mockReturnValue({ contextKey: "test-context" });
        const mockList = jest.fn().mockResolvedValue(mockThreads);
        const mockClient = jest.mocked(tambo_client_provider_1.useTamboClient);
        mockClient.mockReturnValue({
            ...mockTamboAI,
            beta: {
                ...mockBeta,
                projects: {
                    ...mockProjects,
                    getCurrent: jest.fn().mockResolvedValue({ id: "current-project" }),
                },
                threads: {
                    ...mockThreadsApi,
                    list: mockList,
                },
            },
        });
        const { result } = (0, react_1.renderHook)(() => (0, use_tambo_threads_1.useTamboThreadList)());
        await (0, react_1.waitFor)(() => {
            expect(result.current.data).toEqual(mockThreads);
        });
        expect(mockList).toHaveBeenCalledWith("current-project", {
            contextKey: "test-context",
        });
    });
    it("should handle loading state", async () => {
        let resolvePromise;
        const promise = new Promise((resolve) => {
            resolvePromise = resolve;
        });
        const mockClient = jest.mocked(tambo_client_provider_1.useTamboClient);
        mockClient.mockReturnValue({
            ...mockTamboAI,
            beta: {
                ...mockBeta,
                projects: {
                    ...mockProjects,
                    getCurrent: jest.fn().mockResolvedValue({ id: "current-project" }),
                },
                threads: {
                    ...mockThreadsApi,
                    list: jest.fn().mockReturnValue(promise),
                },
            },
        });
        const { result } = (0, react_1.renderHook)(() => (0, use_tambo_threads_1.useTamboThreadList)({}, { retry: false }));
        expect(result.current).toMatchInlineSnapshot(`
      {
        "data": null,
        "dataUpdatedAt": 0,
        "error": null,
        "errorUpdateCount": 0,
        "errorUpdatedAt": 0,
        "failureCount": 0,
        "failureReason": null,
        "fetchStatus": "fetching",
        "isEnabled": true,
        "isError": false,
        "isFetched": false,
        "isFetchedAfterMount": false,
        "isFetching": true,
        "isInitialLoading": true,
        "isLoading": true,
        "isLoadingError": false,
        "isPaused": false,
        "isPending": true,
        "isPlaceholderData": false,
        "isRefetchError": false,
        "isRefetching": false,
        "isStale": true,
        "isSuccess": false,
        "promise": Promise {},
        "refetch": [Function],
        "status": "pending",
      }
    `);
        resolvePromise(mockThreads);
        await (0, react_1.waitFor)(() => {
            expect(result.current.isLoading).toBe(false);
        });
    });
    it("should handle error state", async () => {
        const mockError = new Error("Failed to fetch threads");
        const mockClient = jest.mocked(tambo_client_provider_1.useTamboClient);
        mockClient.mockReturnValue({
            ...mockTamboAI,
            beta: {
                ...mockBeta,
                projects: {
                    ...mockProjects,
                    getCurrent: jest.fn().mockResolvedValue({ id: "current-project" }),
                },
                threads: {
                    ...mockThreadsApi,
                    list: jest.fn().mockImplementation(async () => {
                        // console.log("Mocking error", mockCount++);
                        throw mockError;
                    }),
                },
            },
        });
        const { result } = (0, react_1.renderHook)(() => (0, use_tambo_threads_1.useTamboThreadList)({}, { retry: false }));
        await (0, react_1.waitFor)(() => {
            const { isLoading, error, isError } = result.current;
            expect(isLoading).toBe(false);
            expect(isError).toBe(true);
            expect(error).toBe(mockError);
        });
    });
});
//# sourceMappingURL=use-tambo-threads.test.js.map