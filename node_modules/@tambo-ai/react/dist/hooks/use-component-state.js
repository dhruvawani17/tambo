"use strict";
"use client";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useTamboComponentState = useTamboComponentState;
const fast_equals_1 = require("fast-equals");
const react_1 = require("react");
const use_debounce_1 = require("use-debounce");
const __1 = require("..");
const tambo_interactable_provider_1 = require("../providers/tambo-interactable-provider");
const use_current_message_1 = require("./use-current-message");
function useTamboComponentState(keyName, initialValue, setFromProp, debounceTime = 500) {
    const message = (0, react_1.useContext)(use_current_message_1.TamboMessageContext);
    const { updateThreadMessage } = (0, __1.useTamboThread)();
    const client = (0, __1.useTamboClient)();
    const componentId = message?.interactableMetadata?.id ?? null;
    const { setInteractableState, getInteractableComponentState } = (0, tambo_interactable_provider_1.useTamboInteractable)();
    const messageState = message?.componentState?.[keyName];
    const interactableState = componentId
        ? getInteractableComponentState(componentId)?.[keyName]
        : undefined;
    const initialState = interactableState ?? messageState ?? initialValue;
    const [localState, setLocalState] = (0, react_1.useState)(initialState);
    const [initializedFromThreadMessage, setInitializedFromThreadMessage] = (0, react_1.useState)(messageState ? true : false);
    // Optimistically update the local thread message's componentState
    const updateLocalThreadMessage = (0, react_1.useCallback)(async (newState, existingMessage) => {
        if (!existingMessage) {
            return;
        }
        const updatedMessage = {
            threadId: existingMessage.threadId,
            componentState: {
                ...existingMessage.componentState,
                [keyName]: newState,
            },
        };
        await updateThreadMessage(existingMessage.id, updatedMessage, false);
    }, [updateThreadMessage, keyName]);
    // Debounced callback to update the remote thread message's componentState
    const updateRemoteThreadMessage = (0, use_debounce_1.useDebouncedCallback)(async (newState, existingMessage) => {
        if (!existingMessage) {
            return;
        }
        await client.beta.threads.messages.updateComponentState(existingMessage.id, {
            id: existingMessage.threadId,
            state: { [keyName]: newState },
        });
    }, debounceTime);
    const setValue = (0, react_1.useCallback)((newState) => {
        setLocalState(newState);
        if (componentId) {
            // For interactable components, update the interactable provider's state
            setInteractableState(componentId, keyName, newState);
        }
        else if (message) {
            // For generated components, update both local and remote thread message state
            void updateLocalThreadMessage(newState, message);
            void updateRemoteThreadMessage(newState, message);
        }
    }, [
        message,
        updateLocalThreadMessage,
        updateRemoteThreadMessage,
        setInteractableState,
        componentId,
        keyName,
    ]);
    const existingInteractableState = componentId
        ? getInteractableComponentState(componentId)?.[keyName]
        : undefined;
    const shouldUpdateInteractableInitial = !!componentId &&
        existingInteractableState === undefined &&
        initialValue !== undefined;
    // Set initial value in interactable state if we're in an interactable context and there's no existing state
    (0, react_1.useEffect)(() => {
        if (!shouldUpdateInteractableInitial) {
            return;
        }
        setInteractableState(componentId, keyName, initialValue);
    }, [
        shouldUpdateInteractableInitial,
        componentId,
        keyName,
        initialValue,
        setInteractableState,
    ]);
    const shouldSyncFromMessage = !!message && messageState !== undefined && messageState !== null;
    // Mirror the thread message's componentState value to the local state and interactable state
    (0, react_1.useEffect)(() => {
        if (!shouldSyncFromMessage) {
            return;
        }
        setInitializedFromThreadMessage(true);
        const stateValue = messageState;
        setLocalState(stateValue);
        if (componentId) {
            setInteractableState(componentId, keyName, stateValue);
        }
    }, [
        shouldSyncFromMessage,
        messageState,
        keyName,
        setInteractableState,
        componentId,
    ]);
    // Sync from interactable provider to local state when state changes externally (e.g., from Tambo tool call)
    (0, react_1.useEffect)(() => {
        if (!componentId)
            return;
        // only update if different
        setLocalState((prev) => (0, fast_equals_1.deepEqual)(prev, interactableState) ? prev : interactableState);
    }, [componentId, interactableState]);
    // For editable fields that are set from a prop to allow streaming updates, don't overwrite a fetched state value set from the thread message with prop value on initial load.
    (0, react_1.useEffect)(() => {
        if (setFromProp !== undefined && !initializedFromThreadMessage) {
            setLocalState(setFromProp);
        }
    }, [setFromProp, initializedFromThreadMessage]);
    // Ensure pending changes are flushed on unmount (only for generated components)
    (0, react_1.useEffect)(() => {
        // Only flush remote updates for generated components, not interactable components
        if (componentId) {
            return;
        }
        return () => {
            async function flushUpdates() {
                try {
                    await updateRemoteThreadMessage.flush();
                }
                catch (error) {
                    console.error("Failed to flush pending thread message updates:", error);
                }
            }
            // Fire-and-forget cleanup (errors handled inside)
            void flushUpdates();
        };
    }, [updateRemoteThreadMessage, componentId]);
    return [localState, setValue];
}
//# sourceMappingURL=use-component-state.js.map