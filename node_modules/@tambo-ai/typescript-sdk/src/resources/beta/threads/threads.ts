// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import { APIResource } from '../../../core/resource';
import * as ThreadsAPI from './threads';
import * as Shared from '../../shared';
import * as MessagesAPI from './messages';
import {
  MessageCreateParams,
  MessageCreateResponse,
  MessageDeleteParams,
  MessageListParams,
  MessageListResponse,
  MessageUpdateComponentStateParams,
  Messages,
} from './messages';
import * as SuggestionsAPI from './suggestions';
import {
  Suggestion,
  SuggestionGenerateParams,
  SuggestionGenerateResponse,
  SuggestionListParams,
  SuggestionListResponse,
  Suggestions,
  SuggestionsGenerate,
} from './suggestions';
import { APIPromise } from '../../../core/api-promise';
import { OffsetAndLimit, type OffsetAndLimitParams, PagePromise } from '../../../core/pagination';
import { buildHeaders } from '../../../internal/headers';
import { RequestOptions } from '../../../internal/request-options';
import { path } from '../../../internal/utils/path';

export class Threads extends APIResource {
  messages: MessagesAPI.Messages = new MessagesAPI.Messages(this._client);
  suggestions: SuggestionsAPI.Suggestions = new SuggestionsAPI.Suggestions(this._client);

  /**
   * @example
   * ```ts
   * const thread = await client.beta.threads.create({
   *   projectId: 'projectId',
   * });
   * ```
   */
  create(body: ThreadCreateParams, options?: RequestOptions): APIPromise<Thread> {
    return this._client.post('/threads', { body, ...options });
  }

  /**
   * @example
   * ```ts
   * const thread = await client.beta.threads.retrieve('id');
   * ```
   */
  retrieve(
    id: string,
    query: ThreadRetrieveParams | null | undefined = {},
    options?: RequestOptions,
  ): APIPromise<ThreadRetrieveResponse> {
    return this._client.get(path`/threads/${id}`, { query, ...options });
  }

  /**
   * @example
   * ```ts
   * const thread = await client.beta.threads.update('id', {
   *   projectId: 'projectId',
   * });
   * ```
   */
  update(id: string, body: ThreadUpdateParams, options?: RequestOptions): APIPromise<Thread> {
    return this._client.put(path`/threads/${id}`, { body, ...options });
  }

  /**
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const thread of client.beta.threads.list(
   *   'projectId',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(
    projectID: string,
    query: ThreadListParams | null | undefined = {},
    options?: RequestOptions,
  ): PagePromise<ThreadsOffsetAndLimit, Thread> {
    return this._client.getAPIList(path`/threads/project/${projectID}`, OffsetAndLimit<Thread>, {
      query,
      ...options,
    });
  }

  /**
   * @example
   * ```ts
   * await client.beta.threads.delete('id');
   * ```
   */
  delete(id: string, options?: RequestOptions): APIPromise<void> {
    return this._client.delete(path`/threads/${id}`, {
      ...options,
      headers: buildHeaders([{ Accept: '*/*' }, options?.headers]),
    });
  }

  /**
   * This endpoint has been deprecated. Use POST /advancestream instead.
   *
   * @deprecated
   */
  advance(options?: RequestOptions): APIPromise<ThreadAdvanceResponse> {
    return this._client.post('/threads/advance', options);
  }

  /**
   * This endpoint has been deprecated. Use POST /:id/advancestream instead.
   *
   * @deprecated
   */
  advanceByID(
    id: string,
    body: ThreadAdvanceByIDParams,
    options?: RequestOptions,
  ): APIPromise<ThreadAdvanceByIDResponse> {
    return this._client.post(path`/threads/${id}/advance`, { body, ...options });
  }

  /**
   * Sets a thread's generation stage to CANCELLED
   *
   * @example
   * ```ts
   * const thread = await client.beta.threads.cancel(
   *   'thread_123456789',
   * );
   * ```
   */
  cancel(id: string, options?: RequestOptions): APIPromise<Thread> {
    return this._client.post(path`/threads/${id}/cancel`, options);
  }

  /**
   * Automatically generates and sets a name for the thread as a summary based on its
   * messages.
   *
   * @example
   * ```ts
   * const thread = await client.beta.threads.generateName(
   *   'thread_123456789',
   * );
   * ```
   */
  generateName(
    id: string,
    params: ThreadGenerateNameParams | null | undefined = {},
    options?: RequestOptions,
  ): APIPromise<Thread> {
    const { contextKey } = params ?? {};
    return this._client.post(path`/threads/${id}/generate-name`, { query: { contextKey }, ...options });
  }
}

export type ThreadsOffsetAndLimit = OffsetAndLimit<Thread>;

export interface ChatCompletionContentPart {
  /**
   * The type of content part
   */
  type: 'text' | 'image_url' | 'input_audio' | 'resource';

  /**
   * Image URL content (when type is 'image_url')
   */
  image_url?: ChatCompletionContentPart.ImageURL;

  /**
   * Input audio content (when type is 'input_audio')
   */
  input_audio?: ChatCompletionContentPart.InputAudio;

  /**
   * Resource content (when type is 'resource'). Supports MCP Resources with URI,
   * text, or blob data.
   */
  resource?: Shared.Resource;

  /**
   * Text content (when type is 'text')
   */
  text?: string;
}

export namespace ChatCompletionContentPart {
  /**
   * Image URL content (when type is 'image_url')
   */
  export interface ImageURL {
    url: string;

    detail?: 'auto' | 'high' | 'low';
  }

  /**
   * Input audio content (when type is 'input_audio')
   */
  export interface InputAudio {
    data: string;

    format: 'wav' | 'mp3';
  }
}

export interface ComponentDecisionV2 {
  componentName: string | null;

  componentState: { [key: string]: unknown } | null;

  message: string;

  props: { [key: string]: unknown };

  completionStatusMessage?: string;

  statusMessage?: string;

  /**
   * The unique id of the tool call. This is filled in whether the tool call is a
   * server-side or client-side tool call.
   */
  toolCallId?: string;

  /**
   * The tool call request. This is filled in whether the tool call is a server-side
   * or client-side tool call.
   */
  toolCallRequest?: Shared.ToolCallRequest;
}

export interface Thread {
  id: string;

  createdAt: string;

  projectId: string;

  updatedAt: string;

  generationStage?:
    | 'IDLE'
    | 'CHOOSING_COMPONENT'
    | 'FETCHING_CONTEXT'
    | 'HYDRATING_COMPONENT'
    | 'STREAMING_RESPONSE'
    | 'COMPLETE'
    | 'ERROR'
    | 'CANCELLED';

  metadata?: { [key: string]: unknown };

  name?: string;

  statusMessage?: string;
}

export interface ThreadMessage {
  id: string;

  componentState: { [key: string]: unknown };

  content: Array<ChatCompletionContentPart>;

  createdAt: string;

  role: 'user' | 'assistant' | 'system' | 'tool';

  threadId: string;

  /**
   * @deprecated Deprecated: use the role and the presence of tool calls to determine
   * the action type
   */
  actionType?: 'tool_call' | 'tool_response';

  /**
   * Additional context to provide to the AI beyond the user query, such as the info
   * about the current page the user is visiting.
   */
  additionalContext?: { [key: string]: unknown };

  component?: ComponentDecisionV2;

  error?: string;

  /**
   * Whether the message has been cancelled
   */
  isCancelled?: boolean;

  metadata?: { [key: string]: unknown };

  /**
   * The id of the parent message, if the message was created during the generation
   * of another message, such as during an agent call, MCP Elicitation, or MCP Sample
   */
  parentMessageId?: string;

  /**
   * Reasoning text from the LLM, if the model supports it.
   */
  reasoning?: Array<string>;

  /**
   * Duration of reasoning in milliseconds
   */
  reasoningDurationMS?: number;

  /**
   * The unique id of the tool call. This is filled in only if the tool call is a
   * client-side tool call.
   */
  tool_call_id?: string;

  tool_calls?: Array<unknown>;

  /**
   * The tool call request. This is filled in only if the tool call is a client-side
   * tool call.
   */
  toolCallRequest?: Shared.ToolCallRequest;
}

export interface ThreadRetrieveResponse {
  id: string;

  createdAt: string;

  messages: Array<ThreadMessage>;

  projectId: string;

  updatedAt: string;

  generationStage?:
    | 'IDLE'
    | 'CHOOSING_COMPONENT'
    | 'FETCHING_CONTEXT'
    | 'HYDRATING_COMPONENT'
    | 'STREAMING_RESPONSE'
    | 'COMPLETE'
    | 'ERROR'
    | 'CANCELLED';

  metadata?: { [key: string]: unknown };

  name?: string;

  statusMessage?: string;
}

export interface ThreadAdvanceResponse {
  generationStage:
    | 'IDLE'
    | 'CHOOSING_COMPONENT'
    | 'FETCHING_CONTEXT'
    | 'HYDRATING_COMPONENT'
    | 'STREAMING_RESPONSE'
    | 'COMPLETE'
    | 'ERROR'
    | 'CANCELLED';

  /**
   * Response message
   */
  responseMessageDto: ThreadMessage;

  /**
   * MCP access token to be used as bearer token when talking to the Tambo MCP
   * server. Only included when MCP servers are configured for the project.
   */
  mcpAccessToken?: string;

  /**
   * Status message for the generation stage
   */
  statusMessage?: string;
}

export interface ThreadAdvanceByIDResponse {
  generationStage:
    | 'IDLE'
    | 'CHOOSING_COMPONENT'
    | 'FETCHING_CONTEXT'
    | 'HYDRATING_COMPONENT'
    | 'STREAMING_RESPONSE'
    | 'COMPLETE'
    | 'ERROR'
    | 'CANCELLED';

  /**
   * Response message
   */
  responseMessageDto: ThreadMessage;

  /**
   * MCP access token to be used as bearer token when talking to the Tambo MCP
   * server. Only included when MCP servers are configured for the project.
   */
  mcpAccessToken?: string;

  /**
   * Status message for the generation stage
   */
  statusMessage?: string;
}

export interface ThreadCreateParams {
  projectId: string;

  /**
   * Unique user identifier for the thread
   */
  contextKey?: string;

  generationStage?:
    | 'IDLE'
    | 'CHOOSING_COMPONENT'
    | 'FETCHING_CONTEXT'
    | 'HYDRATING_COMPONENT'
    | 'STREAMING_RESPONSE'
    | 'COMPLETE'
    | 'ERROR'
    | 'CANCELLED';

  metadata?: { [key: string]: unknown };

  name?: string;

  statusMessage?: string;
}

export interface ThreadRetrieveParams {
  contextKey?: string;

  includeInternal?: boolean;
}

export interface ThreadUpdateParams {
  projectId: string;

  /**
   * Unique user identifier for the thread
   */
  contextKey?: string;

  generationStage?:
    | 'IDLE'
    | 'CHOOSING_COMPONENT'
    | 'FETCHING_CONTEXT'
    | 'HYDRATING_COMPONENT'
    | 'STREAMING_RESPONSE'
    | 'COMPLETE'
    | 'ERROR'
    | 'CANCELLED';

  metadata?: { [key: string]: unknown };

  name?: string;

  statusMessage?: string;
}

export interface ThreadListParams extends OffsetAndLimitParams {
  /**
   * Unique user identifier for the thread
   */
  contextKey?: string;
}

export interface ThreadAdvanceByIDParams {
  messageToAppend: ThreadAdvanceByIDParams.MessageToAppend;

  availableComponents?: Array<Shared.AvailableComponent>;

  clientTools?: Array<Shared.ComponentContextToolMetadata>;

  /**
   * Unique user identifier for the thread
   */
  contextKey?: string;

  forceToolChoice?: string;

  /**
   * Initial messages to include when creating a new thread
   */
  initialMessages?: Array<ThreadAdvanceByIDParams.InitialMessage>;

  /**
   * Tool call counts
   */
  toolCallCounts?: { [key: string]: number };
}

export namespace ThreadAdvanceByIDParams {
  export interface MessageToAppend {
    content: Array<ThreadsAPI.ChatCompletionContentPart>;

    role: 'user' | 'assistant' | 'system' | 'tool';

    /**
     * @deprecated No longer used - instead set role and the tool call information
     */
    actionType?: 'tool_call' | 'tool_response';

    /**
     * Additional context to provide to the AI beyond the user query, such as the info
     * about the current page the user is visiting.
     */
    additionalContext?: { [key: string]: unknown };

    component?: ThreadsAPI.ComponentDecisionV2;

    /**
     * The initial state of the component
     */
    componentState?: { [key: string]: unknown };

    error?: string;

    /**
     * Whether the message has been cancelled
     */
    isCancelled?: boolean;

    metadata?: { [key: string]: unknown };

    /**
     * Reasoning text from the LLM, if the model supports it.
     */
    reasoning?: Array<string>;

    /**
     * Duration of reasoning in milliseconds
     */
    reasoningDurationMS?: number;

    tool_call_id?: string;

    toolCallRequest?: Shared.ToolCallRequest;

    /**
     * @deprecated Put the response in the content instead
     */
    toolResponse?: unknown;
  }

  export interface InitialMessage {
    content: Array<ThreadsAPI.ChatCompletionContentPart>;

    role: 'user' | 'assistant' | 'system' | 'tool';

    /**
     * @deprecated No longer used - instead set role and the tool call information
     */
    actionType?: 'tool_call' | 'tool_response';

    /**
     * Additional context to provide to the AI beyond the user query, such as the info
     * about the current page the user is visiting.
     */
    additionalContext?: { [key: string]: unknown };

    component?: ThreadsAPI.ComponentDecisionV2;

    /**
     * The initial state of the component
     */
    componentState?: { [key: string]: unknown };

    error?: string;

    /**
     * Whether the message has been cancelled
     */
    isCancelled?: boolean;

    metadata?: { [key: string]: unknown };

    /**
     * Reasoning text from the LLM, if the model supports it.
     */
    reasoning?: Array<string>;

    /**
     * Duration of reasoning in milliseconds
     */
    reasoningDurationMS?: number;

    tool_call_id?: string;

    toolCallRequest?: Shared.ToolCallRequest;

    /**
     * @deprecated Put the response in the content instead
     */
    toolResponse?: unknown;
  }
}

export interface ThreadGenerateNameParams {
  /**
   * Unique user identifier for the thread
   */
  contextKey?: string;
}

Threads.Messages = Messages;
Threads.Suggestions = Suggestions;

export declare namespace Threads {
  export {
    type ChatCompletionContentPart as ChatCompletionContentPart,
    type ComponentDecisionV2 as ComponentDecisionV2,
    type Thread as Thread,
    type ThreadMessage as ThreadMessage,
    type ThreadRetrieveResponse as ThreadRetrieveResponse,
    type ThreadAdvanceResponse as ThreadAdvanceResponse,
    type ThreadAdvanceByIDResponse as ThreadAdvanceByIDResponse,
    type ThreadsOffsetAndLimit as ThreadsOffsetAndLimit,
    type ThreadCreateParams as ThreadCreateParams,
    type ThreadRetrieveParams as ThreadRetrieveParams,
    type ThreadUpdateParams as ThreadUpdateParams,
    type ThreadListParams as ThreadListParams,
    type ThreadAdvanceByIDParams as ThreadAdvanceByIDParams,
    type ThreadGenerateNameParams as ThreadGenerateNameParams,
  };

  export {
    Messages as Messages,
    type MessageCreateResponse as MessageCreateResponse,
    type MessageListResponse as MessageListResponse,
    type MessageCreateParams as MessageCreateParams,
    type MessageListParams as MessageListParams,
    type MessageDeleteParams as MessageDeleteParams,
    type MessageUpdateComponentStateParams as MessageUpdateComponentStateParams,
  };

  export {
    Suggestions as Suggestions,
    type Suggestion as Suggestion,
    type SuggestionsGenerate as SuggestionsGenerate,
    type SuggestionListResponse as SuggestionListResponse,
    type SuggestionGenerateResponse as SuggestionGenerateResponse,
    type SuggestionListParams as SuggestionListParams,
    type SuggestionGenerateParams as SuggestionGenerateParams,
  };
}
