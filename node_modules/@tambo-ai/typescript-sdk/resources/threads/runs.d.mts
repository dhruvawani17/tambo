import { APIResource } from "../../core/resource.mjs";
import * as RunsAPI from "./runs.mjs";
import * as ThreadsAPI from "./threads.mjs";
import { APIPromise } from "../../core/api-promise.mjs";
import { Stream } from "../../core/streaming.mjs";
import { RequestOptions } from "../../internal/request-options.mjs";
export declare class Runs extends APIResource {
    /**
     * Creates a new thread and immediately starts a streaming run. Returns an SSE
     * stream of AG-UI events.
     *
     * @example
     * ```ts
     * const run = await client.threads.runs.create({
     *   message: {
     *     content: [{ text: 'Hello, world!', type: 'text' }],
     *     role: 'user',
     *   },
     * });
     * ```
     */
    create(body: RunCreateParams, options?: RequestOptions): APIPromise<Stream<RunCreateResponse>>;
    /**
     * Explicitly cancel a running run. Note: closing the SSE connection also cancels
     * the run.
     *
     * @example
     * ```ts
     * const run = await client.threads.runs.delete(
     *   'run_xyz789abc',
     *   { threadId: 'thr_abc123xyz' },
     * );
     * ```
     */
    delete(runID: string, params: RunDeleteParams, options?: RequestOptions): APIPromise<RunDeleteResponse>;
    /**
     * Starts a streaming run on an existing thread. Returns an SSE stream of AG-UI
     * events.
     *
     * @example
     * ```ts
     * const response = await client.threads.runs.run(
     *   'thr_abc123xyz',
     *   {
     *     message: {
     *       content: [{ text: 'Hello, world!', type: 'text' }],
     *       role: 'user',
     *     },
     *   },
     * );
     * ```
     */
    run(threadID: string, body: RunRunParams, options?: RequestOptions): APIPromise<Stream<RunRunResponse>>;
}
export interface InputMessage {
    /**
     * Content blocks (text, resource, or tool_result)
     */
    content: Array<ThreadsAPI.TextContent | ThreadsAPI.ResourceContent | ThreadsAPI.ToolResultContent>;
    /**
     * Message role - must be 'user' for input messages
     */
    role: 'user';
    /**
     * Additional metadata to attach to the message
     */
    metadata?: unknown;
}
export interface RunCreateResponse {
    /**
     * Event type discriminator (e.g., RUN_STARTED, TEXT_MESSAGE_CONTENT,
     * TOOL_CALL_START)
     */
    type: string;
    /**
     * Unix timestamp (milliseconds) when event was generated
     */
    timestamp?: number;
}
export interface RunDeleteResponse {
    /**
     * The run ID that was cancelled
     */
    runId: string;
    /**
     * New status after cancellation (always 'cancelled')
     */
    status: 'cancelled';
}
export interface RunRunResponse {
    /**
     * Event type discriminator (e.g., RUN_STARTED, TEXT_MESSAGE_CONTENT,
     * TOOL_CALL_START)
     */
    type: string;
    /**
     * Unix timestamp (milliseconds) when event was generated
     */
    timestamp?: number;
}
export interface RunCreateParams {
    /**
     * The user's message
     */
    message: InputMessage;
    /**
     * Available UI components the model can render
     */
    availableComponents?: Array<RunCreateParams.AvailableComponent>;
    /**
     * Maximum tokens to generate
     */
    maxTokens?: number;
    /**
     * Override the default model
     */
    model?: string;
    /**
     * ID of the previous run. Required when continuing a thread that already has
     * messages.
     */
    previousRunId?: string;
    /**
     * Metadata for the run
     */
    runMetadata?: unknown;
    /**
     * Temperature for generation (0-2)
     */
    temperature?: number;
    /**
     * Thread configuration
     */
    thread?: RunCreateParams.Thread;
    /**
     * Metadata for the thread
     */
    threadMetadata?: unknown;
    /**
     * How the model should use tools
     */
    toolChoice?: 'auto' | 'required' | 'none' | RunCreateParams.Name;
    /**
     * Client-side tools the model can call
     */
    tools?: Array<RunCreateParams.Tool>;
    /**
     * Optional user key for thread organization
     */
    userKey?: string;
}
export declare namespace RunCreateParams {
    interface AvailableComponent {
        /**
         * Description of what this component displays
         */
        description: string;
        /**
         * Component name (e.g., 'StockChart')
         */
        name: string;
        /**
         * JSON Schema for component props
         */
        propsSchema: unknown;
        /**
         * Optional JSON Schema for component state
         */
        stateSchema?: unknown;
    }
    /**
     * Thread configuration
     */
    interface Thread {
        /**
         * Initial messages to seed the thread with
         */
        initialMessages?: Array<RunsAPI.InputMessage>;
        /**
         * Additional metadata to attach to the thread
         */
        metadata?: unknown;
        /**
         * Optional user key for thread organization
         */
        userKey?: string;
    }
    interface Name {
        name?: string;
    }
    interface Tool {
        /**
         * Description of what the tool does
         */
        description: string;
        /**
         * JSON Schema for the tool's input parameters
         */
        inputSchema: unknown;
        /**
         * Unique tool name (a-z, A-Z, 0-9, \_, -)
         */
        name: string;
        /**
         * Optional JSON Schema for structured output
         */
        outputSchema?: unknown;
        /**
         * Enable strict schema validation (OpenAI feature)
         */
        strict?: boolean;
    }
}
export interface RunDeleteParams {
    /**
     * Thread ID
     */
    threadId: string;
}
export interface RunRunParams {
    /**
     * The user's message
     */
    message: InputMessage;
    /**
     * Available UI components the model can render
     */
    availableComponents?: Array<RunRunParams.AvailableComponent>;
    /**
     * Maximum tokens to generate
     */
    maxTokens?: number;
    /**
     * Override the default model
     */
    model?: string;
    /**
     * ID of the previous run. Required when continuing a thread that already has
     * messages.
     */
    previousRunId?: string;
    /**
     * Metadata for the run
     */
    runMetadata?: unknown;
    /**
     * Temperature for generation (0-2)
     */
    temperature?: number;
    /**
     * How the model should use tools
     */
    toolChoice?: 'auto' | 'required' | 'none' | RunRunParams.Name;
    /**
     * Client-side tools the model can call
     */
    tools?: Array<RunRunParams.Tool>;
    /**
     * Optional user key for thread organization
     */
    userKey?: string;
}
export declare namespace RunRunParams {
    interface AvailableComponent {
        /**
         * Description of what this component displays
         */
        description: string;
        /**
         * Component name (e.g., 'StockChart')
         */
        name: string;
        /**
         * JSON Schema for component props
         */
        propsSchema: unknown;
        /**
         * Optional JSON Schema for component state
         */
        stateSchema?: unknown;
    }
    interface Name {
        name?: string;
    }
    interface Tool {
        /**
         * Description of what the tool does
         */
        description: string;
        /**
         * JSON Schema for the tool's input parameters
         */
        inputSchema: unknown;
        /**
         * Unique tool name (a-z, A-Z, 0-9, \_, -)
         */
        name: string;
        /**
         * Optional JSON Schema for structured output
         */
        outputSchema?: unknown;
        /**
         * Enable strict schema validation (OpenAI feature)
         */
        strict?: boolean;
    }
}
export declare namespace Runs {
    export { type InputMessage as InputMessage, type RunCreateResponse as RunCreateResponse, type RunDeleteResponse as RunDeleteResponse, type RunRunResponse as RunRunResponse, type RunCreateParams as RunCreateParams, type RunDeleteParams as RunDeleteParams, type RunRunParams as RunRunParams, };
}
//# sourceMappingURL=runs.d.mts.map