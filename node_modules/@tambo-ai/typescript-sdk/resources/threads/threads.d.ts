import { APIResource } from "../../core/resource.js";
import * as ThreadsAPI from "./threads.js";
import * as Shared from "../shared.js";
import * as MessagesAPI from "./messages.js";
import { MessageGetParams, MessageGetResponse, MessageListParams, MessageListResponse, Messages } from "./messages.js";
import * as RunsAPI from "./runs.js";
import { InputMessage, RunCreateParams, RunCreateResponse, RunDeleteParams, RunDeleteResponse, RunRunParams, RunRunResponse, Runs } from "./runs.js";
import * as StateAPI from "./state.js";
import { State, StateUpdateStateParams, StateUpdateStateResponse } from "./state.js";
import { APIPromise } from "../../core/api-promise.js";
import { RequestOptions } from "../../internal/request-options.js";
export declare class Threads extends APIResource {
    state: StateAPI.State;
    messages: MessagesAPI.Messages;
    runs: RunsAPI.Runs;
    /**
     * Create a new empty thread. Note: initialMessages is not supported yet; create
     * the thread first, then add messages via runs/message endpoints.
     *
     * @example
     * ```ts
     * const thread = await client.threads.create();
     * ```
     */
    create(body: ThreadCreateParams, options?: RequestOptions): APIPromise<ThreadCreateResponse>;
    /**
     * Get a thread by ID with all its messages. The thread must belong to the
     * authenticated project.
     *
     * @example
     * ```ts
     * const thread = await client.threads.retrieve(
     *   'thr_abc123xyz',
     * );
     * ```
     */
    retrieve(threadID: string, query?: ThreadRetrieveParams | null | undefined, options?: RequestOptions): APIPromise<ThreadRetrieveResponse>;
    /**
     * List all threads for the authenticated project. Supports cursor-based pagination
     * and filtering by user key.
     *
     * @example
     * ```ts
     * const threads = await client.threads.list();
     * ```
     */
    list(query?: ThreadListParams | null | undefined, options?: RequestOptions): APIPromise<ThreadListResponse>;
    /**
     * Delete a thread and all its messages. This action cannot be undone.
     *
     * @example
     * ```ts
     * await client.threads.delete('thr_abc123xyz');
     * ```
     */
    delete(threadID: string, options?: RequestOptions): APIPromise<void>;
}
export interface ComponentContent {
    /**
     * Unique identifier for this component instance
     */
    id: string;
    /**
     * Name of the component to render
     */
    name: string;
    /**
     * Props to pass to the component
     */
    props: unknown;
    /**
     * Content block type identifier
     */
    type: 'component';
    /**
     * Current state of the component
     */
    state?: unknown;
}
export interface ResourceContent {
    /**
     * Resource data containing URI, text, or blob
     */
    resource: Shared.Resource;
    /**
     * Content block type identifier
     */
    type: 'resource';
}
export interface RunError {
    /**
     * Error message
     */
    message: string;
    /**
     * Error code
     */
    code?: string;
}
export interface TextContent {
    /**
     * The text content
     */
    text: string;
    /**
     * Content block type identifier
     */
    type: 'text';
}
export interface ToolResultContent {
    /**
     * Result content (text or resource blocks)
     */
    content: Array<TextContent | ResourceContent>;
    /**
     * ID of the tool call this result responds to
     */
    toolUseId: string;
    /**
     * Content block type identifier
     */
    type: 'tool_result';
    /**
     * Whether the tool call resulted in an error
     */
    isError?: boolean;
}
export interface ToolUseContent {
    /**
     * Unique identifier for this tool call
     */
    id: string;
    /**
     * Input arguments for the tool
     */
    input: unknown;
    /**
     * Name of the tool being called
     */
    name: string;
    /**
     * Content block type identifier
     */
    type: 'tool_use';
}
export interface ThreadCreateResponse {
    /**
     * Unique identifier for this thread
     */
    id: string;
    /**
     * When the thread was created (ISO 8601)
     */
    createdAt: string;
    /**
     * Current run status: idle (no run), waiting (run started, awaiting content),
     * streaming (receiving content)
     */
    runStatus: 'idle' | 'waiting' | 'streaming';
    /**
     * When the thread was last updated (ISO 8601)
     */
    updatedAt: string;
    /**
     * ID of the currently active run (when not idle)
     */
    currentRunId?: string;
    /**
     * ID of the last completed run. Required as previousRunId when continuing after
     * tool calls.
     */
    lastCompletedRunId?: string;
    /**
     * Whether the last run was cancelled
     */
    lastRunCancelled?: boolean;
    /**
     * Error information from the last run
     */
    lastRunError?: RunError;
    /**
     * Additional metadata
     */
    metadata?: unknown;
    /**
     * Tool call IDs awaiting client-side results. If non-empty, next run must provide
     * tool_result content with previousRunId set.
     */
    pendingToolCallIds?: Array<string>;
    /**
     * Human-readable status message (e.g., 'Fetching weather data...')
     */
    statusMessage?: string;
    /**
     * Optional user key for thread organization
     */
    userKey?: string;
}
export interface ThreadRetrieveResponse {
    /**
     * Unique identifier for this thread
     */
    id: string;
    /**
     * When the thread was created (ISO 8601)
     */
    createdAt: string;
    /**
     * Messages in this thread
     */
    messages: Array<ThreadRetrieveResponse.Message>;
    /**
     * Current run status: idle (no run), waiting (run started, awaiting content),
     * streaming (receiving content)
     */
    runStatus: 'idle' | 'waiting' | 'streaming';
    /**
     * When the thread was last updated (ISO 8601)
     */
    updatedAt: string;
    /**
     * ID of the currently active run (when not idle)
     */
    currentRunId?: string;
    /**
     * ID of the last completed run. Required as previousRunId when continuing after
     * tool calls.
     */
    lastCompletedRunId?: string;
    /**
     * Whether the last run was cancelled
     */
    lastRunCancelled?: boolean;
    /**
     * Error information from the last run
     */
    lastRunError?: RunError;
    /**
     * Additional metadata
     */
    metadata?: unknown;
    /**
     * Tool call IDs awaiting client-side results. If non-empty, next run must provide
     * tool_result content with previousRunId set.
     */
    pendingToolCallIds?: Array<string>;
    /**
     * Human-readable status message (e.g., 'Fetching weather data...')
     */
    statusMessage?: string;
    /**
     * Optional user key for thread organization
     */
    userKey?: string;
}
export declare namespace ThreadRetrieveResponse {
    interface Message {
        /**
         * Unique identifier for this message
         */
        id: string;
        /**
         * Content blocks in this message
         */
        content: Array<ThreadsAPI.TextContent | ThreadsAPI.ResourceContent | ThreadsAPI.ToolUseContent | ThreadsAPI.ToolResultContent | ThreadsAPI.ComponentContent>;
        /**
         * Message role
         */
        role: 'user' | 'assistant' | 'system';
        /**
         * When the message was created (ISO 8601)
         */
        createdAt?: string;
        /**
         * Additional metadata
         */
        metadata?: unknown;
    }
}
export interface ThreadListResponse {
    /**
     * Whether there are more results
     */
    hasMore: boolean;
    /**
     * List of threads
     */
    threads: Array<ThreadListResponse.Thread>;
    /**
     * Cursor for the next page of results
     */
    nextCursor?: string;
}
export declare namespace ThreadListResponse {
    interface Thread {
        /**
         * Unique identifier for this thread
         */
        id: string;
        /**
         * When the thread was created (ISO 8601)
         */
        createdAt: string;
        /**
         * Current run status: idle (no run), waiting (run started, awaiting content),
         * streaming (receiving content)
         */
        runStatus: 'idle' | 'waiting' | 'streaming';
        /**
         * When the thread was last updated (ISO 8601)
         */
        updatedAt: string;
        /**
         * ID of the currently active run (when not idle)
         */
        currentRunId?: string;
        /**
         * ID of the last completed run. Required as previousRunId when continuing after
         * tool calls.
         */
        lastCompletedRunId?: string;
        /**
         * Whether the last run was cancelled
         */
        lastRunCancelled?: boolean;
        /**
         * Error information from the last run
         */
        lastRunError?: ThreadsAPI.RunError;
        /**
         * Additional metadata
         */
        metadata?: unknown;
        /**
         * Tool call IDs awaiting client-side results. If non-empty, next run must provide
         * tool_result content with previousRunId set.
         */
        pendingToolCallIds?: Array<string>;
        /**
         * Human-readable status message (e.g., 'Fetching weather data...')
         */
        statusMessage?: string;
        /**
         * Optional user key for thread organization
         */
        userKey?: string;
    }
}
export interface ThreadCreateParams {
    /**
     * Initial messages to seed the thread with
     */
    initialMessages?: Array<RunsAPI.InputMessage>;
    /**
     * Additional metadata to attach to the thread
     */
    metadata?: unknown;
    /**
     * Optional user key for thread organization
     */
    userKey?: string;
}
export interface ThreadRetrieveParams {
    /**
     * Optional user key for thread organization
     */
    userKey?: string;
}
export interface ThreadListParams {
    /**
     * Cursor for pagination
     */
    cursor?: string;
    /**
     * Maximum number of threads to return
     */
    limit?: string;
    /**
     * Filter by user key
     */
    userKey?: string;
}
export declare namespace Threads {
    export { type ComponentContent as ComponentContent, type ResourceContent as ResourceContent, type RunError as RunError, type TextContent as TextContent, type ToolResultContent as ToolResultContent, type ToolUseContent as ToolUseContent, type ThreadCreateResponse as ThreadCreateResponse, type ThreadRetrieveResponse as ThreadRetrieveResponse, type ThreadListResponse as ThreadListResponse, type ThreadCreateParams as ThreadCreateParams, type ThreadRetrieveParams as ThreadRetrieveParams, type ThreadListParams as ThreadListParams, };
    export { State as State, type StateUpdateStateResponse as StateUpdateStateResponse, type StateUpdateStateParams as StateUpdateStateParams, };
    export { Messages as Messages, type MessageListResponse as MessageListResponse, type MessageGetResponse as MessageGetResponse, type MessageListParams as MessageListParams, type MessageGetParams as MessageGetParams, };
    export { Runs as Runs, type InputMessage as InputMessage, type RunCreateResponse as RunCreateResponse, type RunDeleteResponse as RunDeleteResponse, type RunRunResponse as RunRunResponse, type RunCreateParams as RunCreateParams, type RunDeleteParams as RunDeleteParams, type RunRunParams as RunRunParams, };
}
//# sourceMappingURL=threads.d.ts.map